---
title: "Rust 语言基础之枚举与模式匹配"
description: "掌握 Rust 强大的枚举类型和 match 模式匹配，学习如何编写安全且富有表达力的代码。"
date: "2025-11-30"
seriesOrder: 16
---

# 16. Rust 语言基础之枚举与模式匹配

## 引言

在许多语言（如 C、Java、TypeScript）中，枚举 (Enum) 通常只是一组命名的常量。
但在 Rust 中，枚举要强大得多。它不仅可以列举可能的变体，还可以**携带数据**。这使得 Rust 的枚举更像函数式编程语言中的**代数数据类型 (Algebraic Data Types)**。

此外，Rust 还有一个杀手级特性——**模式匹配 (Pattern Matching)**，它与枚举结合使用，能写出极具表达力且安全的代码。

## 1. 定义枚举

最简单的枚举形式：

```rust
enum IpAddrKind {
    V4,
    V6,
}

let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```

## 2. 携带数据的枚举

Rust 的枚举变体可以包含不同类型和数量的数据。

```rust
enum Message {
    Quit,                       // 没有关联数据
    Move { x: i32, y: i32 },    // 包含一个匿名结构体
    Write(String),              // 包含一个 String
    ChangeColor(i32, i32, i32), // 包含三个 i32
}
```

这比定义一组结构体要好得多，因为它们都属于同一个类型 `Message`，可以被同一个函数处理。

## 3. Option 枚举：告别 Null

Rust 没有 `null`。
在其他语言中，`null` 经常导致 "Null Pointer Exception"（十亿美元的错误）。

Rust 使用 `Option<T>` 枚举来表示"值可能存在，也可能不存在"。它在标准库中定义如下：

```rust
enum Option<T> {
    None,
    Some(T),
}
```

*   **`Some(T)`**：表示有一个值 T。
*   **`None`**：表示没有值（类似 null）。

**为什么这更安全？**
因为 `Option<T>` 和 `T` 是不同的类型。你不能直接把 `Option<T>` 当作 `T` 来使用。你**必须**显式地处理 `None` 的情况（通常通过 `match`），这在编译期就杜绝了空指针异常。

## 4. match 控制流运算符

`match` 允许我们将一个值与一系列**模式**进行比较，并根据匹配的模式执行相应的代码。它就像是加强版的 `switch`。

```rust
enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter => 25,
    }
}
```

### 4.1 绑定值

`match` 可以从枚举变体中提取数据。

```rust
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

match home {
    IpAddr::V4(a, b, c, d) => {
        println!("IPv4: {}.{}.{}.{}", a, b, c, d);
    },
    IpAddr::V6(s) => {
        println!("IPv6: {}", s);
    },
}
```

### 4.2 穷尽性检查 (Exhaustiveness)

`match` 必须覆盖所有可能的情况。如果你漏掉了一个变体，编译器会报错。这是 Rust 安全性的重要保证。

如果你不想处理所有情况，可以使用 `_` 通配符：

```rust
let some_u8_value = 0u8;
match some_u8_value {
    1 => println!("one"),
    3 => println!("three"),
    _ => (), // 匹配所有其他情况，什么也不做
}
```

## 5. if let 语法糖

当你只关心**一种**匹配情况，而忽略其他所有情况时，`match` 显得有点啰嗦。这时可以使用 `if let`。

**使用 match:**
```rust
let config_max = Some(3u8);
match config_max {
    Some(max) => println!("The maximum is configured to be {}", max),
    _ => (),
}
```

**使用 if let:**
```rust
let config_max = Some(3u8);
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max);
}
```

`if let` 读作："如果 `config_max` 匹配 `Some(max)` 模式，则执行..."。

## 6. 总结

1.  **Enum** 可以携带数据，是 Rust 中处理复合数据的强大工具。
2.  **Option** 替代了 Null，强制开发者处理空值情况。
3.  **match** 提供了强大的模式匹配能力，且编译器会检查是否覆盖了所有情况。
4.  **if let** 是处理单一匹配情况的简洁语法。

到目前为止，我们已经掌握了 Rust 的大部分基础语法。下一篇，我们将介绍 Rust 中实现多态和代码复用的核心机制——**Trait (特征)** 和 **泛型 (Generics)**。

---

