---
title: "Rust 语言基础之流程控制"
description: "掌握 Rust 的流程控制：if 表达式、循环、以及强大的 match 模式匹配。"
date: "2025-11-30"
seriesOrder: 10
---

# 10. Rust 语言基础之流程控制

## 引言

任何编程语言的核心都离不开流程控制：决定代码执行的顺序。

Rust 的流程控制语法（`if`, `while`, `for`）看起来与 JavaScript 非常相似，但它们有一个本质的区别：**在 Rust 中，大多数流程控制结构都是表达式（Expression），这意味着它们有返回值。**

此外，Rust 还有一个杀手级特性：`match` 模式匹配，它比 JS 的 `switch` 强大得多。

本篇文章将带你掌握 Rust 的流程控制。

## 1. if 表达式

### 1.1 基本用法

Rust 的 `if` 语法不需要像 JS 那样给条件加括号 `()`，但代码块必须加花括号 `{}`。

```rust
let number = 3;

if number < 5 {
    println!("condition was true");
} else {
    println!("condition was false");
}
```

**注意**：条件必须是 `bool` 类型。Rust 不会将数字或字符串自动转换为布尔值（没有 Truthy/Falsy 概念）。
*   `if number { ... }` 是错误的。
*   必须写成 `if number != 0 { ... }`。

### 1.2 if 是表达式

这是 Rust 与 JS 的一个重要区别。`if` 结构本身是一个表达式，可以返回值。我们可以利用这一点将 `if` 的结果赋给变量。

```rust
let condition = true;
// 类似 JS 的三元运算符 condition ? 5 : 6
let number = if condition { 5 } else { 6 };

println!("The value of number is: {}", number);
```

**要求**：`if` 和 `else` 分支返回的值类型必须相同。

## 2. 循环 (Loops)

Rust 提供了三种循环：`loop`, `while`, `for`。

### 2.1 loop (无限循环)

`loop` 关键字告诉 Rust 永远重复执行一段代码，直到你显式使用 `break` 停止。

```rust
let mut count = 0;
loop {
    count += 1;
    if count == 3 {
        break; // 跳出循环
    }
}
```

**loop 也是表达式**：你可以从 `loop` 中返回值。

```rust
let mut counter = 0;
let result = loop {
    counter += 1;
    if counter == 10 {
        break counter * 2; // 返回 20
    }
};
```

### 2.2 while (条件循环)

与 JS 的 `while` 完全一致。

```rust
let mut number = 3;
while number != 0 {
    println!("{}!", number);
    number -= 1;
}
```

### 2.3 for (遍历集合)

这是 Rust 中最常用的循环方式，类似于 JS 的 `for...of`。它比 `while` 更安全、更快速（因为它不需要在每次迭代时检查索引边界）。

```rust
let a = [10, 20, 30, 40, 50];

// 遍历数组
for element in a {
    println!("the value is: {}", element);
}

// 遍历范围 (Range)
// 1..4 生成 1, 2, 3 (不包含 4)
for number in 1..4 {
    println!("{}!", number);
}

// 1..=4 生成 1, 2, 3, 4 (包含 4)
for number in 1..=4 { ... }
```

## 3. match 模式匹配 (Pattern Matching)

`match` 是 Rust 中最强大的控制流运算符。它类似于 JS 的 `switch`，但要强大得多。它可以匹配字面量、范围、解构复杂数据类型，并且编译器会强制要求你处理**所有可能的情况**（Exhaustiveness）。

### 3.1 基本用法

```rust
let number = 3;

match number {
    1 => println!("One"),
    2 => println!("Two"),
    3 => println!("Three"),
    _ => println!("Other"), // _ 通配符，类似 default
}
```

### 3.2 匹配范围和多值

```rust
let x = 1;

match x {
    1 | 2 => println!("One or Two"), // 匹配多个值
    3..=5 => println!("Three through Five"), // 匹配范围
    _ => println!("Anything else"),
}
```

### 3.3 解构并绑定值

`match` 可以深入数据结构内部，提取值。

```rust
enum Action {
    Click,
    Move { x: i32, y: i32 },
    Write(String),
}

let action = Action::Move { x: 10, y: 20 };

match action {
    Action::Click => println!("Clicked"),
    // 解构 Move 变体中的 x 和 y
    Action::Move { x, y } => println!("Moved to x: {}, y: {}", x, y),
    Action::Write(text) => println!("Text: {}", text),
}
```

这种能力让处理复杂数据结构变得异常简单和安全。

## 4. if let 语法

`match` 强制要求处理所有情况。但有时我们只关心一种情况，忽略其他所有情况。这时可以用 `if let`，它是 `match` 的语法糖。

```rust
let config_max = Some(3u8);

// 使用 match (有点繁琐)
match config_max {
    Some(max) => println!("The maximum is configured to be {}", max),
    _ => (), // 必须写这一行来处理 None
}

// 使用 if let (简洁)
if let Some(max) = config_max {
    println!("The maximum is configured to be {}", max);
}
```

**解读**：`if let 模式 = 表达式`。如果表达式匹配这个模式，就执行代码块。

## 5. JS / Go / Rust 对比

| 特性 | JavaScript | Go | Rust |
| :--- | :--- | :--- | :--- |
| **条件括号** | `if (x > 0)` | `if x > 0` | `if x > 0` |
| **if 返回值** | 不支持 (用三元) | 不支持 | ✅ 支持 |
| **switch/match** | `switch` (松散) | `switch` (无 fall-through) | `match` (穷尽检查) |
| **无限循环** | `while(true)` | `for {}` | `loop {}` |
| **范围遍历** | `for(let i=0;i<n;i++)` | `for i := 0; i < n; i++` | `for i in 0..n` |
| **迭代遍历** | `for...of` | `for _, v := range arr` | `for v in arr` |

**Go 与 Rust 的相似点**：
- 都不需要条件括号
- 都没有三元运算符 `? :`

**Go 与 Rust 的区别**：
- Go 的 `switch` 默认 break，Rust 的 `match` 强制穷尽
- Rust 的 `if`/`match`/`loop` 都是表达式，可以返回值
- Rust 用 `..` 表示范围，Go 没有原生 Range 语法

## 6. 总结

Rust 的流程控制既熟悉又新颖：

1.  **if 是表达式**：可以返回值，替代三元运算符。
2.  **for 循环**：最常用，配合 Range (`1..4`) 使用很方便。
3.  **match**：Rust 的杀手锏，强制穷尽所有可能性，彻底消灭 `switch` 的遗漏 bug。
4.  **if let**：处理单一匹配场景的语法糖。

掌握了流程控制，我们就可以开始处理更复杂的数据结构了。下一篇，我们将学习 Rust 中的数组和元组。

---

