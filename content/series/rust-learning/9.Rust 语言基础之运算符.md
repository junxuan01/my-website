---
title: "Rust 语言基础之运算符"
description: "全面介绍 Rust 的运算符系统：算术、比较、逻辑、位运算以及引用和解引用。"
date: "2025-11-30"
seriesOrder: 9
---

# 9. Rust 语言基础之运算符

## 引言

运算符是编程语言中最基础的构建块。Rust 的运算符大部分与 JavaScript 相似，这对于前端开发者来说是个好消息。

然而，由于 Rust 独特的内存模型（所有权和借用），它引入了一些 JS 中没有的特殊运算符，如引用 `&` 和解引用 `*`。此外，Rust 不支持 `++` 和 `--` 自增自减运算符，这可能会让初学者感到意外。

本篇文章将全面介绍 Rust 的运算符系统。

## 1. 算术运算符 (Arithmetic Operators)

Rust 支持标准的算术运算：`+`, `-`, `*`, `/`, `%`。

```rust
fn main() {
    // 加法
    let sum = 5 + 10;

    // 减法
    let difference = 95.5 - 4.3;

    // 乘法
    let product = 4 * 30;

    // 除法
    let quotient = 56.7 / 32.2;
    let floored = 2 / 3; // 结果为 0 (整数除法向零取整)

    // 取余
    let remainder = 43 % 5;
}
```

### 1.1 为什么没有 `++` 和 `--`？

在 JS 和 C/C++ 中，`i++` 是非常常见的。但在 Rust 中，**不支持**自增和自减运算符。

原因：
1.  **歧义性**：`x++` 返回旧值，`++x` 返回新值，这容易造成混淆。
2.  **求值顺序**：在复杂表达式中，自增运算符的求值顺序可能导致未定义行为。

**替代方案**：使用 `+= 1` 和 `-= 1`。

```rust
let mut x = 5;
x += 1; // 替代 x++
```

## 2. 比较运算符 (Comparison Operators)

Rust 的比较运算符与 JS 基本一致：`==`, `!=`, `>`, `<`, `>=`, `<=`。

**注意**：
*   Rust 是强类型语言，不同类型之间不能直接比较（例如 `i32` 和 `f64` 不能比）。
*   `==` 比较的是**值**（Value），而不是引用地址（这与 JS 的对象比较不同）。只要两个复杂类型（如结构体）实现了 `PartialEq` 特征，且内容相同，它们就相等。

## 3. 逻辑运算符 (Logical Operators)

*   `&&`：逻辑与（短路求值）。
*   `||`：逻辑或（短路求值）。
*   `!`：逻辑非。

```rust
let a = true;
let b = false;
if a && !b {
    println!("True!");
}
```

## 4. 位运算符 (Bitwise Operators)

用于直接操作二进制位。

*   `&`：按位与
*   `|`：按位或
*   `^`：按位异或
*   `!`：按位取反（注意：JS 中是 `~`）
*   `<<`：左移
*   `>>`：右移

## 5. 引用与解引用 (Reference & Dereference)

这是 Rust 中最重要的一组运算符，涉及所有权和借用。

### 5.1 引用 `&`

创建一个指向值的引用（借用），允许你使用值但不获取所有权。

```rust
let x = 5;
let y = &x; // y 是对 x 的引用
```

### 5.2 解引用 `*`

通过引用访问其指向的实际值。

```rust
let x = 5;
let y = &x;

assert_eq!(5, x);
assert_eq!(5, *y); // 解引用 y 来获取值 5
```

**JS 对比**：这有点像 C 指针。JS 中的对象默认就是引用传递，但你不能显式地对基本类型（如 number）取引用。

## 6. 赋值运算符

Rust 支持复合赋值运算符：`=`, `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`。

注意：赋值表达式（如 `x = y`）在 Rust 中返回单元类型 `()`，而不是被赋的值。这意味着你不能写 `a = b = c` 这样的链式赋值。

## 7. 运算符重载 (Operator Overloading)

Rust 允许你为自定义类型（如结构体）重载运算符。这是通过实现 `std::ops` 下的 Trait（特征）来实现的。

例如，如果你想让两个 `Point` 结构体相加：

```rust
use std::ops::Add;

#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

// 实现 Add 特征
impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 1, y: 0 };
    let p2 = Point { x: 2, y: 3 };
    let p3 = p1 + p2; // 魔法发生在这里
    println!("{:?}", p3); // Point { x: 3, y: 3 }
}
```

这比 JS 灵活得多，JS 不支持自定义运算符重载。

## 8. 总结

Rust 的运算符系统在保持熟悉感的同时，为了安全性和清晰性做了一些取舍（如移除 `++`）。

1.  **算术**：标准加减乘除，注意整数除法。
2.  **自增**：没有 `++`，请用 `+= 1`。
3.  **引用**：`&` 取引用，`*` 解引用。
4.  **重载**：可以通过 Trait 实现自定义类型的运算符行为。

掌握了运算符，我们就可以开始编写复杂的逻辑了。下一篇，我们将学习 Rust 的流程控制（if, loop, match）。

---

