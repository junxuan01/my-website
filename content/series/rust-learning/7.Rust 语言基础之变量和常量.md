---
title: "Rust 语言基础之变量和常量"
description: "深入理解 Rust 的变量系统：不可变性、可变变量、常量和遮蔽的概念。"
date: "2025-11-30"
seriesOrder: 7
---

# 7. Rust 语言基础之变量和常量

## 引言

在 JavaScript 中，我们经历了从 `var` 到 `let` 和 `const` 的演变。`let` 声明变量，`const` 声明常量。

Rust 的变量声明看起来和 JavaScript 非常像，都使用 `let` 和 `const` 关键字。但是，它们的行为逻辑（尤其是**不可变性**）有着本质的区别。

本篇文章将带你深入理解 Rust 的变量系统，这是理解后续"所有权"概念的基础。

## 1. 变量的不可变性 (Immutability)

### 1.1 默认不可变

在 JavaScript 中，`let` 声明的变量默认是可变的：

```javascript
// JavaScript
let x = 5;
x = 6; // 没问题
```

但在 Rust 中，**变量默认是不可变的 (Immutable)**。

```rust
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    // x = 6; // 编译错误！cannot assign twice to immutable variable `x`
}
```

这是 Rust 安全性的基石之一。如果一个变量不应该被修改，编译器会确保它真的不会被修改。这在并发编程中尤为重要（只读数据是线程安全的）。

### 1.2 可变变量 (mut)

如果你想修改变量的值，必须显式地使用 `mut` 关键字（Mutable）。

```rust
fn main() {
    let mut x = 5; // 注意这里的 mut
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

这不仅告诉编译器这个变量可以变，也告诉阅读代码的人：注意，这个变量的值可能会在后面被修改。

## 2. 常量 (Constants)

Rust 也有 `const` 关键字，但它比 JavaScript 的 `const` 更严格。

### 2.1 const vs let

| 特性 | let (不可变) | const (常量) |
| :--- | :--- | :--- |
| **关键字** | `let` | `const` |
| **可变性** | 默认不可变，可加 `mut` 变可变 | **永远不可变** |
| **类型注解** | 可选 (自动推断) | **必须显式标注类型** |
| **赋值时机** | 运行时 | **编译时** (必须是常量表达式) |
| **作用域** | 局部作用域 | 全局或局部作用域 |

### 2.2 定义常量

```rust
// 必须标注类型，通常使用全大写加下划线命名
const MAX_POINTS: u32 = 100_000;

fn main() {
    println!("Max points: {}", MAX_POINTS);
}
```

**注意**：你不能将函数的返回值赋给 `const`，因为函数调用是在运行时发生的，而 `const` 必须在编译时确定。

```rust
// 错误！
// const VAL: i32 = get_value(); 

// 正确 (如果是 let)
let val = get_value();
```

## 3. 变量遮蔽 (Shadowing)

这是 Rust 中一个非常有趣且强大的特性，JavaScript 中也有类似概念（作用域遮蔽），但 Rust 用得更频繁。

**遮蔽**指的是：你可以声明一个与之前变量**同名**的新变量。新变量会"遮蔽"掉旧变量。

```rust
fn main() {
    let x = 5;
    let x = x + 1; // 声明了一个新的 x，值为 6，旧的 x 被遮蔽
    let x = x * 2; // 又声明了一个新的 x，值为 12

    println!("The value of x is: {}", x); // 12
}
```

### 3.1 Shadowing vs Mut

你可能会问：这和 `mut` 有什么区别？

**区别 1：类型可以改变**
使用 `mut` 时，你不能改变变量的类型。

```rust
let mut spaces = "   ";
// spaces = spaces.len(); // 编译错误！类型不匹配：期望 &str，得到 usize
```

使用 Shadowing，你可以改变类型，因为你实际上是创建了一个**新变量**。

```rust
let spaces = "   ";
let spaces = spaces.len(); // 没问题！第一个 spaces 是字符串，第二个是数字
```

**区别 2：不可变性重置**
使用 Shadowing 后，新变量默认又是不可变的（除非你再次加 `mut`）。这允许你在进行一些转换后，确保变量不再被修改。

## 4. 类型推断 (Type Inference)

Rust 是静态强类型语言，这意味着每个变量在编译时都必须有确定的类型。

但是，你很少看到像 C++ 或 Java 那样繁琐的类型声明。因为 Rust 编译器非常聪明，它可以根据上下文自动推断出变量的类型。

```rust
let x = 5; // 编译器推断 x 是 i32 (默认整数类型)
let y = 3.14; // 编译器推断 y 是 f64 (默认浮点类型)
```

只有在编译器无法推断时（例如解析字符串），你才需要显式添加类型注解：

```rust
// parse() 可以解析成多种数字类型，必须告诉编译器我们要 u32
let guess: u32 = "42".parse().expect("Not a number!");
```

## 5. 总结

Rust 的变量系统设计体现了其"显式优于隐式"和"安全第一"的哲学。

1.  **默认不可变**：`let x = 5`。
2.  **显式可变**：`let mut x = 5`。
3.  **常量**：`const MAX: u32 = 100`，编译时常量。
4.  **遮蔽 (Shadowing)**：允许重用变量名，甚至改变类型。

理解了变量，下一篇我们将深入探讨 Rust 的数据类型，看看它与 JavaScript 的类型系统有何不同。

---

**上一篇**：[6.Rust 语言依赖管理以及 Cargo 使用](./6.Rust%20语言依赖管理以及%20Cargo%20使用.md)
**下一篇预告**：[8.Rust 语言基础之基本数据类型](./8.Rust%20语言基础之基本数据类型.md)
