---
title: "Rust 语言基础之所有权与借用"
description: "理解 Rust 最关键的特性：所有权、借用和生命周期，掌握内存安全的核心概念。"
date: "2025-11-30"
seriesOrder: 14
---

# 14. Rust 语言基础之所有权与借用

## 引言

欢迎来到 Rust 学习之旅中最关键的一站。

如果你之前学过 C/C++，你可能经历过手动管理内存的痛苦（内存泄漏、悬垂指针）。
如果你是 JavaScript/Python/Go 开发者，你可能习惯了**垃圾回收 (GC)**，从未关心过内存是如何释放的。

Rust 选择了一条独特的道路：**所有权 (Ownership)**。它不需要 GC，也不需要手动 `free`，却能保证内存安全。

## 1. 内存管理方式对比

| 方式 | 代表语言 | 优点 | 缺点 |
| :--- | :--- | :--- | :--- |
| **垃圾回收 (GC)** | JS, Java, Go | 开发简单，无需关心释放 | 运行时开销，可能 STW |
| **手动管理** | C, C++ | 控制力强，性能极致 | 极易出错（内存泄漏、悬垂指针） |
| **所有权** | Rust | 内存安全 + 零成本 | 学习曲线陡峭 |

**特别说明 Go 的 GC**：
- Go 使用并发三色标记清除算法，STW 时间已经非常短（通常 < 1ms）
- 但在内存密集型场景（如游戏引擎）仍可能有影响
- Rust 没有 GC，所以不存在这个问题

## 2. 所有权规则 (The Rules)

记住这三条铁律：

1.  Rust 中的每一个值都有一个被称为其 **所有者 (Owner)** 的变量。
2.  值在任一时刻有且只有一个所有者。
3.  当所有者（变量）离开作用域，这个值将被丢弃 (Drop)。

### 2.1 变量作用域

```rust
{                      // s 在这里无效，它还没被声明
    let s = "hello";   // s 是有效的
    // 使用 s
}                      // 作用域结束，s 不再有效
```

### 2.2 Move (移动) 语义

这是 Rust 与 JS 最大的不同。

**在 JavaScript 中：**
```javascript
let s1 = "hello";
let s2 = s1;
// s1 和 s2 都指向同一个字符串对象（或者说是值的拷贝，取决于实现），两者都可用。
```

**在 Rust 中：**
```rust
let s1 = String::from("hello");
let s2 = s1; 

// println!("{}", s1); // ❌ 错误！s1 已经失效了
println!("{}", s2); // ✅ 正确
```

**为什么？**
为了保证内存安全。`s1` 和 `s2` 指向堆上的同一块内存。如果 `s1` 和 `s2` 离开作用域时都尝试释放这块内存，就会发生 **Double Free** 错误。
因此，Rust 规定：当 `s1` 赋值给 `s2` 时，`s1` 的所有权**移动 (Move)** 给了 `s2`，`s1` 随即失效。

**例外：Copy Trait**
对于像 `i32`、`bool` 这样存储在栈上的简单类型，它们实现了 `Copy` trait。赋值时会进行**复制**，旧变量依然可用。

```rust
let x = 5;
let y = x;
println!("x = {}, y = {}", x, y); // ✅ 没问题，整数是 Copy 的
```

## 3. 借用 (Borrowing) 与引用

如果我们想使用一个值，但不想获取它的所有权，怎么办？答案是：**借用**。
借用通过**引用 (Reference, `&`)** 来实现。

```rust
fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1); // 传递引用，不转移所有权

    println!("The length of '{}' is {}.", s1, len); // s1 依然可用
}

fn calculate_length(s: &String) -> usize { // s 是对 String 的引用
    s.len()
} // s 离开作用域，但因为它不拥有值，所以什么也不会发生
```

### 3.1 可变引用 (`&mut`)

默认情况下，引用是不可变的。如果你想修改借用的值，需要使用可变引用。

```rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

### 3.2 引用的规则 (非常重要)

在任意给定时间，**要么** 只能有一个可变引用，**要么** 只能有多个不可变引用。

*   ❌ **不可以**同时拥有可变引用和不可变引用。
    ```rust
    let mut s = String::from("hello");
    let r1 = &s; 
    let r2 = &s; 
    let r3 = &mut s; // ❌ 错误！
    // 既然 r1, r2 借用了 s，它们就不希望 s 在它们眼皮底下被 r3 修改。
    ```

*   ❌ **不可以**同时拥有多个可变引用。
    ```rust
    let mut s = String::from("hello");
    let r1 = &mut s;
    let r2 = &mut s; // ❌ 错误！防止数据竞争 (Data Race)。
    ```

## 4. 总结

1.  **所有权**：每个值都有一个所有者，所有者离开作用域，值被清理。
2.  **Move**：赋值或传参时，非 Copy 类型的所有权会转移，原变量失效。
3.  **借用**：使用 `&` 创建引用，不获取所有权。
4.  **借用规则**：
    *   一个可变引用 (`&mut`) **OR** 任意多个不可变引用 (`&`)。
    *   引用必须总是有效的（编译器会检查悬垂引用）。

理解了所有权，你就理解了 Rust 的灵魂。虽然刚开始会被编译器频频报错（"Borrow Checker"），但一旦习惯，你会发现它能帮你写出极其健壮的代码。

下一篇，我们将学习 Rust 的面向对象特性之一：**结构体 (Struct)**。

---

