---
title: "Rust 语言基础之基本数据类型"
description: "详细了解 Rust 的类型系统：标量类型、复合类型，以及 String 和 &str 的区别。"
date: "2025-11-30"
seriesOrder: 8
---

# 8. Rust 语言基础之基本数据类型

## 引言

在 JavaScript 中，我们有 `number`（包括整数和浮点数）、`string`、`boolean`、`null`、`undefined`、`symbol` 和 `bigint`。JS 的类型系统相对宽松，数字不分整数和浮点数，也不分位数。

Rust 作为一门系统级语言，对内存布局有着精确的控制。因此，它的数据类型分类更加细致。Rust 的数据类型主要分为两类：**标量（Scalar）**和**复合（Compound）**。

本篇文章将带你详细了解 Rust 的类型系统，并重点解释 `String` 和 `&str` 这个初学者最容易混淆的概念。

## 1. 标量类型 (Scalar Types)

标量类型代表一个单独的值。Rust 有四种基本的标量类型：整型、浮点型、布尔型和字符型。

### 1.1 整型 (Integer)

Rust 提供了多种不同长度的整数类型，分为有符号（Signed, `i`）和无符号（Unsigned, `u`）。

| 长度 | 有符号 (i) | 无符号 (u) | 范围 (有符号) |
| :--- | :--- | :--- | :--- |
| 8-bit | `i8` | `u8` | -128 ~ 127 |
| 16-bit | `i16` | `u16` | -32768 ~ 32767 |
| 32-bit | `i32` (默认) | `u32` | 约 -20亿 ~ 20亿 |
| 64-bit | `i64` | `u64` | 很大 |
| 128-bit | `i128` | `u128` | 非常大 |
| arch | `isize` | `usize` | 取决于 CPU 架构 (32位或64位) |

*   **默认类型**：如果你写 `let x = 10;`，Rust 默认推断为 `i32`。
*   **usize**：常用于数组索引和集合大小，因为它能保证覆盖内存地址范围。

### 1.2 浮点型 (Floating-Point)

Rust 有两种浮点数：`f32` 和 `f64`。

*   `f32`：单精度浮点数。
*   `f64`：双精度浮点数（默认）。这与 JavaScript 的 `number` 类型完全一致（IEEE-754 标准）。

```rust
let x = 2.0; // f64
let y: f32 = 3.0; // f32
```

### 1.3 布尔型 (Boolean)

只有两个值：`true` 和 `false`。类型关键字是 `bool`。

```rust
let t = true;
let f: bool = false;
```

### 1.4 字符型 (Character)

**注意**：Rust 的 `char` 与 C/C++ 的 `char` 不同。
*   C/C++ 的 `char` 是 1 个字节（ASCII）。
*   Rust 的 `char` 是 **4 个字节**，代表一个 **Unicode 标量值**。这意味着它可以存储中文、Emoji 表情等。

```rust
let c = 'z';
let z = 'ℤ';
let heart_eyed_cat = '😻'; // 这是一个 char！
```

注意：字符使用单引号 `'`，字符串使用双引号 `"`。

## 2. 复合类型 (Compound Types)

复合类型可以将多个值组合成一个类型。Rust 有两个原生的复合类型：元组（Tuple）和数组（Array）。

### 2.1 元组 (Tuple)

元组可以将多个**不同类型**的值组合在一起。长度固定。

```rust
// 定义元组
let tup: (i32, f64, u8) = (500, 6.4, 1);

// 解构 (Destructuring) - 类似 JS 的 const [x, y, z] = tup;
let (x, y, z) = tup;

// 通过索引访问
let five_hundred = tup.0;
let six_point_four = tup.1;
```

### 2.2 数组 (Array)

数组包含多个**相同类型**的值。**长度固定**。

```rust
// 类型签名：[类型; 长度]
let a: [i32; 5] = [1, 2, 3, 4, 5];

// 初始化相同值的数组：[值; 长度]
let a = [3; 5]; // 等同于 [3, 3, 3, 3, 3]

// 访问
let first = a[0];
```

**注意**：Rust 的数组是固定长度的，分配在栈上。如果你需要动态长度的数组（像 JS 的 Array），请使用 `Vec`（向量），我们会在后续文章详细介绍。

## 3. 字符串：String vs &str

这是 Rust 新手最容易晕的地方。在 JS 中，字符串只有一种 `string`。但在 Rust 中，主要有两种字符串类型。

### 3.1 `String` (所有权字符串)

*   **存储位置**：堆 (Heap)。
*   **特点**：可变、可增长、拥有所有权。
*   **类比**：类似于 JS 的 `new String("hello")` 对象（虽然不完全准确），或者 C++ 的 `std::string`。

```rust
let mut s = String::from("hello");
s.push_str(", world!"); // 可以修改
println!("{}", s);
```

### 3.2 `&str` (字符串切片/引用)

*   **存储位置**：通常指向静态存储区（字面量）或堆上的某个片段。
*   **特点**：不可变、固定长度、**没有所有权**（只是一个借用视图）。
*   **类比**：类似于 JS 的字符串字面量。

```rust
let s = "hello"; // s 的类型是 &str
```

### 3.3 转换与使用

*   **&str -> String**：`"hello".to_string()` 或 `String::from("hello")`。
*   **String -> &str**：`&s`（取引用）。

**简单法则**：
*   如果你需要修改字符串，或者需要拥有它（比如作为结构体字段），用 `String`。
*   如果你只是作为函数参数读取字符串，用 `&str`（效率更高，因为不需要拷贝）。

## 4. 空值处理：Option vs Null

**Rust 没有 `null`！**

在 JS 中，`null` 和 `undefined` 是著名的"十亿美元错误"，经常导致运行时崩溃。

Rust 使用 `Option<T>` 枚举来显式处理可能为空的情况。

```rust
enum Option<T> {
    Some(T), // 有值
    None,    // 无值
}
```

如果你想表示一个可能为空的整数，你必须使用 `Option<i32>`。

```rust
let some_number = Some(5);
let absent_number: Option<i32> = None;
```

编译器会强制你处理 `None` 的情况，你不能直接把 `Option<i32>` 当作 `i32` 来运算。这彻底杜绝了空指针异常。

## 5. 总结

Rust 的类型系统严谨而强大：

1.  **整型**：区分符号和长度（`i32`, `u64` 等）。
2.  **字符**：`char` 是 4 字节 Unicode。
3.  **数组**：固定长度，动态数组请用 `Vec`。
4.  **字符串**：区分 `String`（所有权、堆）和 `&str`（借用、视图）。
5.  **空值**：没有 `null`，只有 `Option`。

理解了这些基础类型，下一篇我们将学习如何对它们进行运算——Rust 的运算符。

---

**上一篇**：[7.Rust 语言基础之变量和常量](./7.Rust%20语言基础之变量和常量.md)
**下一篇预告**：[9.Rust 语言基础之运算符](./9.Rust%20语言基础之运算符.md)
