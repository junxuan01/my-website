---
title: "Rust 语言基础之错误处理"
description: "掌握 Rust 的错误处理机制：Result、Option 和 ? 操作符，编写健壮的代码。"
date: "2025-11-30"
seriesOrder: 17.5
---

# 17.5 Rust 语言基础之错误处理

## 引言

在 JavaScript 中，我们使用 `try...catch` 捕获异常。在 Go 中，函数返回 `error` 类型，调用者需要检查。

Rust 选择了与 Go 类似的方式：**错误作为返回值**。但 Rust 通过类型系统（`Result` 和 `Option`）和语法糖（`?` 操作符）让错误处理更加优雅和安全。

## 1. 两种"错误"

Rust 将程序问题分为两类：

| 类型 | 说明 | 处理方式 | 类比 |
| :--- | :--- | :--- | :--- |
| **可恢复错误** | 文件找不到、网络超时等 | `Result<T, E>` | Go 的 `error` |
| **不可恢复错误** | 数组越界、断言失败等 | `panic!` 宏 | JS 的 `throw Error` |

## 2. panic! - 不可恢复的错误

当程序遇到无法处理的错误时，可以调用 `panic!` 宏使程序崩溃并打印错误信息。

```rust
fn main() {
    panic!("Something went terribly wrong!");
}
```

输出类似：
```
thread 'main' panicked at 'Something went terribly wrong!', src/main.rs:2:5
```

**什么时候用 panic?**
- 程序处于无效状态，无法继续运行
- 开发阶段快速失败，暴露 Bug
- 示例代码、测试代码

**生产环境应尽量避免 panic，使用 Result 处理错误。**

## 3. Result - 可恢复的错误

`Result` 是一个枚举，定义如下：

```rust
enum Result<T, E> {
    Ok(T),    // 成功，包含结果值
    Err(E),   // 失败，包含错误信息
}
```

### 3.1 基本用法

```rust
use std::fs::File;

fn main() {
    let file_result = File::open("hello.txt");

    let file = match file_result {
        Ok(f) => f,
        Err(error) => {
            println!("Failed to open file: {:?}", error);
            return;
        }
    };
}
```

### 3.2 unwrap 和 expect

如果你确定不会出错，或者只是在写原型代码，可以使用快捷方法：

```rust
// unwrap: 成功返回值，失败 panic
let file = File::open("hello.txt").unwrap();

// expect: 同上，但可以自定义错误信息
let file = File::open("hello.txt").expect("Failed to open hello.txt");
```

**注意**：生产代码中慎用，它们会导致程序崩溃。

## 4. ? 操作符 - 错误传播的语法糖

这是 Rust 最优雅的特性之一。`?` 操作符可以简化错误传播。

**没有 ? 的写法：**
```rust
fn read_username_from_file() -> Result<String, std::io::Error> {
    let file_result = File::open("username.txt");

    let mut file = match file_result {
        Ok(f) => f,
        Err(e) => return Err(e), // 手动传播错误
    };

    let mut username = String::new();

    match file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e), // 手动传播错误
    }
}
```

**使用 ? 的写法：**
```rust
use std::fs::File;
use std::io::Read;

fn read_username_from_file() -> Result<String, std::io::Error> {
    let mut file = File::open("username.txt")?; // 失败则直接返回 Err
    let mut username = String::new();
    file.read_to_string(&mut username)?; // 失败则直接返回 Err
    Ok(username)
}
```

**`?` 的工作原理：**
- 如果 Result 是 `Ok`，取出值继续执行
- 如果 Result 是 `Err`，立即返回该错误

**链式调用：**
```rust
fn read_username_from_file() -> Result<String, std::io::Error> {
    let mut username = String::new();
    File::open("username.txt")?.read_to_string(&mut username)?;
    Ok(username)
}
```

## 5. JS / Go / Rust 对比

| 特性 | JavaScript | Go | Rust |
| :--- | :--- | :--- | :--- |
| **机制** | 异常 (throw/catch) | 错误返回值 | Result 枚举 |
| **语法** | `try { } catch (e) { }` | `if err != nil { }` | `match` 或 `?` |
| **强制处理** | ❌ 可以忽略 | ❌ 可以忽略 `_` | ⚠️ 编译警告 |
| **传播** | 自动冒泡 | 手动 `return err` | `?` 操作符 |

**Go vs Rust 错误处理对比：**

```go
// Go: 需要反复写 if err != nil
file, err := os.Open("file.txt")
if err != nil {
    return err
}
content, err := ioutil.ReadAll(file)
if err != nil {
    return err
}
```

```rust
// Rust: 使用 ? 非常简洁
let mut file = File::open("file.txt")?;
let mut content = String::new();
file.read_to_string(&mut content)?;
```

## 6. Option vs Result

| 类型 | 用途 | 成功 | 失败 |
| :--- | :--- | :--- | :--- |
| `Option<T>` | 值可能不存在 | `Some(T)` | `None` |
| `Result<T, E>` | 操作可能失败 | `Ok(T)` | `Err(E)` |

```rust
// Option: 查找可能不存在的元素
fn find_user(id: u32) -> Option<User> { ... }

// Result: I/O 操作可能失败
fn read_file(path: &str) -> Result<String, io::Error> { ... }
```

## 7. 总结

1. **panic!**：不可恢复的错误，程序崩溃退出
2. **Result<T, E>**：可恢复的错误，必须显式处理
3. **? 操作符**：简化错误传播，失败时自动返回 Err
4. **unwrap/expect**：快捷方法，失败会 panic（慎用）

Rust 的错误处理虽然看起来比 JS 的 try/catch 繁琐，但它强制你考虑所有可能的错误情况，从而写出更健壮的代码。

---

**返回目录**：[README](./README.md)
