---
title: "Rust 语言基础之结构体"
description: "学习如何使用结构体组织数据，掌握结构体的定义、实例化、方法和关联函数。"
date: "2025-11-30"
seriesOrder: 15
---

# 15. Rust 语言基础之结构体

## 引言

在 JavaScript 中，我们使用 Object 来组合多个相关的值。在 Rust 中，我们使用 **结构体 (Struct)**。

结构体允许你将多个相关的值（可以是不同类型）组合成一个有意义的整体。如果你熟悉 C、Go 或 TypeScript 的 Interface，你会发现它们非常相似。

## 1. 定义结构体

使用 `struct` 关键字定义结构体。

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```

## 2. 实例化结构体

创建结构体的实例时，我们需要为每个字段指定具体的值。

```rust
fn main() {
    let user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    println!("User email: {}", user1.email);
}
```

注意：
1.  字段顺序不必与定义时一致。
2.  如果要修改字段，实例必须是可变的 (`mut`)。Rust 不允许只将某个字段标记为可变。

```rust
let mut user1 = User { ... };
user1.email = String::from("another@example.com");
```

## 3. 简写语法

### 3.1 字段初始化简写

如果变量名与字段名相同，可以省略字段名（类似 ES6 的对象简写）。

```rust
fn build_user(email: String, username: String) -> User {
    User {
        email,     // 等同于 email: email
        username,  // 等同于 username: username
        active: true,
        sign_in_count: 1,
    }
}
```

### 3.2 结构体更新语法

如果你想基于一个旧实例创建一个新实例，可以使用 `..` 语法（类似 JS 的 Spread Operator `...`，但写法略有不同）。

```rust
let user2 = User {
    email: String::from("another@example.com"),
    ..user1 // 其他字段与 user1 相同
};
```

**注意**：结构体更新语法会**移动 (Move)** 数据。如果 `user1` 中有堆上分配的字段（如 String）被移动到了 `user2`，那么 `user1` 在这之后可能就无法使用了（除非被移动的字段实现了 Copy trait）。

## 4. 元组结构体 (Tuple Structs)

有时候我们不需要给字段起名，只需要类型。

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
    
    // 访问字段使用索引
    println!("Black R: {}", black.0);
}
```

虽然 `Color` 和 `Point` 的字段类型完全一样，但它们是**不同的类型**。

## 5. 方法 (Methods)

结构体不仅可以存数据，还可以定义行为。我们使用 `impl` (implementation) 块来定义方法。

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // 方法：第一个参数总是 &self (或 self, &mut self)
    fn area(&self) -> u32 {
        self.width * self.height
    }

    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    
    println!("The area is {}", rect1.area());
}
```

### 5.1 关联函数 (Associated Functions)

如果在 `impl` 块中定义的函数**不以** `self` 作为第一个参数，那么它就是关联函数（类似静态方法）。
常用于构造函数，比如 `new`。

```rust
impl Rectangle {
    fn square(size: u32) -> Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}

fn main() {
    // 使用 :: 调用关联函数
    let sq = Rectangle::square(3);
}
```

## 6. JS / Go / Rust 对比

| 特性 | JavaScript | Go | Rust |
| :--- | :--- | :--- | :--- |
| **定义** | `class` / 对象字面量 | `type X struct {}` | `struct X {}` |
| **实例化** | `new Class()` / `{}` | `X{field: val}` | `X { field: val }` |
| **方法定义** | `class { method() {} }` | `func (x X) method() {}` | `impl X { fn method(&self) {} }` |
| **静态/关联** | `static method()` | 普通函数 | `fn new() -> Self` (无 self) |
| **接收者** | 隐式 `this` | 显式 `(x X)` | 显式 `&self` |
| **字段简写** | `{ name }` (ES6) | ❌ 不支持 | `{ name }` ✅ |

**Go 与 Rust 的结构体对比**：

```go
// Go: 方法定义在外部
type Rectangle struct {
    Width  int
    Height int
}

func (r Rectangle) Area() int {
    return r.Width * r.Height
}
```

```rust
// Rust: 方法定义在 impl 块中
struct Rectangle { width: u32, height: u32 }

impl Rectangle {
    fn area(&self) -> u32 { self.width * self.height }
}
```

**关键区别**：
- Go 的方法接收者写在函数名前面，Rust 写在参数列表里 (`&self`)
- Go 使用大小写控制可见性，Rust 使用 `pub` 关键字
- Rust 的 `..` 更新语法会 Move 数据，Go 没有这个问题

## 7. 总结

1.  **Struct** 用于自定义数据类型，组合多个字段。
2.  **impl** 块用于定义结构体的方法和关联函数。
3.  **方法** 的第一个参数是 `&self`，代表实例本身。
4.  **关联函数** (如 `new`) 不带 `self`，通过 `Type::func()` 调用。

结构体让我们可以创建更有意义的数据模型。但在实际开发中，我们经常需要处理"多种可能的情况"（比如：结果可能是成功，也可能是失败；值可能是有的，也可能是空的）。这时候，就需要用到 Rust 的另一个强大特性——**枚举 (Enum)**。

---

