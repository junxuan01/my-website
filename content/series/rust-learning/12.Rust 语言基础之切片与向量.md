---
title: "Rust 语言基础之切片与向量"
description: "掌握 Rust 中最常用的两个集合类型：动态数组 Vec 和切片 Slice。"
date: "2025-11-30"
seriesOrder: 12
---

# 12. Rust 语言基础之切片与向量

## 引言

在上一篇中，我们学习了 Rust 的数组（Array），它的长度是固定的。但在实际开发中，我们绝大多数时候需要的是**动态数组**——可以随时添加、删除元素。

在 JavaScript 中，`Array` 本身就是动态的。在 Rust 中，这个角色由 **Vector (`Vec<T>`)** 扮演。

此外，Rust 还有一个非常重要的概念：**切片 (Slice)**。它是对集合中一段连续元素的引用。

本篇文章将带你掌握 Rust 中最常用的两个集合类型：`Vec` 和切片。

## 1. 向量 (Vector)

`Vec<T>` 是 Rust 标准库提供的动态数组。它存储在堆（Heap）上，因此长度可以动态改变。

### 1.1 创建 Vector

```rust
// 1. 使用 Vec::new() 创建空向量
let mut v: Vec<i32> = Vec::new();

// 2. 使用 vec! 宏创建并初始化 (推荐)
let v = vec![1, 2, 3];
```

### 1.2 更新 Vector

要修改 Vector，必须将其声明为 `mut`。

```rust
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);

v.pop(); // 移除最后一个元素 (8)
```

### 1.3 读取元素

有两种方式读取 Vector 中的元素，这体现了 Rust 对安全性的考量。

**方式一：索引访问 (`&v[i]`)**

```rust
let v = vec![1, 2, 3, 4, 5];
let third: &i32 = &v[2];
println!("The third element is {}", third);
```

*   **风险**：如果索引越界（比如访问 `v[100]`），程序会 **Panic**（崩溃）。

**方式二：`get` 方法**

```rust
match v.get(2) {
    Some(third) => println!("The third element is {}", third),
    None => println!("There is no third element."),
}
```

*   **安全**：`get` 返回 `Option<&T>`。如果越界，返回 `None`，程序不会崩溃。这在处理不可信输入时非常有用。

### 1.4 遍历 Vector

```rust
let v = vec![100, 32, 57];

// 不可变遍历
for i in &v {
    println!("{}", i);
}

// 可变遍历 (修改元素)
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50; // 使用解引用运算符 * 修改值
}
```

## 2. 切片 (Slice)

切片是对集合中**一段连续元素序列的引用**。切片本身不拥有数据，它只是数据的"视图"（View）。

### 2.1 字符串切片 (`&str`)

我们在讲数据类型时提到过 `&str`，它实际上就是字符串的切片。

```rust
let s = String::from("Hello world");

let hello = &s[0..5]; // "Hello"
let world = &s[6..11]; // "world"
```

*   `[start..end]`：包含 `start`，不包含 `end`。
*   `[..2]`：从头开始。
*   `[3..]`：直到结尾。
*   `[..]`：整个切片。

### 2.2 数组/向量切片 (`&[T]`)

切片不仅可以用于字符串，还可以用于数组和 Vector。

```rust
let a = [1, 2, 3, 4, 5];

let slice = &a[1..3]; // 类型是 &[i32]
assert_eq!(slice, &[2, 3]);
```

### 2.3 为什么需要切片？

切片解决了**引用集合一部分**的问题，同时保证了内存安全。

假设你写了一个函数，计算数组前 N 个元素的和。

**不使用切片（传引用和长度）：**
```rust
fn sum(arr: &Vec<i32>, len: usize) -> i32 { ... }
// 风险：len 可能超过 arr 的实际长度
```

**使用切片（推荐）：**
```rust
fn sum(slice: &[i32]) -> i32 {
    let mut s = 0;
    for i in slice {
        s += i;
    }
    s
}

fn main() {
    let v = vec![1, 2, 3, 4, 5];
    let a = [10, 20, 30];

    // 切片的神奇之处：既可以传 Vector 的切片，也可以传数组的切片
    println!("{}", sum(&v[0..2])); // 3
    println!("{}", sum(&a[..]));   // 60
}
```

**关键点**：`&[T]` 是一个通用的接口。如果你的函数只读取数据而不修改长度，**参数类型应该尽量使用切片 `&[T]` 而不是 `&Vec<T>`**。这样你的函数既能接受 Vector，也能接受 Array。

## 3. JS vs Rust 对比

| 操作 | JavaScript Array | Rust Vec | Rust Slice |
| :--- | :--- | :--- | :--- |
| **创建** | `[1, 2]` | `vec![1, 2]` | `&v[..]` |
| **添加** | `arr.push(3)` | `v.push(3)` | 不支持 (长度固定) |
| **访问** | `arr[0]` | `&v[0]` 或 `v.get(0)` | `&s[0]` 或 `s.get(0)` |
| **截取** | `arr.slice(1, 3)` | `&v[1..3]` | `&s[1..3]` |
| **类型** | 引用类型 | 拥有所有权 | 借用 (引用) |

## 4. 总结

1.  **Vector (`Vec<T>`)**：Rust 中的动态数组，存储在堆上，拥有数据的所有权。
2.  **切片 (`&[T]`)**：对数组或 Vector 一部分的引用，不拥有数据，长度固定。
3.  **最佳实践**：函数参数尽量使用切片 `&[T]`，这样调用者既可以传 `Vec` 也可以传 `Array`，灵活性最高。

掌握了 Vector 和 Slice，你已经可以处理绝大多数序列数据了。但在实际开发中，我们还需要键值对存储。下一篇，我们将学习 Rust 的哈希表——**HashMap**。

---

