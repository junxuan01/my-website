---
title: "Rust 语言基础之 HashMap"
description: "学习如何在 Rust 中使用 HashMap 存储和操作键值对数据。"
date: "2025-11-30"
seriesOrder: 13
---

# 13. Rust 语言基础之 HashMap

## 引言

在 JavaScript 中，我们最常用的数据结构可能是 **Object** (`{}`) 或 **Map**。它们都用于存储键值对（Key-Value）。

在 Rust 中，这种数据结构被称为 **HashMap** (`HashMap<K, V>`)。它通过哈希函数将键映射到存储值的位置。

本篇文章将带你学习如何在 Rust 中使用 HashMap。

## 1. 引入 HashMap

与 `Vec` 不同，`HashMap` 并没有被包含在 Rust 的预导入模块（Prelude）中。因此，使用前必须先引入：

```rust
use std::collections::HashMap;
```

## 2. 创建 HashMap

```rust
use std::collections::HashMap;

fn main() {
    // 创建一个空的 HashMap
    let mut scores = HashMap::new();

    // 插入数据
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
}
```

注意：
1.  HashMap 存储在堆上。
2.  所有的 Key 必须是同一种类型，所有的 Value 必须是同一种类型。

## 3. 读取数据

### 3.1 使用 `get` 方法

```rust
let team_name = String::from("Blue");
let score = scores.get(&team_name);

match score {
    Some(s) => println!("Score: {}", s),
    None => println!("Team not found"),
}
```

*   `get` 方法返回 `Option<&V>`。
*   如果键存在，返回 `Some(&value)`；如果不存在，返回 `None`。
*   这种设计强制你处理"键不存在"的情况，避免了空指针异常。

### 3.2 遍历 HashMap

```rust
for (key, value) in &scores {
    println!("{}: {}", key, value);
}
```

注意：HashMap 是无序的，遍历的顺序可能与插入顺序不同。

## 4. 更新 HashMap

### 4.1 覆盖旧值

如果你插入一个已经存在的 Key，新值会覆盖旧值。

```rust
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Blue"), 25); // 覆盖

println!("{:?}", scores); // {"Blue": 25}
```

### 4.2 只在键不存在时插入 (`entry` API)

这是 Rust HashMap 一个非常强大的特性。

```rust
scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50); // "Blue" 已存在，不会修改

println!("{:?}", scores);
```

*   `entry`：获取键对应的入口。
*   `or_insert`：如果键不存在，插入参数中的值；如果存在，返回对现有值的引用。

### 4.3 基于旧值更新

比如统计单词出现的次数：

```rust
let text = "hello world wonderful world";
let mut map = HashMap::new();

for word in text.split_whitespace() {
    // or_insert 返回的是值的**可变引用** (&mut V)
    let count = map.entry(word).or_insert(0);
    *count += 1; // 解引用并修改
}

println!("{:?}", map); 
// {"world": 2, "hello": 1, "wonderful": 1}
```

这段代码非常简洁且高效。

## 5. HashMap 与所有权

这是初学者最容易遇到的坑。

*   对于实现了 `Copy` trait 的类型（如 `i32`），值会被**复制**进 HashMap。
*   对于拥有所有权的类型（如 `String`），值会被**移动**（Move）进 HashMap，所有权归 HashMap 所有。

```rust
let field_name = String::from("Favorite color");
let field_value = String::from("Blue");

let mut map = HashMap::new();
map.insert(field_name, field_value);

// println!("{}", field_name); // ❌ 错误！field_name 的所有权已经移动到了 map 中
```

如果你想在插入后继续使用 `field_name`，你需要插入它的引用（但这涉及到生命周期），或者插入它的克隆 (`field_name.clone()`)。

## 6. JS vs Rust 对比

| 特性 | JavaScript Object/Map | Rust HashMap |
| :--- | :--- | :--- |
| **引入** | 内置 | `use std::collections::HashMap;` |
| **键类型** | Object 只能是 String/Symbol (Map 可以是任意) | 任何实现了 `Eq` 和 `Hash` trait 的类型 |
| **访问** | `obj.key` 或 `map.get(key)` | `map.get(&key)` |
| **不存在时** | 返回 `undefined` | 返回 `None` |
| **默认值插入** | 手动判断 `if (!map.has(k)) ...` | `map.entry(k).or_insert(v)` |

## 7. 总结

1.  **HashMap** 用于存储键值对，键必须唯一。
2.  使用 `insert` 添加元素，`get` 获取元素（返回 `Option`）。
3.  **`entry().or_insert()`** 是处理"不存在则插入"逻辑的神器。
4.  注意**所有权**：插入非 Copy 类型的数据后，变量的所有权会被转移给 HashMap。

到目前为止，我们已经学习了 Rust 的基础语法和常用数据结构。接下来，我们将进入 Rust 最核心、最独特，也是最"劝退"的部分——**所有权系统**。

---

