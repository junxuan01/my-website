---
title: "实战二：订单状态机与分布式 ID 生成"
description: "在购物车之上搭建订单子系统，设计订单主表与明细表、实现可维护的订单状态机，并通过 Snowflake 分布式 ID 和数据库事务保证订单的一致性与可追踪性。"
date: "2025-12-13"
seriesOrder: 20
---

# 20. 实战二：订单状态机与分布式 ID 生成

> 从“勾选购物车条目”到“生成一笔可追踪的订单”，这一篇我们会把整个下单流程的后端骨架搭起来，并解决订单 ID 和状态流转两个核心问题。

这一章的目标，是让你从前端视角完全搞清楚：

- 订单到底是怎么从购物车“长出来”的？
- 后端是如何保证**订单号全局唯一**、**有序且不暴露业务信息**？
- 订单从“待支付”到“已完成”中间到底经历了什么状态？
- 这些状态在数据库里如何建模？
- 在 Go + GORM 里，如何用事务保证下单的基本一致性？

---

## 1. 从前端视角看订单数据结构

先用 TypeScript 把“订单”这件事抽象出来：

```ts
// 订单状态
export type OrderStatus =
  | 'PENDING_PAY'   // 待支付
  | 'PAID'          // 已支付
  | 'SHIPPED'       // 已发货
  | 'COMPLETED'     // 已完成
  | 'CANCELED';     // 已取消

// 订单条目（基于购物车/sku）
export interface OrderItem {
  skuId: number;
  productId: number;
  title: string;
  price: number;
  quantity: number;
  image: string;
  attrs: Array<{ name: string; value: string }>;
}

// 订单主信息
export interface Order {
  id: string;            // 订单号（字符串形式，非自增）
  userId: number;
  status: OrderStatus;
  totalAmount: number;   // 商品总金额
  payAmount: number;     // 实际支付金额（含优惠）
  createdAt: string;
  payAt?: string;
  items: OrderItem[];
}
```

在前端，你通常会这样使用：

- 从购物车勾选若干条目，算出总价，发起“创建订单”请求；
- `POST /api/orders` 返回一个 `Order` 对象，其中包含 `id`（订单号）；
- 前端拿着 `id` 跳转到支付页 `/checkout/[id]`，进行后续操作。

后端要做的，就是提供这一套：

1. 订单主表 + 订单明细表建模；
2. 分布式订单号生成器（Snowflake 或改良方案）；
3. 订单状态机与状态更新规则；
4. 创建订单时的事务处理（写入订单 + 预校验库存）。

---

## 2. 订单数据库建模：主表 + 明细表

### 2.1 主表 `orders`

```sql
CREATE TABLE `orders` (
  `id`            BIGINT UNSIGNED NOT NULL COMMENT '订单ID（雪花算法）',
  `order_sn`      VARCHAR(64)     NOT NULL COMMENT '订单编号（字符串格式，可与id相同或携带业务含义）',
  `user_id`       BIGINT UNSIGNED NOT NULL COMMENT '用户ID',
  `status`        TINYINT         NOT NULL DEFAULT 0 COMMENT '订单状态',
  `total_amount`  DECIMAL(10,2)   NOT NULL DEFAULT 0 COMMENT '商品总金额',
  `pay_amount`    DECIMAL(10,2)   NOT NULL DEFAULT 0 COMMENT '实际支付金额',
  `pay_channel`   TINYINT         NOT NULL DEFAULT 0 COMMENT '支付渠道：0未知 1支付宝 2微信 3银行卡',
  `pay_time`      DATETIME        NULL COMMENT '支付时间',
  `remark`        VARCHAR(255)    NOT NULL DEFAULT '' COMMENT '订单备注',
  `created_at`    DATETIME        NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at`    DATETIME        NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  UNIQUE KEY `uk_order_sn` (`order_sn`),
  KEY `idx_user` (`user_id`),
  KEY `idx_status_created` (`status`, `created_at`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='订单主表';
```

这里有几个设计要点：

- `id` 使用 BIGINT，方便使用 Snowflake 一类的分布式 ID；
- `order_sn` 可以是：
  - 直接等于 `id` 转字符串；
  - 或者是 `日期前缀 + 随机数` 的格式，方便客服查单；
- `status` 用整数枚举，便于索引和统计。后面我们会定义 Go 层的枚举类型。

### 2.2 明细表 `order_items`

```sql
CREATE TABLE `order_items` (
  `id`           BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '自增ID',
  `order_id`     BIGINT UNSIGNED NOT NULL COMMENT '订单ID',
  `user_id`      BIGINT UNSIGNED NOT NULL COMMENT '用户ID冗余，便于查询',
  `product_id`   BIGINT UNSIGNED NOT NULL COMMENT 'SPU ID',
  `sku_id`       BIGINT UNSIGNED NOT NULL COMMENT 'SKU ID',
  `title`        VARCHAR(255)    NOT NULL COMMENT '商品标题快照',
  `image`        VARCHAR(512)    NOT NULL DEFAULT '' COMMENT '商品图片快照',
  `price`        DECIMAL(10,2)   NOT NULL DEFAULT 0 COMMENT '下单时单价快照',
  `quantity`     INT             NOT NULL DEFAULT 1 COMMENT '购买数量',
  `attrs`        JSON            NULL COMMENT '规格快照，如[{"name":"颜色","value":"红"}]',
  `created_at`   DATETIME        NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_order_id` (`order_id`),
  KEY `idx_user` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='订单明细表';
```

注意：

- 订单明细里要尽量存**快照信息**：标题、图片、单价、规格。
- 这样即使后续商品信息发生变化，订单详情页依旧展示当时下单时的快照数据。

---

## 3. Go 中的订单模型与状态枚举

### 3.1 订单状态枚举

```go
// internal/model/order.go

package model

import "time"

type OrderStatus int8

const (
    OrderStatusPendingPay OrderStatus = iota // 0 待支付
    OrderStatusPaid                          // 1 已支付
    OrderStatusShipped                       // 2 已发货
    OrderStatusCompleted                     // 3 已完成
    OrderStatusCanceled                      // 4 已取消
)

func (s OrderStatus) String() string {
    switch s {
    case OrderStatusPendingPay:
        return "PENDING_PAY"
    case OrderStatusPaid:
        return "PAID"
    case OrderStatusShipped:
        return "SHIPPED"
    case OrderStatusCompleted:
        return "COMPLETED"
    case OrderStatusCanceled:
        return "CANCELED"
    default:
        return "UNKNOWN"
    }
}
```

这和 TS 里的联合类型很像：

```ts
type OrderStatus = 'PENDING_PAY' | 'PAID' | 'SHIPPED' | 'COMPLETED' | 'CANCELED';
```

区别在于：

- Go 里用 `iota` 给每个状态一个 int8 值，方便存数据库；
- 提供 `String()` 方法方便日志输出和调试。

### 3.2 订单主表模型

```go
type Order struct {
    ID          uint64      `gorm:"primaryKey" json:"id"`
    OrderSN     string      `gorm:"size:64;not null;uniqueIndex" json:"order_sn"`
    UserID      uint64      `gorm:"not null;index" json:"user_id"`
    Status      OrderStatus `gorm:"not null;default:0;index" json:"status"`
    TotalAmount float64     `gorm:"type:decimal(10,2);not null;default:0" json:"total_amount"`
    PayAmount   float64     `gorm:"type:decimal(10,2);not null;default:0" json:"pay_amount"`
    PayChannel  int8        `gorm:"not null;default:0" json:"pay_channel"`
    PayTime     *time.Time  `json:"pay_time,omitempty"`
    Remark      string      `gorm:"size:255;not null;default:''" json:"remark"`
    CreatedAt   time.Time   `json:"created_at"`
    UpdatedAt   time.Time   `json:"updated_at"`

    Items []OrderItem `gorm:"foreignKey:OrderID" json:"items,omitempty"`
}
```

### 3.3 订单明细模型

```go
type OrderItem struct {
    ID         uint64        `gorm:"primaryKey;autoIncrement" json:"id"`
    OrderID    uint64        `gorm:"not null;index" json:"order_id"`
    UserID     uint64        `gorm:"not null;index" json:"user_id"`
    ProductID  uint64        `gorm:"not null" json:"product_id"`
    SkuID      uint64        `gorm:"not null" json:"sku_id"`
    Title      string        `gorm:"size:255;not null" json:"title"`
    Image      string        `gorm:"size:512;not null;default:''" json:"image"`
    Price      float64       `gorm:"type:decimal(10,2);not null;default:0" json:"price"`
    Quantity   int           `gorm:"not null;default:1" json:"quantity"`
    Attrs      SkuAttrs      `gorm:"type:json" json:"attrs"`
    CreatedAt  time.Time     `json:"created_at"`
}
```

> `SkuAttrs` 可复用之前定义的 JSON 类型。

---

## 4. 分布式 ID：为什么不能用自增主键？

先对比前端/数据库中几种常见 ID 设计方式：

### 4.1 自增 ID 的问题

在 MySQL 中常见：

```sql
id BIGINT UNSIGNED NOT NULL AUTO_INCREMENT
```

问题：

1. **安全性**：
   - 自增 ID 很容易被人“扫号”，推算出你的订单量级、用户量；
2. **跨库难以合并**：
   - 如果未来做分库分表，不同库自增 ID 可能会冲突；
3. **不能表达时间信息**：
   - 仅看 `id` 无法知道订单大致是什么时间创建的。

### 4.2 UUID 的问题

前端你也许习惯用 `uuid.v4()`：

```ts
import { v4 as uuidv4 } from 'uuid';

const id = uuidv4(); // 例如 550e8400-e29b-41d4-a716-446655440000
```

缺点：

- 字符串太长，占用存储空间大；
- 作为数据库主键，对索引不友好（非顺序写入，容易产生碎片）。

### 4.3 Snowflake（雪花算法）的优势

Snowflake 核心思想：

- 使用 64 位整数，将不同信息编码到不同 bit：

```text
[1bit 符号][41bit 时间戳][10bit 机器ID][12bit 自增序列]
```

- 特性：
  - 按时间大致递增，适合作为数据库主键（写入更顺序）；
  - 理论上在一个时间窗口内几乎不会重复（分布式节点安全）；
  - 仍然是一个普通的 BIGINT，存储、索引都友好。

在 Go 生态中有多个成熟实现，我们可以使用一个简单易用的库，或者在学习阶段自己实现一个简化版。

---

## 5. 在 Go 中实现一个简单 Snowflake 生成器

我们写一个较为简化，但足够实用的版本，重点理解原理：

```go
// internal/pkg/snowflake/snowflake.go

package snowflake

import (
    "errors"
    "sync"
    "time"
)

const (
    workerIDBits  uint8 = 10                    // 机器ID占用位数
    sequenceBits  uint8 = 12                    // 序列号占用位数
    maxWorkerID         = -1 ^ (-1 << workerIDBits)
    maxSequence         = -1 ^ (-1 << sequenceBits)

    workerIDShift  = sequenceBits
    timestampShift = sequenceBits + workerIDBits
)

// 自定义一个起始时间戳（比如 2024-01-01）
var epoch int64 = func() int64 {
    t, _ := time.Parse("2006-01-02", "2024-01-01")
    return t.UnixMilli()
}()

type Node struct {
    mu        sync.Mutex
    workerID  int64
    sequence  int64
    lastStamp int64
}

func NewNode(workerID int64) (*Node, error) {
    if workerID < 0 || workerID > maxWorkerID {
        return nil, errors.New("workerID out of range")
    }
    return &Node{workerID: workerID}, nil
}

func (n *Node) NextID() int64 {
    n.mu.Lock()
    defer n.mu.Unlock()

    now := time.Now().UnixMilli()
    if now == n.lastStamp {
        n.sequence = (n.sequence + 1) & maxSequence
        if n.sequence == 0 {
            // 当前毫秒内序列用完，等待下一毫秒
            for now <= n.lastStamp {
                now = time.Now().UnixMilli()
            }
        }
    } else {
        n.sequence = 0
    }

    n.lastStamp = now

    id := ((now - epoch) << timestampShift) | (n.workerID << workerIDShift) | n.sequence
    return id
}
```

在业务代码中，只需要在应用启动时初始化一个 Node：

```go
var orderIDNode *snowflake.Node

func InitIDGenerator() error {
    node, err := snowflake.NewNode(1) // 机器ID
    if err != nil {
        return err
    }
    orderIDNode = node
    return nil
}

func NextOrderID() uint64 {
    return uint64(orderIDNode.NextID())
}
```

> 生产环境中你可能会通过配置中心为每台机器分配不同 workerID，这里简单写死为 1 即可。

---

## 6. 从购物车生成订单：API 设计

下单入口接口一般是：

- `POST /api/orders`

请求体可能是：

```ts
interface CreateOrderRequest {
  addressId: number;        // 收货地址ID（本篇先略过地址细节）
  remark?: string;          // 订单备注
  skuIds: number[];         // 从购物车中勾选的SKU列表
}
```

在后端：

1. 根据 `userID` + `skuIds` 从 Redis 购物车中取出条目；
2. 计算总价（也可以顺便做一些简单的优惠逻辑）；
3. 生成订单主记录 + 明细记录；
4. 可选：预校验库存（真实扣减库存我们会在下一篇高并发里细讲）。

---

## 7. 订单创建 Service：事务 + 状态机起点

### 7.1 DTO 请求结构

```go
// internal/service/order_service.go

package service

import (
    "context"

    "gorm.io/gorm"

    "yourapp/internal/model"
    "yourapp/internal/pkg/snowflake"
    "yourapp/internal/repository"
)

type CreateOrderRequest struct {
    UserID    uint64   `json:"-"` // 从上下文获取
    SkuIDs    []uint64 `json:"sku_ids"`
    Remark   string    `json:"remark"`
}

type OrderService struct {
    db        *gorm.DB
    cartRepo  *repository.CartRepository
}

func NewOrderService(db *gorm.DB, cartRepo *repository.CartRepository) *OrderService {
    return &OrderService{db: db, cartRepo: cartRepo}
}
```

### 7.2 创建订单核心逻辑

```go
func (s *OrderService) CreateOrder(ctx context.Context, req CreateOrderRequest) (*model.Order, error) {
    if len(req.SkuIDs) == 0 {
        return nil, fmt.Errorf("no sku selected")
    }

    // 1. 根据 userID 获取购物车条目
    cartKey := s.cartRepo.UserCartKey(req.UserID)
    cartItems, err := s.cartRepo.GetAllItems(ctx, cartKey)
    if err != nil {
        return nil, err
    }

    // 构建一个 map 方便查找
    cartMap := make(map[uint64]model.CartItem, len(cartItems))
    for _, it := range cartItems {
        cartMap[it.SkuID] = it
    }

    var (
        orderItems []model.OrderItem
        totalAmount float64
    )

    for _, skuID := range req.SkuIDs {
        ci, ok := cartMap[skuID]
        if !ok {
            return nil, fmt.Errorf("sku %d not in cart", skuID)
        }
        if ci.Quantity <= 0 {
            return nil, fmt.Errorf("invalid quantity for sku %d", skuID)
        }

        // 此处应从数据库中查询 SKU 最新价格，避免前端篡改，示意：
        // sku, err := s.querySkuByID(ctx, skuID)
        // price := sku.Price
        price := ci.Price // 示例中直接用购物车价格

        oi := model.OrderItem{
            UserID:    req.UserID,
            ProductID: ci.ProductID,
            SkuID:     ci.SkuID,
            Title:     ci.Title,
            Image:     ci.Image,
            Price:     price,
            Quantity:  ci.Quantity,
            Attrs:     ci.Attrs,
        }
        orderItems = append(orderItems, oi)
        totalAmount += price * float64(ci.Quantity)
    }

    // 简单起见，暂时不考虑优惠，payAmount = totalAmount
    payAmount := totalAmount

    // 2. 使用事务写入订单与明细
    var order model.Order

    err = s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        orderID := uint64(snowflake.NextOrderID())
        order = model.Order{
            ID:          orderID,
            OrderSN:     fmt.Sprintf("%d", orderID),
            UserID:      req.UserID,
            Status:      model.OrderStatusPendingPay,
            TotalAmount: totalAmount,
            PayAmount:   payAmount,
            Remark:      req.Remark,
        }

        if err := tx.Create(&order).Error; err != nil {
            return err
        }

        for i := range orderItems {
            orderItems[i].OrderID = order.ID
        }

        if err := tx.Create(&orderItems).Error; err != nil {
            return err
        }

        // 这里可以预留：预扣减库存、写订单日志等

        return nil
    })
    if err != nil {
        return nil, err
    }

    // 3. 清理购物车中已下单的条目
    for _, skuID := range req.SkuIDs {
        _ = s.cartRepo.RemoveItem(ctx, cartKey, skuID)
    }

    // 加载 items 返回
    order.Items = orderItems
    return &order, nil
}
```

这里我们做了几个关键操作：

- 在事务中同时写入 `orders` 和 `order_items`，保证要么都成功，要么都失败；
- 使用 Snowflake 生成全局唯一的订单 ID；
- 把购物车中已下单条目删除，保持购物车与订单状态一致。

> 注意：真正的库存扣减和高并发安全会在“高并发库存扣减与 MQ 削峰”那一篇详细展开，这里只做“下单逻辑骨架”。

---

## 8. 订单状态机：有哪些合法流转？

一个简化版订单状态机可以这样定义：

```text
PENDING_PAY (待支付)
  ├── 支付成功  → PAID (已支付)
  ├── 超时取消 → CANCELED (已取消)
  └── 用户主动取消 → CANCELED

PAID (已支付)
  └── 商家发货 → SHIPPED (已发货)

SHIPPED (已发货)
  └── 用户确认收货 / 超时自动收货 → COMPLETED (已完成)

CANCELED / COMPLETED 为终态，不再流转
```

在 TS 里，你可能会写一个小状态机辅助函数：

```ts
function canTransition(from: OrderStatus, to: OrderStatus): boolean {
  const map: Record<OrderStatus, OrderStatus[]> = {
    PENDING_PAY: ['PAID', 'CANCELED'],
    PAID: ['SHIPPED'],
    SHIPPED: ['COMPLETED'],
    COMPLETED: [],
    CANCELED: [],
  };
  return map[from].includes(to);
}
```

在 Go 里可以这样实现：

```go
// internal/service/order_state_machine.go

package service

import "yourapp/internal/model"

func CanTransition(from, to model.OrderStatus) bool {
    switch from {
    case model.OrderStatusPendingPay:
        return to == model.OrderStatusPaid || to == model.OrderStatusCanceled
    case model.OrderStatusPaid:
        return to == model.OrderStatusShipped
    case model.OrderStatusShipped:
        return to == model.OrderStatusCompleted
    case model.OrderStatusCompleted, model.OrderStatusCanceled:
        return false
    default:
        return false
    }
}
```

### 8.1 更新订单状态的 Service 方法

```go
func (s *OrderService) UpdateOrderStatus(ctx context.Context, orderID uint64, newStatus model.OrderStatus) error {
    var order model.Order
    if err := s.db.WithContext(ctx).First(&order, "id = ?", orderID).Error; err != nil {
        return err
    }

    if !CanTransition(order.Status, newStatus) {
        return fmt.Errorf("invalid status transition: %s -> %s", order.Status, newStatus)
    }

    updates := map[string]any{
        "status": newStatus,
    }

    if order.Status == model.OrderStatusPendingPay && newStatus == model.OrderStatusPaid {
        now := time.Now()
        updates["pay_time"] = &now
    }

    return s.db.WithContext(ctx).Model(&model.Order{}).
        Where("id = ? AND status = ?", orderID, order.Status).
        Updates(updates).Error
}
```

这里用到了一个小技巧：

- `WHERE id = ? AND status = ?`，即在更新时再校验一次当前状态；
- 可以在一定程度上避免并发请求导致的“状态乱跳”。

---

## 9. Gin 订单接口与前后端联动

我们设计两条核心接口：

- `POST /api/orders`：创建订单；
- `GET /api/orders/:id`：获取订单详情。

### 9.1 创建订单接口

```go
// internal/handler/order.go

package handler

import (
    "net/http"

    "github.com/gin-gonic/gin"

    "yourapp/internal/service"
)

type CreateOrderHTTPReq struct {
    SkuIDs  []uint64 `json:"sku_ids" binding:"required,min=1"`
    Remark string    `json:"remark"`
}

func CreateOrder(orderSvc *service.OrderService) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID, ok := getUserIDFromContext(c)
        if !ok || userID == 0 {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
            return
        }

        var req CreateOrderHTTPReq
        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        sreq := service.CreateOrderRequest{
            UserID:  userID,
            SkuIDs:  req.SkuIDs,
            Remark:  req.Remark,
        }

        order, err := orderSvc.CreateOrder(c.Request.Context(), sreq)
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        c.JSON(http.StatusOK, order)
    }
}
```

前端使用方式（Next.js）：

```ts
// lib/api/order.ts

export async function createOrder(skuIds: number[], remark?: string) {
  const res = await fetch('/api/orders', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ sku_ids: skuIds, remark }),
    credentials: 'include',
  });

  if (!res.ok) throw new Error('Failed to create order');
  return res.json();
}
```

### 9.2 获取订单详情接口

```go
func GetOrderDetail(orderSvc *service.OrderService) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID, ok := getUserIDFromContext(c)
        if !ok || userID == 0 {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
            return
        }

        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil || id == 0 {
            c.JSON(http.StatusBadRequest, gin.H{"error": "invalid id"})
            return
        }

        var order model.Order
        if err := orderSvc.DB().WithContext(c.Request.Context()).
            Preload("Items").
            Where("id = ? AND user_id = ?", id, userID).
            First(&order).Error; err != nil {
            if errors.Is(err, gorm.ErrRecordNotFound) {
                c.JSON(http.StatusNotFound, gin.H{"error": "order not found"})
                return
            }
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }

        c.JSON(http.StatusOK, order)
    }
}
```

前端可以在 `/orders/[id]` 页里使用这个接口展示订单详情。

---

## 10. 小结与下一篇预告

本篇我们完成了：

1. 设计订单主表 `orders` 和明细表 `order_items`，并用 Go + GORM 建模；
2. 介绍了自增 ID、UUID 的优劣，重点实现了一个简化版 Snowflake 分布式 ID 生成器用于订单号；
3. 通过事务实现了“从购物车勾选条目创建订单”的完整后端逻辑；
4. 设计并实现了一个简易的订单状态机，定义了状态流转规则，并在更新状态时加了并发安全校验；
5. 用 Gin 暴露了创建订单与查询订单详情的 API，并给出了 Next.js 前端的对接示例。

在下一篇《实战二：高并发库存扣减与 RabbitMQ 削峰填谷》中，我们会重点解决：

- 在秒杀或大促场景下，如何避免库存“超卖”；
- 如何使用 Redis + Lua 做原子扣减库存；
- 如何用 RabbitMQ 将下单请求“削峰填谷”，保护数据库不被瞬时流量压垮；
- 并把这些能力与本篇的订单创建逻辑串联起来，形成一条真正可抗压的下单链路。