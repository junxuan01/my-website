---
title: "实战一：前端对接与全链路测试"
description: "前端视角实战。使用 Next.js 16 + Ant Design 6 构建管理后台。实现 Axios 拦截器处理 JWT 自动刷新，使用 Zustand 管理用户状态，动态渲染侧边栏菜单。"
date: "2025-12-17"
seriesOrder: 15
---

# 15. 实战一：前端对接与全链路测试

## 引言

前面 4 章，我们以后端视角完成了 RBAC 系统的全部功能：数据库建模、JWT 双令牌、菜单管理、Casbin 权限控制。

现在，是时候**回到你熟悉的前端世界**，看看如何对接这套后端 API。

这一章我们将完成：

1. 使用 **Next.js 16 + Ant Design 6** 搭建管理后台框架；
2. 封装 **Axios 实例**，实现 JWT 自动刷新（无感续期）；
3. 使用 **Zustand** 管理用户状态和菜单数据；
4. 根据后端返回的树形菜单，**动态渲染侧边栏**；
5. 实现**按钮级权限控制**（有权限才显示）；
6. 进行**全链路测试**，验证前后端协作是否正常。

> **给后端同学的话**：
> 
> 这一章的代码是 TypeScript + React，如果你不熟悉也没关系。重点关注**前后端如何协作**——前端期望什么样的数据结构、怎么处理 Token、怎么判断权限。这会帮助你设计出更好用的 API。

### 本章目标

学完这一章，你将能够：

1. 理解前端如何存储和使用 JWT（Access Token + Refresh Token）；
2. 实现 Axios 响应拦截器，自动处理 401 并刷新 Token；
3. 用 Zustand 管理全局状态（用户信息、菜单、权限列表）；
4. 根据后端返回的菜单树，递归渲染 Ant Design 的 `Menu` 组件；
5. 封装一个 `<Auth permission="xxx">` 组件，实现按钮级权限控制。

## 1. 前端项目初始化

```bash
npx create-next-app@latest rbac-admin
# 选型: TypeScript, ESLint, Tailwind CSS, App Router, src directory

cd rbac-admin
pnpm add antd @ant-design/icons axios zustand
```

## 2. Axios 封装：处理 JWT 刷新

这是前后端对接中最核心的部分。我们需要在 Axios 拦截器中实现第 12 章提到的**双令牌刷新逻辑**。

### 2.1 核心思路

1. **请求拦截器**：每次发请求前，从 localStorage 取出 Access Token，塞进 `Authorization` 头；
2. **响应拦截器**：如果收到 401（Token 过期），自动调用刷新接口，拿到新 Token 后重发原请求。

### 2.2 实现代码

创建 `src/utils/request.ts`:

```typescript
import axios, { AxiosError, InternalAxiosRequestConfig } from 'axios';

const instance = axios.create({
  baseURL: '/api/v1',
  timeout: 10000,
});

// 请求拦截器：注入 Access Token
instance.interceptors.request.use((config: InternalAxiosRequestConfig) => {
  const token = localStorage.getItem('access_token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// 响应拦截器：处理 401 和 Token 刷新
instance.interceptors.response.use(
  (response) => response.data, // 直接返回 data，省去每次 .data
  async (error: AxiosError) => {
    const originalRequest = error.config as InternalAxiosRequestConfig & { _retry?: boolean };

    // 如果是 401 且不是刷新接口本身，且没有重试过
    if (
      error.response?.status === 401 &&
      !originalRequest.url?.includes('/auth/refresh') &&
      !originalRequest._retry
    ) {
      originalRequest._retry = true; // 标记已重试，防止死循环

      try {
        const refreshToken = localStorage.getItem('refresh_token');
        if (!refreshToken) {
          throw new Error('No refresh token');
        }

        // 调用刷新接口（注意：这里用原生 axios，不用 instance，避免循环拦截）
        const { data } = await axios.post('/api/v1/auth/refresh', {
          refresh_token: refreshToken,
        });

        // 保存新 Token
        localStorage.setItem('access_token', data.data.access_token);
        localStorage.setItem('refresh_token', data.data.refresh_token);

        // 更新原请求的 Header，重发
        originalRequest.headers.Authorization = `Bearer ${data.data.access_token}`;
        return instance(originalRequest);
      } catch (refreshError) {
        // 刷新失败（Refresh Token 也过期了），清除登录状态，跳转登录页
        localStorage.removeItem('access_token');
        localStorage.removeItem('refresh_token');
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);

export default instance;
```

### 2.3 使用方式

```typescript
import request from '@/utils/request';

// 获取用户列表
const users = await request.get('/users');

// 创建用户
await request.post('/users', { username: 'test', password: '123456' });
```

所有请求都会自动带上 Token，401 时自动刷新，对业务代码完全透明。

## 3. 状态管理：Zustand

使用 Zustand 管理用户信息和菜单数据。

创建 `src/store/userStore.ts`:

```typescript
import { create } from 'zustand';
import { MenuItem } from '@/types'; // 假设你定义了类型

interface UserState {
  userInfo: any;
  menus: MenuItem[];
  setUserInfo: (info: any) => void;
  setMenus: (menus: MenuItem[]) => void;
}

export const useUserStore = create<UserState>((set) => ({
  userInfo: null,
  menus: [],
  setUserInfo: (info) => set({ userInfo: info }),
  setMenus: (menus) => set({ menus }),
}));
```

## 4. 动态菜单渲染

在 `src/app/layout.tsx` 或你的后台 Layout 组件中，调用后端接口获取菜单树。

```typescript
// src/components/AdminLayout.tsx
'use client';
import { useEffect } from 'react';
import { Layout, Menu } from 'antd';
import { useUserStore } from '@/store/userStore';
import request from '@/utils/request';

const { Sider, Content } = Layout;

export default function AdminLayout({ children }: { children: React.ReactNode }) {
  const { menus, setMenus } = useUserStore();

  useEffect(() => {
    // 获取当前用户的菜单树
    request.get('/menus/me').then((res: any) => {
      if (res.code === 0) {
        setMenus(res.data);
      }
    });
  }, []);

  // 递归渲染菜单项
  const renderMenuItems = (items: any[]) => {
    return items.map((item) => {
      if (item.children && item.children.length > 0) {
        return (
          <Menu.SubMenu key={item.id} title={item.title} icon={<i className={item.icon} />}>
            {renderMenuItems(item.children)}
          </Menu.SubMenu>
        );
      }
      return (
        <Menu.Item key={item.id} icon={<i className={item.icon} />}>
          {item.title}
        </Menu.Item>
      );
    });
  };

  return (
    <Layout style={{ minHeight: '100vh' }}>
      <Sider>
        <Menu theme="dark" mode="inline">
          {renderMenuItems(menus)}
        </Menu>
      </Sider>
      <Content style={{ margin: '16px' }}>{children}</Content>
    </Layout>
  );
}
```

## 5. 按钮级权限控制

除了页面访问（由 Next.js 路由和菜单控制），我们还需要控制按钮的显示。
例如：只有拥有 `user:delete` 权限的用户才能看到"删除"按钮。

创建一个高阶组件或 Hook：

```typescript
// src/components/Auth.tsx
import { useUserStore } from '@/store/userStore';

export const Auth = ({ permission, children }: { permission: string; children: React.ReactNode }) => {
  const { userInfo } = useUserStore();
  
  // 假设 userInfo.permissions 是一个字符串数组 ['user:add', 'user:delete']
  // 这需要后端在登录或获取用户信息时返回
  if (userInfo?.permissions?.includes(permission)) {
    return <>{children}</>;
  }
  
  return null; // 不渲染
};
```

**使用：**

```tsx
<Auth permission="user:delete">
  <Button danger>删除用户</Button>
</Auth>
```

## 6. 全链路测试 (Integration Test)

现在，启动后端 Go 服务和前端 Next.js 服务，进行完整流程测试：

1.  **登录**：输入 `admin/123456`，观察 Network 面板，确认 `/auth/login` 返回了 `access_token` 和 `refresh_token`。
2.  **菜单加载**：登录成功后跳转首页，观察 `/menus/me` 接口返回的 JSON 树，确认侧边栏是否正确渲染。
3.  **Token 刷新**：
    -   手动修改 LocalStorage 中的 `access_token`（比如删掉最后一位），使其失效。
    -   刷新页面或点击某个按钮。
    -   观察 Network，应该会看到一个红色的 401 请求，紧接着一个 `/auth/refresh` 请求，然后原请求自动重试并成功。
4.  **权限控制**：
    -   创建一个新角色 `guest`，只分配"查看用户"权限，不分配"删除用户"权限。
    -   用 `guest` 账号登录。
    -   确认"删除"按钮不可见，且直接调用删除接口报 403。

## 7. 本章小结与练习

这一章，我们从前端视角完成了 RBAC 系统的最后一块拼图：

1. **Axios 封装**：
   - 请求拦截器自动注入 Token；
   - 响应拦截器处理 401，自动刷新并重发请求；
   - 刷新失败则清除登录状态，跳转登录页。

2. **状态管理 (Zustand)**：
   - 用 Zustand 管理用户信息、菜单树、权限列表；
   - 比 Redux 更轻量，比 Context 更适合跨组件共享。

3. **动态菜单**：
   - 登录后调用 `/menus/me` 获取当前用户的菜单树；
   - 递归渲染 Ant Design 的 `Menu` 组件，支持多级嵌套。

4. **按钮级权限**：
   - 封装 `<Auth permission="xxx">` 组件；
   - 根据用户权限列表决定是否渲染子元素。

5. **全链路测试**：
   - 验证了登录、菜单加载、Token 刷新、权限控制的完整流程。

> **前后端协作的最佳实践**：
> 
> - 前端控制 UI 显示（菜单、按钮是否可见）—— 提升用户体验；
> - 后端控制 API 访问（Casbin 中间件）—— 保证系统安全；
> - 两者数据来源一致（都基于数据库里的角色-权限配置），保证状态同步。

### 思考题 / 练习

1. **实现登录页**：
   - 创建 `/login` 页面，包含用户名、密码输入框和提交按钮；
   - 调用 `POST /auth/login`，成功后保存 Token 并跳转首页。

2. **实现 Token 刷新的并发控制**：
   - 如果页面上同时发出 5 个请求，都收到 401，会触发 5 次刷新吗？
   - 思考如何用"锁"或"队列"保证只刷新一次，其他请求等待刷新结果。
   - 提示：可以用一个 Promise 变量存储刷新请求，其他请求直接 await 这个 Promise。

3. **实现路由守卫**：
   - 用户未登录时访问 `/dashboard`，应该自动跳转到 `/login`；
   - 在 Next.js 中可以用 middleware 或者在 Layout 中判断。

4. **完善错误处理**：
   - 目前 Axios 拦截器只处理了 401；
   - 增加对 403（无权限）、500（服务器错误）等状态码的统一处理；
   - 可以用 Ant Design 的 `message.error()` 弹出提示。

> 实战项目一到此完结！你已经掌握了一个完整的**全栈 RBAC 系统**的开发流程。下一章我们将把这套系统部署到生产环境。
