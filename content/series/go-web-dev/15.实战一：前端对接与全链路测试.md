---
title: "实战一：前端对接与全链路测试"
description: "前端视角实战。使用 Next.js 16 + Ant Design 6 构建管理后台。实现 Axios 拦截器处理 JWT 自动刷新，使用 Zustand 管理用户状态，动态渲染侧边栏菜单。"
date: "2025-12-17"
seriesOrder: 15
---

# 15. 实战一：前端对接与全链路测试

## 引言

后端 API 开发完成了，但没有前端的系统是不完整的。
作为一名前端开发者，你可能更关心：**后端给我的数据格式对不对？** **我的 Token 过期了怎么自动刷新？** **侧边栏菜单怎么根据后端返回的数据动态生成？**

本章我们将切换到前端视角，使用 **Next.js 16** 和 **Ant Design 6** 来对接我们刚刚开发好的 Go RBAC 系统。

## 1. 前端项目初始化

```bash
npx create-next-app@latest rbac-admin
# 选型: TypeScript, ESLint, Tailwind CSS, App Router, src directory

cd rbac-admin
pnpm add antd @ant-design/icons axios zustand
```

## 2. Axios 封装：处理 JWT 刷新

这是前后端对接中最核心的部分。我们需要在 Axios 拦截器中实现第 12 章提到的**双令牌刷新逻辑**。

创建 `src/utils/request.ts`:

```typescript
import axios from 'axios';

const instance = axios.create({
  baseURL: '/api/v1',
  timeout: 10000,
});

// 请求拦截器：注入 Access Token
instance.interceptors.request.use((config) => {
  const token = localStorage.getItem('access_token');
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

// 响应拦截器：处理 401 和 Token 刷新
instance.interceptors.response.use(
  (response) => response.data,
  async (error) => {
    const originalRequest = error.config;

    // 如果是 401 且不是刷新接口本身
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const refreshToken = localStorage.getItem('refresh_token');
        // 调用刷新接口
        const { data } = await axios.post('/api/v1/auth/refresh', {
          refresh_token: refreshToken,
        });

        // 保存新 Token
        localStorage.setItem('access_token', data.access_token);
        localStorage.setItem('refresh_token', data.refresh_token);

        // 重发原请求
        originalRequest.headers.Authorization = `Bearer ${data.access_token}`;
        return instance(originalRequest);
      } catch (refreshError) {
        // 刷新失败（Refresh Token 也过期了），强制登出
        localStorage.clear();
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }
    return Promise.reject(error);
  }
);

export default instance;
```

## 3. 状态管理：Zustand

使用 Zustand 管理用户信息和菜单数据。

创建 `src/store/userStore.ts`:

```typescript
import { create } from 'zustand';
import { MenuItem } from '@/types'; // 假设你定义了类型

interface UserState {
  userInfo: any;
  menus: MenuItem[];
  setUserInfo: (info: any) => void;
  setMenus: (menus: MenuItem[]) => void;
}

export const useUserStore = create<UserState>((set) => ({
  userInfo: null,
  menus: [],
  setUserInfo: (info) => set({ userInfo: info }),
  setMenus: (menus) => set({ menus }),
}));
```

## 4. 动态菜单渲染

在 `src/app/layout.tsx` 或你的后台 Layout 组件中，调用后端接口获取菜单树。

```typescript
// src/components/AdminLayout.tsx
'use client';
import { useEffect } from 'react';
import { Layout, Menu } from 'antd';
import { useUserStore } from '@/store/userStore';
import request from '@/utils/request';

const { Sider, Content } = Layout;

export default function AdminLayout({ children }: { children: React.ReactNode }) {
  const { menus, setMenus } = useUserStore();

  useEffect(() => {
    // 获取当前用户的菜单树
    request.get('/menus/me').then((res: any) => {
      if (res.code === 0) {
        setMenus(res.data);
      }
    });
  }, []);

  // 递归渲染菜单项
  const renderMenuItems = (items: any[]) => {
    return items.map((item) => {
      if (item.children && item.children.length > 0) {
        return (
          <Menu.SubMenu key={item.id} title={item.title} icon={<i className={item.icon} />}>
            {renderMenuItems(item.children)}
          </Menu.SubMenu>
        );
      }
      return (
        <Menu.Item key={item.id} icon={<i className={item.icon} />}>
          {item.title}
        </Menu.Item>
      );
    });
  };

  return (
    <Layout style={{ minHeight: '100vh' }}>
      <Sider>
        <Menu theme="dark" mode="inline">
          {renderMenuItems(menus)}
        </Menu>
      </Sider>
      <Content style={{ margin: '16px' }}>{children}</Content>
    </Layout>
  );
}
```

## 5. 按钮级权限控制

除了页面访问（由 Next.js 路由和菜单控制），我们还需要控制按钮的显示。
例如：只有拥有 `user:delete` 权限的用户才能看到"删除"按钮。

创建一个高阶组件或 Hook：

```typescript
// src/components/Auth.tsx
import { useUserStore } from '@/store/userStore';

export const Auth = ({ permission, children }: { permission: string; children: React.ReactNode }) => {
  const { userInfo } = useUserStore();
  
  // 假设 userInfo.permissions 是一个字符串数组 ['user:add', 'user:delete']
  // 这需要后端在登录或获取用户信息时返回
  if (userInfo?.permissions?.includes(permission)) {
    return <>{children}</>;
  }
  
  return null; // 不渲染
};
```

**使用：**

```tsx
<Auth permission="user:delete">
  <Button danger>删除用户</Button>
</Auth>
```

## 6. 全链路测试 (Integration Test)

现在，启动后端 Go 服务和前端 Next.js 服务，进行完整流程测试：

1.  **登录**：输入 `admin/123456`，观察 Network 面板，确认 `/auth/login` 返回了 `access_token` 和 `refresh_token`。
2.  **菜单加载**：登录成功后跳转首页，观察 `/menus/me` 接口返回的 JSON 树，确认侧边栏是否正确渲染。
3.  **Token 刷新**：
    -   手动修改 LocalStorage 中的 `access_token`（比如删掉最后一位），使其失效。
    -   刷新页面或点击某个按钮。
    -   观察 Network，应该会看到一个红色的 401 请求，紧接着一个 `/auth/refresh` 请求，然后原请求自动重试并成功。
4.  **权限控制**：
    -   创建一个新角色 `guest`，只分配"查看用户"权限，不分配"删除用户"权限。
    -   用 `guest` 账号登录。
    -   确认"删除"按钮不可见，且直接调用删除接口报 403。

## 7. 总结

本章我们完成了前后端的最后一块拼图。
通过前端的实际对接，我们验证了后端 API 的可用性：
1.  **JWT 刷新机制**在前端 Axios 拦截器中完美工作。
2.  **树形菜单结构**直接被 Ant Design Menu 组件消费。
3.  **RBAC 权限**真正落地到了每一个按钮和每一个请求。

**下一章预告**：
实战项目一圆满结束！下一章我们将总结整个项目的架构，并介绍如何将这个单体应用**部署到生产环境**（CI/CD 流水线）。
