---
title: "核心：Gin 框架与 RESTful API 设计"
description: "深入理解 RESTful 架构风格，使用 Gin 框架实现资源的分组管理。封装统一的响应结构，建立企业级 API 开发规范。"
date: "2025-12-04"
seriesOrder: 2
---

# 2. 核心：Gin 框架与 RESTful API 设计

## 引言

在上一章，我们搭建了项目的骨架。现在，我们要开始填充血肉了。

对于 Web 后端来说，**API** 就是产品的界面。设计糟糕的 API 会让前端开发者痛不欲生（比如：状态码永远返回 200，错误信息在 Body 里乱飘）。

本章我们将引入 Go 语言中最流行的 Web 框架 —— **Gin**，并制定一套严格的 **RESTful API 设计规范**。

## 1. 为什么选择 Gin？

在 Node.js 世界里，你有 Express（简单、灵活）和 NestJS（大而全、规范）。
在 Go 的世界里，**Gin** 更像是 Express，但性能是它的 40 倍。

-   **极速**：基于 httprouter，路由匹配性能极高。
-   **中间件支持**：洋葱模型（类似 Koa），非常适合做鉴权、日志。
-   **JSON 处理**：内置极其方便的 JSON 序列化和验证。

## 2. 安装 Gin

```bash
go get -u github.com/gin-gonic/gin
```

## 3. RESTful API 设计规范

在开始写代码前，我们先约定好 API 的设计原则。

### 3.1 资源 (Resource) 与 动词 (Verb)

API 应该是面向资源的。

| 操作 | HTTP 动词 | URL 示例 | 含义 |
|------|-----------|----------|------|
| 创建 | POST | `/api/v1/articles` | 发布一篇新文章 |
| 查询列表 | GET | `/api/v1/articles` | 获取文章列表 |
| 查询单条 | GET | `/api/v1/articles/:id` | 获取指定 ID 的文章 |
| 更新 | PUT/PATCH | `/api/v1/articles/:id` | 修改文章 (PUT 全量, PATCH 增量) |
| 删除 | DELETE | `/api/v1/articles/:id` | 删除文章 |

### 3.2 状态码 (Status Code)

不要永远返回 200！前端需要根据状态码做不同的交互处理。

-   `200 OK`: 查询/更新/删除成功。
-   `201 Created`: 创建成功。
-   `400 Bad Request`: 参数错误（如必填项为空）。
-   `401 Unauthorized`: 未登录。
-   `403 Forbidden`: 已登录但无权限。
-   `404 Not Found`: 资源不存在。
-   `500 Internal Server Error`: 服务器炸了。

### 3.3 统一响应结构 (Unified Response)

前端最怕后端接口返回的数据格式五花八门。我们需要封装一个统一的响应结构。

在 `pkg/util/response.go` 中定义：

```go
package util

import (
	"net/http"

	"github.com/gin-gonic/gin"
)

// Response 统一响应结构
type Response struct {
	Code    int         `json:"code"`    // 业务码，0 表示成功，非 0 表示错误
	Message string      `json:"message"` // 提示信息
	Data    interface{} `json:"data"`    // 数据载荷
}

// Success 成功响应
func Success(c *gin.Context, data interface{}) {
	c.JSON(http.StatusOK, Response{
		Code:    0,
		Message: "success",
		Data:    data,
	})
}

// Error 错误响应
func Error(c *gin.Context, httpCode int, errCode int, msg string) {
	c.JSON(httpCode, Response{
		Code:    errCode,
		Message: msg,
		Data:    nil,
	})
}
```

## 4. 实战：实现文章 API

我们将按照 **Controller (API 层)** -> **Service (业务层)** -> **Repository (数据层)** 的分层架构来开发。虽然目前还没有数据库，我们先用 Mock 数据打通链路。

### 4.1 定义 Controller

创建 `internal/api/v1/article.go`:

```go
package v1

import (
	"go-blog-api/pkg/util"
	"strconv"

	"github.com/gin-gonic/gin"
)

type ArticleController struct{}

func NewArticleController() *ArticleController {
	return &ArticleController{}
}

// GetArticle 获取单篇文章
// @Summary 获取文章详情
// @Tags 文章
// @Param id path int true "文章ID"
// @Success 200 {object} util.Response
// @Router /api/v1/articles/{id} [get]
func (ctrl *ArticleController) GetArticle(c *gin.Context) {
	idStr := c.Param("id")
	id, err := strconv.Atoi(idStr)
	if err != nil {
		util.Error(c, http.StatusBadRequest, 40001, "Invalid ID format")
		return
	}

	// 模拟从 Service 层获取数据
	mockData := map[string]interface{}{
		"id":      id,
		"title":   "Gin 实战指南",
		"content": "Gin 是一个高性能的 Go Web 框架...",
	}

	util.Success(c, mockData)
}
```

### 4.2 注册路由

创建 `internal/router/router.go`:

```go
package router

import (
	v1 "go-blog-api/internal/api/v1"
	"go-blog-api/pkg/config"

	"github.com/gin-gonic/gin"
)

func InitRouter() *gin.Engine {
	// 设置运行模式
	gin.SetMode(config.AppConfig.Server.Mode)

	r := gin.New()
	r.Use(gin.Logger())
	r.Use(gin.Recovery())

	// 初始化 Controller
	articleCtrl := v1.NewArticleController()

	// 路由分组
	apiV1 := r.Group("/api/v1")
	{
		articles := apiV1.Group("/articles")
		{
			articles.GET("/:id", articleCtrl.GetArticle)
			// articles.POST("", articleCtrl.CreateArticle)
			// articles.PUT("/:id", articleCtrl.UpdateArticle)
		}
	}

	return r
}
```

### 4.3 修改入口文件

修改 `cmd/server/main.go`，使用 Gin 的 Router 替换 `net/http`。

```go
package main

import (
	"fmt"
	"go-blog-api/internal/router"
	"go-blog-api/pkg/config"
	"net/http"
)

func main() {
	// 1. 初始化配置
	config.InitConfig()

	// 2. 初始化路由
	r := router.InitRouter()

	// 3. 启动服务
	addr := ":" + config.AppConfig.Server.Port
	fmt.Printf("Server starting on %s\n", addr)
	
	srv := &http.Server{
		Addr:    addr,
		Handler: r,
	}

	if err := srv.ListenAndServe(); err != nil {
		panic(err)
	}
}
```

## 5. 验证

运行项目：
```bash
go run cmd/server/main.go
```

测试接口：
```bash
curl http://localhost:8080/api/v1/articles/1
```

响应：
```json
{
    "code": 0,
    "message": "success",
    "data": {
        "content": "Gin 是一个高性能的 Go Web 框架...",
        "id": 1,
        "title": "Gin 实战指南"
    }
}
```

尝试输入非法 ID：
```bash
curl http://localhost:8080/api/v1/articles/abc
```

响应：
```json
{
    "code": 40001,
    "message": "Invalid ID format",
    "data": null
}
```

## 6. 总结

本章我们完成了：
1.  **引入 Gin**：替换了原生的 `net/http`。
2.  **规范响应**：封装了 `util.Success` 和 `util.Error`，告别随意的 JSON 返回。
3.  **路由分组**：使用 `Group("/api/v1")` 管理版本，结构清晰。

**下一章预告**：
只有 API 没有数据是空洞的。下一章我们将引入 **GORM** 和 **MySQL**，设计用户表和文章表，并学习如何处理**逻辑外键**和**索引优化**。我们将真正连接数据库，实现数据的持久化。
