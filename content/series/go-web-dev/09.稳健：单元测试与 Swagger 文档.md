---
title: "稳健：单元测试与 Swagger 文档"
description: "提升代码质量与协作效率。使用 Go 标准库 testing 和 testify 编写单元测试，Mock 掉数据库依赖。集成 Swagger 自动生成 API 文档。"
date: "2025-12-11"
seriesOrder: 9
---

# 9. 稳健：单元测试与 Swagger 文档

## 引言

在小团队或个人项目中，我们可能习惯了"写完代码直接运行看效果"。但在企业级开发中，**单元测试**是代码质量的生命线。

> **前端同学的类比**：
> 
> 你可能用过 Jest、Vitest 或 Testing Library 来测试 React 组件。后端的单元测试思路完全一样：
> 
> - 给一个函数输入特定参数
> - 验证输出是否符合预期
> - 如果函数依赖外部服务（如数据库），就用 Mock 替代

同时，作为后端，提供一份清晰、实时更新的 **API 文档** 是对前端同事最大的尊重。

> 你一定遇到过这种情况：后端说"接口改了"，但文档没更新，你调了半天才发现参数名变了...
> 
> **Swagger** 可以从代码注释自动生成文档，代码改了文档就自动更新，永远不会过时。

本章我们将学习如何测试 Service 层，以及如何自动生成 Swagger 文档。

### 本章目标

学完这一章，你将能够：

1. 理解单元测试的价值，以及"测试金字塔"的概念；
2. 使用 Go 标准库 `testing` 编写表格驱动测试；
3. 使用 `testify/mock` 模拟数据库依赖，隔离测试；
4. 集成 Swagger，通过注释自动生成 API 文档；
5. 在浏览器中访问交互式文档页面，直接测试接口。

## 1. 单元测试 (Unit Test)

### 1.0 为什么需要单元测试？

你可能会想："我手动测一下不就行了？"

手动测试的问题：

1. **不可重复**：你改了一行代码，要把所有功能都点一遍吗？
2. **不可记录**：一个月后你还记得当初测了哪些场景吗？
3. **不可自动化**：每次上线前都要人工回归一遍？

单元测试的价值：

- **自动化回归**：改了代码，跑一遍测试，3 秒钟知道有没有 Bug；
- **文档作用**：测试用例本身就是"这个函数怎么用"的活文档；
- **重构保障**：有测试兜底，你可以大胆重构，不怕改坏。

### 1.1 测试金字塔

在软件测试领域，有一个经典的"测试金字塔"模型：

```
        △  端到端测试 (E2E)
       ━━━  少量，慢，贵
      ━━━━━  集成测试
     ━━━━━━━  中等数量
    ━━━━━━━━━  单元测试
   ━━━━━━━━━━━  大量，快，便宜
```

- **单元测试**：测试单个函数/方法，不依赖外部服务（数据库、网络）；
- **集成测试**：测试多个模块协作，可能会启动真实数据库；
- **端到端测试**：模拟用户行为，如 Cypress、Playwright。

本章聚焦**单元测试**——测试量最大、性价比最高的那一层。

### 1.2 Go 语言内置的测试框架

Go 语言内置了强大的测试框架 `testing`，不需要额外安装。

### 1.3 表格驱动测试 (Table Driven Test)

> **前端类比**：这类似于 Jest 中的 `test.each` 或 Vitest 的参数化测试。

这是 Go 社区推荐的测试写法。我们将测试数据和预期结果定义在一个表格（Slice）中，然后遍历执行。

**为什么叫"表格"驱动？**

想象一个 Excel 表格：

| 用例名 | 输入 a | 输入 b | 期望输出 |
|--------|--------|--------|----------|
| 正数   | 1      | 2      | 3        |
| 负数   | -1     | -2     | -3       |
| 混合   | -1     | 2      | 1        |

我们把这个表格翻译成 Go 代码：

```go
// 一个简单的加法函数
func Add(a, b int) int {
    return a + b
}

// 测试文件：xxx_test.go
func TestAdd(t *testing.T) {
    // 定义"表格"：每一行是一个测试用例
    tests := []struct {
        name string  // 用例名称，方便定位失败的测试
        a    int     // 输入参数 a
        b    int     // 输入参数 b
        want int     // 期望的输出
    }{
        {"正数相加", 1, 2, 3},
        {"负数相加", -1, -2, -3},
        {"正负混合", -1, 2, 1},
        {"零", 0, 0, 0},
    }

    // 遍历表格，逐行执行测试
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            got := Add(tt.a, tt.b)
            if got != tt.want {
                t.Errorf("Add(%d, %d) = %d, want %d", tt.a, tt.b, got, tt.want)
            }
        })
    }
}
```

**运行测试：**

```bash
go test ./... -v
```

输出：

```
=== RUN   TestAdd
=== RUN   TestAdd/正数相加
=== RUN   TestAdd/负数相加
=== RUN   TestAdd/正负混合
=== RUN   TestAdd/零
--- PASS: TestAdd (0.00s)
    --- PASS: TestAdd/正数相加 (0.00s)
    --- PASS: TestAdd/负数相加 (0.00s)
    --- PASS: TestAdd/正负混合 (0.00s)
    --- PASS: TestAdd/零 (0.00s)
```

**表格驱动的好处：**

1. **易于扩展**：要加新用例？往数组里加一行就行；
2. **结构清晰**：所有测试数据一目了然；
3. **失败定位**：`t.Run(name)` 让你能精确知道哪个用例失败了。

### 1.4 Mock 依赖：隔离测试的关键

> **前端类比**：这类似于 Jest 的 `jest.mock()` 或 MSW (Mock Service Worker)。

#### 什么是 Mock？

Mock 就是"假装"——用一个假的实现替代真实的依赖。

**为什么需要 Mock？**

假设我们要测试 `UserService.Login()` 方法：

```go
func (s *UserService) Login(req *LoginRequest) (*LoginResponse, error) {
    user, err := s.userRepo.GetByUsername(req.Username) // 从数据库查询用户
    if err != nil {
        return nil, err
    }
    // 验证密码...
}
```

问题来了：

1. 如果不 Mock，测试时需要连接真实数据库；
2. 数据库里要有测试数据；
3. 测试速度慢（数据库 I/O）；
4. 测试不稳定（网络问题、数据被其他测试修改）。

**Mock 的解决方案**：

用一个"假的" `UserRepository` 替换真实的，让它直接返回我们预设的数据。

#### 依赖注入与接口

要实现 Mock，首先需要**依赖接口而非具体实现**（这是依赖倒置原则 DIP）。

> **前端类比**：就像 React 中不直接调用 `fetch`，而是注入一个 `apiClient`，这样测试时可以替换成 Mock 版本。

**重构代码，定义接口：**

```go
// internal/repository/user_repo.go

// 定义接口
type IUserRepository interface {
    GetByUsername(username string) (*model.User, error)
    Create(user *model.User) error
    // ... 其他方法
}

// 真实实现
type UserRepository struct {
    db *gorm.DB
}

// 实现接口方法
func (r *UserRepository) GetByUsername(username string) (*model.User, error) {
    var user model.User
    if err := r.db.Where("username = ?", username).First(&user).Error; err != nil {
        return nil, err
    }
    return &user, nil
}
```

**Service 依赖接口：**

```go
// internal/service/user_service.go

type UserService struct {
    userRepo repository.IUserRepository // 依赖接口，而非具体结构体
}

// 通过构造函数注入依赖
func NewUserService(repo repository.IUserRepository) *UserService {
    return &UserService{userRepo: repo}
}
```

#### 使用 testify/mock 编写 Mock

```bash
go get github.com/stretchr/testify
```

**编写 Mock 对象：**

```go
// internal/service/user_service_test.go

import (
    "testing"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/mock"
)

// Mock 实现
type MockUserRepo struct {
    mock.Mock  // 嵌入 mock.Mock
}

// 实现接口方法
func (m *MockUserRepo) GetByUsername(username string) (*model.User, error) {
    args := m.Called(username)  // 记录调用参数
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*model.User), args.Error(1)
}

func (m *MockUserRepo) Create(user *model.User) error {
    args := m.Called(user)
    return args.Error(0)
}
```

**编写测试：**

```go
func TestUserService_Login_Success(t *testing.T) {
    // 1. 创建 Mock 对象
    mockRepo := new(MockUserRepo)
    
    // 2. 注入到 Service
    service := NewUserService(mockRepo)

    // 3. 设定预期行为：
    // "当调用 GetByUsername('tom') 时，返回这个 User 对象"
    mockRepo.On("GetByUsername", "tom").Return(&model.User{
        ID:       1,
        Username: "tom",
        Password: "$2a$10$...", // bcrypt 加密后的密码
    }, nil)

    // 4. 执行测试
    resp, err := service.Login(&LoginRequest{
        Username: "tom",
        Password: "123456",
    })
    
    // 5. 断言结果
    assert.NoError(t, err)
    assert.NotNil(t, resp)
    assert.NotEmpty(t, resp.Token)
    
    // 6. 验证 Mock 是否按预期被调用
    mockRepo.AssertExpectations(t)
}

func TestUserService_Login_UserNotFound(t *testing.T) {
    mockRepo := new(MockUserRepo)
    service := NewUserService(mockRepo)

    // 模拟用户不存在的场景
    mockRepo.On("GetByUsername", "unknown").Return(nil, gorm.ErrRecordNotFound)

    resp, err := service.Login(&LoginRequest{
        Username: "unknown",
        Password: "123456",
    })
    
    assert.Error(t, err)
    assert.Nil(t, resp)
    mockRepo.AssertExpectations(t)
}
```

**Mock 的工作原理图解：**

```
正常流程：
UserService → UserRepository → MySQL 数据库

测试流程：
UserService → MockUserRepo → 直接返回预设数据（不经过数据库）
```

## 2. Swagger 文档

> **前端类比**：类似于 TypeScript 的类型定义可以生成文档，或者 GraphQL 的 Schema 自动生成 API 文档。

### 2.0 什么是 Swagger？

Swagger (OpenAPI) 是 RESTful API 文档的**事实标准**。

**没有 Swagger 的痛苦：**

1. 后端写了接口，前端不知道怎么调；
2. 后端改了接口，忘了更新文档；
3. 文档是 Word/Notion 写的，跟代码完全脱节；
4. 前端："这个字段是什么类型？" 后端："等我看看代码..."

**Swagger 的价值：**

1. **文档即代码**：文档直接从代码注释生成，永远同步；
2. **交互式测试**：在浏览器里直接发请求测试接口；
3. **类型导出**：前端可以从 Swagger 生成 TypeScript 类型（如用 `swagger-typescript-api`）。

### 2.1 安装工具

Go 中最常用的 Swagger 工具是 `swaggo/swag`：

```bash
# 安装 swag CLI 工具
go install github.com/swaggo/swag/cmd/swag@latest

# 安装 Gin 集成包
go get -u github.com/swaggo/gin-swagger
go get -u github.com/swaggo/files
```

### 2.2 编写注释

Swagger 通过解析**特定格式的注释**来生成文档。

> **这就是"文档即代码"的核心——注释写在代码旁边，代码改了，注释跟着改。**

**项目级注释（main.go）：**

```go
// @title Go Blog API
// @version 1.0
// @description 一个用 Go + Gin 构建的博客 API
// @host localhost:8080
// @BasePath /api/v1
// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
func main() {
    // ...
}
```

**接口级注释（Controller）：**

```go
// Login 用户登录
// @Summary 用户登录
// @Description 使用用户名和密码登录，获取 JWT Token
// @Tags 用户认证
// @Accept json
// @Produce json
// @Param request body service.LoginRequest true "登录信息"
// @Success 200 {object} util.Response{data=service.LoginResponse} "成功返回 Token"
// @Failure 400 {object} util.Response "参数错误"
// @Failure 401 {object} util.Response "用户名或密码错误"
// @Router /auth/login [post]
func (ctrl *UserController) Login(c *gin.Context) {
    // ...
}

// GetArticle 获取文章详情
// @Summary 获取文章详情
// @Description 根据文章 ID 获取文章详情
// @Tags 文章
// @Accept json
// @Produce json
// @Param id path int true "文章 ID"
// @Success 200 {object} util.Response{data=model.Article}
// @Failure 404 {object} util.Response "文章不存在"
// @Security BearerAuth
// @Router /articles/{id} [get]
func (ctrl *ArticleController) GetArticle(c *gin.Context) {
    // ...
}
```

**注释标签说明：**

| 标签 | 说明 | 示例 |
|------|------|------|
| `@Summary` | 接口简短标题 | `用户登录` |
| `@Description` | 详细描述 | `使用用户名和密码登录...` |
| `@Tags` | 分组标签 | `用户认证` |
| `@Accept` | 接受的请求格式 | `json` |
| `@Produce` | 返回的响应格式 | `json` |
| `@Param` | 参数说明 | `name位置类型是否必须描述` |
| `@Success` | 成功响应 | `200 {object} Response` |
| `@Failure` | 失败响应 | `401 {object} Response` |
| `@Router` | 路由路径和方法 | `/auth/login [post]` |
| `@Security` | 需要的认证方式 | `BearerAuth` |

### 2.3 生成文档

在项目根目录运行：

```bash
swag init -g cmd/server/main.go
```

这会在项目根目录生成 `docs/` 目录：

```
docs/
├── docs.go       # Go 代码，用于注册文档
├── swagger.json  # JSON 格式的 API 文档
└── swagger.yaml  # YAML 格式的 API 文档
```

**每次修改了注释，都需要重新运行 `swag init`！**

### 2.4 挂载 Swagger UI

修改 `internal/router/router.go`：

```go
import (
    swaggerFiles "github.com/swaggo/files"
    ginSwagger "github.com/swaggo/gin-swagger"
    _ "go-blog-api/docs" // 必须导入生成的 docs 包（匿名导入）
)

func InitRouter() *gin.Engine {
    r := gin.Default()
    
    // 挂载 Swagger UI
    r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
    
    // ... 其他路由
    return r
}
```

## 3. 运行与验证

### 3.1 运行测试

```bash
# 运行所有测试
go test ./...

# 运行测试并显示详细输出
go test ./... -v

# 运行特定包的测试
go test ./internal/service -v

# 运行特定测试函数
go test ./internal/service -run TestUserService_Login -v

# 查看测试覆盖率
go test ./... -cover
```

### 3.2 访问 Swagger UI

启动服务后，访问 `http://localhost:8080/swagger/index.html`：

你会看到一个交互式文档页面：

1. 所有接口按 Tags 分组展示；
2. 点击任意接口，可以看到参数说明和返回值结构；
3. 点击 "Try it out"，可以直接在浏览器里测试接口；
4. 对于需要认证的接口，点击右上角的 "Authorize"，输入 Token。

## 4. 小结与练习

### 本章回顾

| 概念 | 说明 | 前端对应 |
|------|------|----------|
| 单元测试 | 测试单个函数/方法 | Jest/Vitest 单测 |
| 表格驱动测试 | 用数组定义多组测试数据 | test.each |
| Mock | 用假实现替代真实依赖 | jest.mock / MSW |
| 依赖注入 | Service 依赖接口而非具体实现 | 依赖注入 / Provider |
| Swagger | 从注释生成 API 文档 | GraphQL Schema / TypeDoc |

### 关键命令

```bash
# 运行测试
go test ./... -v

# 查看覆盖率
go test ./... -cover

# 生成 Swagger 文档
swag init -g cmd/server/main.go
```

### 动手练习

1. **编写 ArticleService 的测试**：
   - Mock 掉 `ArticleRepository`；
   - 测试 `CreateArticle`、`GetArticle` 方法；
   - 覆盖成功和失败两种场景。

2. **给所有 Controller 添加 Swagger 注释**：
   - 确保每个接口都有完整的文档；
   - 包含 `@Summary`、`@Param`、`@Success`、`@Failure`。

3. **前端集成**：
   - 使用 `swagger-typescript-api` 从 Swagger 生成 TypeScript 类型；
   - 在前端项目中使用生成的类型。

### 思考题

1. 为什么单元测试要 Mock 掉数据库，而不是用真实数据库？
2. 如果不用接口，直接 Mock 结构体会有什么问题？
3. Swagger 文档和 Postman 集合有什么区别？

**下一章预告**：
我们的应用已经开发完成，测试通过，文档齐全。最后一步，就是把它部署到服务器上。下一章我们将编写 **Dockerfile**，并使用 **Docker Compose** 一键编排 App、MySQL、Redis 和 RabbitMQ。
