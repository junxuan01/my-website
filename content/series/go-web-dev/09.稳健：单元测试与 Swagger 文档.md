---
title: "稳健：单元测试与 Swagger 文档"
description: "提升代码质量与协作效率。使用 Go 标准库 testing 和 testify 编写单元测试，Mock 掉数据库依赖。集成 Swagger 自动生成 API 文档。"
date: "2025-12-11"
seriesOrder: 9
---

# 9. 稳健：单元测试与 Swagger 文档

## 引言

在小团队或个人项目中，我们可能习惯了"写完代码直接运行看效果"。但在企业级开发中，**单元测试**是代码质量的生命线。

同时，作为后端，提供一份清晰、实时更新的 **API 文档** 是对前端同事最大的尊重。

本章我们将学习如何测试我们的 Service 层，以及如何自动生成 Swagger 文档。

## 1. 单元测试 (Unit Test)

Go 语言内置了强大的测试框架 `testing`。

### 1.1 表格驱动测试 (Table Driven Test)

这是 Go 社区推荐的测试写法。我们将测试数据和预期结果定义在一个表格（Slice）中，然后遍历执行。

假设我们要测试一个简单的加法函数：

```go
func Add(a, b int) int { return a + b }

func TestAdd(t *testing.T) {
    tests := []struct {
        name string
        a    int
        b    int
        want int
    }{
        {"positive", 1, 2, 3},
        {"negative", -1, -2, -3},
        {"mixed", -1, 2, 1},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            if got := Add(tt.a, tt.b); got != tt.want {
                t.Errorf("Add() = %v, want %v", got, tt.want)
            }
        })
    }
}
```

### 1.2 Mock 依赖

在测试 `UserService` 时，我们不想真的去连数据库。我们需要 **Mock** 掉 `UserRepository`。

我们可以使用 `github.com/stretchr/testify/mock`。

首先，我们需要让 `UserService` 依赖接口而不是具体结构体（这是依赖倒置原则的体现）。

**重构代码：**

```go
// internal/repository/user_repo.go
type IUserRepository interface {
    GetByUsername(username string) (*model.User, error)
    // ...
}

// internal/service/user_service.go
type UserService struct {
    userRepo repository.IUserRepository // 依赖接口
}
```

**编写 Mock 对象：**

```go
type MockUserRepo struct {
    mock.Mock
}

func (m *MockUserRepo) GetByUsername(username string) (*model.User, error) {
    args := m.Called(username)
    if args.Get(0) == nil {
        return nil, args.Error(1)
    }
    return args.Get(0).(*model.User), args.Error(1)
}
```

**编写测试：**

```go
func TestLogin(t *testing.T) {
    mockRepo := new(MockUserRepo)
    service := NewUserService(mockRepo)

    // 设定预期：当调用 GetByUsername("tom") 时，返回一个 User 对象
    mockRepo.On("GetByUsername", "tom").Return(&model.User{
        Username: "tom",
        Password: "hashed_password",
    }, nil)

    // 执行测试
    resp, err := service.Login(&LoginRequest{Username: "tom", Password: "password"})
    
    // 断言
    assert.NoError(t, err)
    assert.NotNil(t, resp)
    mockRepo.AssertExpectations(t)
}
```

## 2. Swagger 文档

Swagger (OpenAPI) 是 RESTful API 文档的事实标准。Go 中最常用的是 `swaggo/swag`。

### 2.1 安装工具

```bash
go install github.com/swaggo/swag/cmd/swag@latest
go get -u github.com/swaggo/gin-swagger
go get -u github.com/swaggo/files
```

### 2.2 编写注释

我们需要在 Controller 的方法上写特定格式的注释。

```go
// @Summary 用户登录
// @Description 使用用户名和密码登录，获取 Token
// @Tags 用户认证
// @Accept json
// @Produce json
// @Param request body service.LoginRequest true "登录信息"
// @Success 200 {object} util.Response{data=service.LoginResponse}
// @Router /api/v1/auth/login [post]
func (ctrl *UserController) Login(c *gin.Context) { ... }
```

### 2.3 生成文档

在项目根目录运行：

```bash
swag init -g cmd/server/main.go
```

这会生成 `docs/` 目录。

### 2.4 挂载 Swagger UI

修改 `internal/router/router.go`：

```go
import (
    swaggerFiles "github.com/swaggo/files"
    ginSwagger "github.com/swaggo/gin-swagger"
    _ "go-blog-api/docs" // 必须导入生成的 docs 包
)

func InitRouter() *gin.Engine {
    // ...
    r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
    // ...
}
```

## 3. 验证

启动服务，访问 `http://localhost:8080/swagger/index.html`。
你会看到一个漂亮的交互式文档页面，可以直接在上面测试接口。

## 4. 总结

本章我们完成了：
1.  **单元测试**：学会了 Table Driven Test 和 Mock 技术，保证了业务逻辑的正确性。
2.  **文档自动化**：使用 Swag 自动生成文档，解决了"文档跟不上代码"的千古难题。

**下一章预告**：
我们的应用已经开发完成，测试通过，文档齐全。最后一步，就是把它部署到服务器上。下一章我们将编写 **Dockerfile**，并使用 **Docker Compose** 一键编排 App、MySQL、Redis 和 RabbitMQ。
