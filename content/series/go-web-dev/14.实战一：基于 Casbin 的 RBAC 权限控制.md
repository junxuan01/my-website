---
title: "实战一：基于 Casbin 的 RBAC 权限控制"
description: "引入强大的权限引擎 Casbin。编写 RBAC 模型配置文件，集成 GORM Adapter 实现策略持久化。编写 Gin 中间件实现 API 级别的细粒度访问控制。"
date: "2025-12-16"
seriesOrder: 14
---

# 14. 实战一：基于 Casbin 的 RBAC 权限控制

## 引言

在上一章，我们完成了菜单和角色的管理。现在数据库里已经有了"角色-菜单"的关系。
但是，当用户请求 `DELETE /api/v1/users/1` 时，后端如何判断该用户是否有权限？

最笨的方法是写硬代码：
```go
if user.Role != "admin" { return 403 }
```
但这无法应对动态配置的权限。

本章我们将引入 Go 语言中最著名的权限引擎 —— **Casbin**。它支持 ACL, RBAC, ABAC 等多种模型，并且可以将策略存储在数据库中。

## 1. Casbin 核心概念

Casbin 的核心是 **PERM 模型** (Policy, Effect, Request, Matchers)。

我们需要定义一个模型文件 `configs/rbac_model.conf`：

```ini
[request_definition]
r = sub, obj, act
# sub: 访问者 (Subject)，即用户或角色
# obj: 访问对象 (Object)，即 API 路径
# act: 访问动作 (Action)，即 HTTP Method

[policy_definition]
p = sub, obj, act

[role_definition]
g = _, _
# g(u1, r1) 表示 u1 拥有角色 r1

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub) && keyMatch2(r.obj, p.obj) && r.act == p.act
# keyMatch2 支持路径通配符，如 /api/v1/users/:id
```

## 2. 集成 Casbin

我们需要安装核心库和 GORM 适配器：

```bash
go get github.com/casbin/casbin/v2
go get github.com/casbin/gorm-adapter/v3
```

### 2.1 初始化 Enforcer

创建 `pkg/auth/casbin.go`：

```go
package auth

import (
	"go-blog-api/pkg/db"
	"log"

	"github.com/casbin/casbin/v2"
	gormadapter "github.com/casbin/gorm-adapter/v3"
)

var Enforcer *casbin.Enforcer

func InitCasbin() {
	// 使用 GORM Adapter，将策略存储在 MySQL 的 casbin_rule 表中
	adapter, err := gormadapter.NewAdapterByDB(db.DB)
	if err != nil {
		log.Fatalf("Failed to create casbin adapter: %v", err)
	}

	// 加载模型配置
	Enforcer, err = casbin.NewEnforcer("configs/rbac_model.conf", adapter)
	if err != nil {
		log.Fatalf("Failed to create casbin enforcer: %v", err)
	}

	// 从数据库加载策略
	if err := Enforcer.LoadPolicy(); err != nil {
		log.Fatalf("Failed to load policy: %v", err)
	}
}
```

## 3. 编写权限中间件

我们需要一个中间件，拦截所有请求，询问 Casbin："当前用户能访问这个 URL 吗？"

创建 `internal/middleware/casbin.go`：

```go
package middleware

import (
	"go-blog-api/pkg/auth"
	"go-blog-api/pkg/util"
	"net/http"

	"github.com/gin-gonic/gin"
)

func CasbinAuth() gin.HandlerFunc {
	return func(c *gin.Context) {
		// 1. 获取请求信息
		path := c.Request.URL.Path
		method := c.Request.Method

		// 2. 获取当前用户角色 (从 JWT 中解析出来的 username 或 role)
		// 注意：Casbin 的 RBAC 通常是基于角色的。
		// 我们在 JWT 中存了 username，我们需要知道该 username 对应的角色。
		// 或者，我们可以直接把 username 当作 sub，然后在 Casbin 中定义 g(username, role)。
		username := c.GetString("username")
		if username == "" {
			util.Error(c, http.StatusUnauthorized, 401, "Unauthorized")
			c.Abort()
			return
		}

		// 3. 检查权限
		// Enforce(sub, obj, act)
		ok, err := auth.Enforcer.Enforce(username, path, method)
		if err != nil {
			util.Error(c, http.StatusInternalServerError, 500, "Auth error")
			c.Abort()
			return
		}

		if !ok {
			util.Error(c, http.StatusForbidden, 403, "No permission")
			c.Abort()
			return
		}

		c.Next()
	}
}
```

## 4. 策略同步 (Policy Sync)

这是最关键的一步。
我们在第 13 章实现了"给角色分配菜单"。但是 Casbin 并不知道这些变化。
我们需要在更新角色权限时，同步更新 Casbin 的策略。

### 4.1 策略格式

假设角色 `admin` 拥有菜单 `用户管理`，该菜单对应的 API 是 `GET /api/v1/users`。
我们需要向 Casbin 添加一条策略：
`p, admin, /api/v1/users, GET`

### 4.2 修改 RoleService

在 `internal/service/role_service.go` 中，修改 `UpdateRole` 方法：

```go
func (s *RoleService) UpdateRole(id uint, req *RoleRequest) error {
    // ... 原有的数据库更新逻辑 ...

    // --- 同步 Casbin ---
    
    // 1. 清除该角色旧的策略
    // remove p where v0 = role_name
    auth.Enforcer.RemoveFilteredPolicy(0, req.Name)

    // 2. 添加新的策略
    var policies [][]string
    for _, menuID := range req.MenuIDs {
        // 查出 Menu 对应的 Path 和 Method
        // 假设 Menu 表里有 Path 和 Method 字段 (之前定义的 Permission 字段可能需要拆分或解析)
        // 这里简化假设 Menu.Path = "/api/v1/users", Menu.Method = "GET"
        menu := s.getMenuByID(menuID) 
        if menu.Path != "" && menu.Method != "" {
            policies = append(policies, []string{req.Name, menu.Path, menu.Method})
        }
    }
    
    if len(policies) > 0 {
        auth.Enforcer.AddPolicies(policies)
    }
    
    return nil
}
```

### 4.3 用户与角色的关联

同样，当用户注册或管理员修改用户角色时，我们需要更新 `g` 策略。

`g, junxuan, admin`

```go
// 在 UserService.UpdateUserRole 中
auth.Enforcer.RemoveFilteredGroupingPolicy(0, username)
auth.Enforcer.AddGroupingPolicy(username, roleName)
```

## 5. 验证

1.  **配置策略**：给 `editor` 角色分配 `GET /api/v1/articles` 权限。
2.  **登录**：使用 `editor` 账号登录。
3.  **成功访问**：访问 `GET /api/v1/articles`，返回 200。
4.  **拒绝访问**：访问 `DELETE /api/v1/articles/1`，返回 403。

## 6. 总结

本章我们完成了 RBAC 的最后一块拼图 —— **权限拦截**。
1.  **Casbin 模型**：定义了灵活的 RBAC 规则。
2.  **中间件拦截**：在 API 入口处统一鉴权。
3.  **策略同步**：保证了管理后台的配置能实时生效到权限引擎中。

**下一章预告**：
后端开发基本完成。下一章我们将站在**前端开发者**的视角，看看如何使用 **Next.js 16** 和 **Ant Design 6** 来对接我们开发的这套 RBAC 接口，并进行全链路测试。
