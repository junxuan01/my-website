---
title: "实战一：基于 Casbin 的 RBAC 权限控制"
description: "引入强大的权限引擎 Casbin。编写 RBAC 模型配置文件，集成 GORM Adapter 实现策略持久化。编写 Gin 中间件实现 API 级别的细粒度访问控制。"
date: "2025-12-16"
seriesOrder: 14
---

# 14. 实战一：基于 Casbin 的 RBAC 权限控制

## 引言

在上一章，我们完成了菜单和角色的管理。现在数据库里已经有了"角色-菜单"的关系，前端也能根据用户角色动态渲染侧边栏了。

但这还不够安全。

> **前端同学请注意**：
> 
> 前端的"权限控制"本质上只是**隐藏 UI**——不显示某个菜单、不显示某个按钮。但如果用户知道接口地址，他完全可以用 Postman 或者浏览器开发者工具直接调用 API。
> 
> 比如，你在前端隐藏了"删除用户"按钮，但用户如果直接发 `DELETE /api/v1/users/1`，后端会怎么处理？

如果后端不做校验，这个请求就会成功。这就是为什么**后端必须做权限拦截**——不能信任前端传来的任何东西。

最笨的方法是写硬代码：

```go
// 不推荐的写法
if user.Role != "admin" { 
    return 403 
}
```

但这无法应对动态配置的权限（管理员在后台给某个角色新增了权限，总不能每次都改代码重新部署吧）。

本章我们将引入 Go 语言中最著名的权限引擎 —— **Casbin**。它支持 ACL、RBAC、ABAC 等多种模型，并且可以将策略存储在数据库中。

### 本章目标

学完这一章，你将能够：

1. 理解 Casbin 的 PERM 模型（Policy, Effect, Request, Matchers）；
2. 编写 RBAC 模型配置文件；
3. 使用 GORM Adapter 把权限策略存到 MySQL；
4. 编写 Gin 中间件，在 API 入口处统一鉴权；
5. 实现"权限变更即时生效"——管理员修改角色权限后，不需要用户重新登录。

## 1. Casbin 核心概念

### 1.1 什么是 Casbin？

Casbin 是一个高性能的、支持多种访问控制模型的授权库。你可以把它理解为一个**规则引擎**：

- 你告诉它"谁能做什么"（策略）；
- 每次请求来的时候，你问它"这个人能不能做这件事"（鉴权）；
- 它根据策略返回 `true` 或 `false`。

### 1.2 PERM 模型

Casbin 的核心是 **PERM 模型** (Policy, Effect, Request, Matchers)。

用一个类比来理解：

| 概念 | 类比 | 说明 |
|---|---|---|
| Request | 门卫收到的请求 | "张三要进 A 大楼" |
| Policy | 门禁名单 | "允许张三进 A 大楼" |
| Matcher | 门卫的判断逻辑 | "请求的人和名单上的人一样，且请求的地点和名单上的地点一样" |
| Effect | 最终结论 | "只要有一条策略允许，就放行" |

### 1.3 编写模型文件

我们需要定义一个模型文件 `configs/rbac_model.conf`：

```ini
[request_definition]
r = sub, obj, act
# sub: 访问者 (Subject)，可以是用户名或角色名
# obj: 访问对象 (Object)，即 API 路径，如 /api/v1/users
# act: 访问动作 (Action)，即 HTTP Method，如 GET, POST, DELETE

[policy_definition]
p = sub, obj, act
# 策略的格式：p, admin, /api/v1/users, GET
# 表示 admin 可以 GET /api/v1/users

[role_definition]
g = _, _
# 角色定义，g(user1, admin) 表示 user1 拥有 admin 角色

[policy_effect]
e = some(where (p.eft == allow))
# 只要有一条策略是 allow，就允许访问

[matchers]
m = g(r.sub, p.sub) && keyMatch2(r.obj, p.obj) && r.act == p.act
# 匹配规则：
# 1. r.sub（请求的用户）是否拥有 p.sub（策略中的角色）
# 2. r.obj（请求的路径）是否匹配 p.obj（策略中的路径），keyMatch2 支持 /users/:id 这种通配
# 3. r.act（请求的方法）是否等于 p.act（策略中的方法）
```

**用人话翻译**：

当用户 `zhangsan` 请求 `DELETE /api/v1/users/123` 时：

1. Casbin 先查：`zhangsan` 有什么角色？假设他有 `admin` 角色；
2. 再查：`admin` 角色能不能 `DELETE /api/v1/users/:id`？
3. 如果有这条策略，返回 `true`，允许访问；否则返回 `false`，拒绝访问。

## 2. 集成 Casbin

我们需要安装核心库和 GORM 适配器：

```bash
go get github.com/casbin/casbin/v2
go get github.com/casbin/gorm-adapter/v3
```

### 2.1 初始化 Enforcer

创建 `pkg/auth/casbin.go`：

```go
package auth

import (
	"go-blog-api/pkg/db"
	"log"

	"github.com/casbin/casbin/v2"
	gormadapter "github.com/casbin/gorm-adapter/v3"
)

var Enforcer *casbin.Enforcer

func InitCasbin() {
	// 使用 GORM Adapter，将策略存储在 MySQL 的 casbin_rule 表中
	adapter, err := gormadapter.NewAdapterByDB(db.DB)
	if err != nil {
		log.Fatalf("Failed to create casbin adapter: %v", err)
	}

	// 加载模型配置
	Enforcer, err = casbin.NewEnforcer("configs/rbac_model.conf", adapter)
	if err != nil {
		log.Fatalf("Failed to create casbin enforcer: %v", err)
	}

	// 从数据库加载策略
	if err := Enforcer.LoadPolicy(); err != nil {
		log.Fatalf("Failed to load policy: %v", err)
	}
}
```

## 3. 编写权限中间件

我们需要一个中间件，拦截所有请求，询问 Casbin："当前用户能访问这个 URL 吗？"

创建 `internal/middleware/casbin.go`：

```go
package middleware

import (
	"go-blog-api/pkg/auth"
	"go-blog-api/pkg/util"
	"net/http"

	"github.com/gin-gonic/gin"
)

func CasbinAuth() gin.HandlerFunc {
	return func(c *gin.Context) {
		// 1. 获取请求信息
		path := c.Request.URL.Path
		method := c.Request.Method

		// 2. 获取当前用户角色 (从 JWT 中解析出来的 username 或 role)
		// 注意：Casbin 的 RBAC 通常是基于角色的。
		// 我们在 JWT 中存了 username，我们需要知道该 username 对应的角色。
		// 或者，我们可以直接把 username 当作 sub，然后在 Casbin 中定义 g(username, role)。
		username := c.GetString("username")
		if username == "" {
			util.Error(c, http.StatusUnauthorized, 401, "Unauthorized")
			c.Abort()
			return
		}

		// 3. 检查权限
		// Enforce(sub, obj, act)
		ok, err := auth.Enforcer.Enforce(username, path, method)
		if err != nil {
			util.Error(c, http.StatusInternalServerError, 500, "Auth error")
			c.Abort()
			return
		}

		if !ok {
			util.Error(c, http.StatusForbidden, 403, "No permission")
			c.Abort()
			return
		}

		c.Next()
	}
}
```

## 4. 策略同步 (Policy Sync)

这是最关键的一步。
我们在第 13 章实现了"给角色分配菜单"。但是 Casbin 并不知道这些变化。
我们需要在更新角色权限时，同步更新 Casbin 的策略。

### 4.1 策略格式

假设角色 `admin` 拥有菜单 `用户管理`，该菜单对应的 API 是 `GET /api/v1/users`。
我们需要向 Casbin 添加一条策略：
`p, admin, /api/v1/users, GET`

### 4.2 修改 RoleService

在 `internal/service/role_service.go` 中，修改 `UpdateRole` 方法：

```go
func (s *RoleService) UpdateRole(id uint, req *RoleRequest) error {
    // ... 原有的数据库更新逻辑 ...

    // --- 同步 Casbin ---
    
    // 1. 清除该角色旧的策略
    // remove p where v0 = role_name
    auth.Enforcer.RemoveFilteredPolicy(0, req.Name)

    // 2. 添加新的策略
    var policies [][]string
    for _, menuID := range req.MenuIDs {
        // 查出 Menu 对应的 Path 和 Method
        // 假设 Menu 表里有 Path 和 Method 字段 (之前定义的 Permission 字段可能需要拆分或解析)
        // 这里简化假设 Menu.Path = "/api/v1/users", Menu.Method = "GET"
        menu := s.getMenuByID(menuID) 
        if menu.Path != "" && menu.Method != "" {
            policies = append(policies, []string{req.Name, menu.Path, menu.Method})
        }
    }
    
    if len(policies) > 0 {
        auth.Enforcer.AddPolicies(policies)
    }
    
    return nil
}
```

### 4.3 用户与角色的关联

同样，当用户注册或管理员修改用户角色时，我们需要更新 `g` 策略。

`g, junxuan, admin`

```go
// 在 UserService.UpdateUserRole 中
auth.Enforcer.RemoveFilteredGroupingPolicy(0, username)
auth.Enforcer.AddGroupingPolicy(username, roleName)
```

## 5. 验证

1.  **配置策略**：给 `editor` 角色分配 `GET /api/v1/articles` 权限。
2.  **登录**：使用 `editor` 账号登录。
3.  **成功访问**：访问 `GET /api/v1/articles`，返回 200。
4.  **拒绝访问**：访问 `DELETE /api/v1/articles/1`，返回 403。

## 6. 本章小结与练习

这一章，我们完成了 RBAC 系统的最后一块拼图 —— **API 级别的权限拦截**：

1. **Casbin 模型**：
   - 理解了 PERM 模型（Policy, Effect, Request, Matchers）；
   - 编写了 RBAC 模型配置文件，定义了"谁能访问什么"的规则。

2. **GORM Adapter**：
   - 使用 `gorm-adapter` 把策略存储在 MySQL 的 `casbin_rule` 表中；
   - 策略持久化后，重启服务也不会丢失。

3. **Gin 中间件**：
   - 在 API 入口处统一调用 `Enforcer.Enforce()`；
   - 权限不足直接返回 403，不需要在每个 Controller 里写判断。

4. **策略同步**：
   - 管理员修改角色权限时，同步更新 Casbin 的 Policy 和 Grouping Policy；
   - 权限变更即时生效，不需要用户重新登录。

> **前后端协作要点**：
> 
> - 前端通过菜单/按钮权限控制 UI 显示（体验好）；
> - 后端通过 Casbin 中间件控制 API 访问（安全）；
> - 两者相辅相成，缺一不可。

### 思考题 / 练习

1. **测试权限拦截**：
   - 创建一个角色 `viewer`，只分配 `GET /api/v1/articles` 权限；
   - 用 `viewer` 角色的用户登录；
   - 尝试 `DELETE /api/v1/articles/1`，验证是否返回 403。

2. **实现白名单**：
   - 有些接口不需要权限校验，比如 `/api/v1/auth/login`、`/api/v1/auth/refresh`；
   - 修改 Casbin 中间件，加入白名单逻辑，跳过这些路径的鉴权。

3. **实现超级管理员**：
   - 超级管理员（`admin` 角色）应该能访问所有接口，不需要配置每一条策略；
   - 提示：可以在 Matcher 中加入特殊判断，如 `r.sub == "admin" || (原有逻辑)`。

4. **理解策略同步时机**：
   - 目前我们在 `UpdateRole` 时同步 Casbin 策略；
   - 思考：如果管理员修改了某个用户的角色（`UpdateUserRoles`），是否也需要同步 Casbin？应该同步哪种策略（Policy 还是 Grouping Policy）？

> Casbin 是一个功能非常强大的库，除了 RBAC，还支持 ACL（访问控制列表）、ABAC（基于属性的访问控制）等模型。如果你对权限设计感兴趣，推荐阅读 [Casbin 官方文档](https://casbin.org/docs/overview)。
