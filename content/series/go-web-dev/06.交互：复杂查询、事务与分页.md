---
title: "交互：复杂查询、事务与分页"
description: "深入 GORM 高级用法。解决 N+1 查询性能问题，使用 Preload 加载关联数据。掌握数据库事务（Transaction）的使用场景，实现高效的分页查询接口。"
date: "2025-12-08"
seriesOrder: 6
---

# 6. 交互：复杂查询、事务与分页

## 引言

在前面的章节中，我们完成了用户注册、登录和鉴权。现在，我们要进入博客系统的核心业务：**文章管理**。

这不仅仅是简单的 CRUD。在真实业务中，我们需要处理：
1.  **关联查询**：查文章时要把作者信息带出来。
2.  **N+1 问题**：如何避免查 10 篇文章发出了 11 条 SQL？
3.  **事务**：发布文章同时要增加用户的积分，如何保证原子性？
4.  **分页**：当文章有 10 万篇时，如何高效分页？

## 1. 关联查询与 N+1 问题

### 1.1 什么是 N+1 问题？

假设我们要获取文章列表，并显示每篇文章的作者。

**错误写法 (伪代码):**
```go
articles := db.FindAllArticles() // 1 条 SQL
for _, article := range articles {
    user := db.FindUser(article.UserID) // N 条 SQL
}
```
如果有 20 篇文章，就会执行 1 + 20 = 21 条 SQL。这就是 N+1 问题，性能杀手。

### 1.2 GORM 的 Preload

GORM 提供了 `Preload` 方法来解决这个问题，它会生成两条 SQL：一条查文章，一条查用户（使用 `IN` 查询），然后在内存中组装。

修改 `internal/repository/article_repo.go`:

```go
package repository

import (
	"go-blog-api/internal/model"
	"go-blog-api/pkg/db"

	"gorm.io/gorm"
)

type ArticleRepository struct {
	db *gorm.DB
}

func NewArticleRepository() *ArticleRepository {
	return &ArticleRepository{db: db.DB}
}

// List 获取文章列表 (带分页和作者信息)
func (r *ArticleRepository) List(offset, limit int) ([]model.Article, int64, error) {
	var articles []model.Article
	var total int64

	// 1. 计算总数
	if err := r.db.Model(&model.Article{}).Count(&total).Error; err != nil {
		return nil, 0, err
	}

	// 2. 查询数据 (Preload User)
	// SELECT * FROM articles LIMIT 10 OFFSET 0;
	// SELECT * FROM users WHERE id IN (1, 2, 3...);
	err := r.db.Preload("User").
		Offset(offset).
		Limit(limit).
		Order("created_at desc").
		Find(&articles).Error

	return articles, total, err
}
```

## 2. 事务处理 (Transaction)

假设我们的业务逻辑是：用户发布文章后，积分 +10。这两个操作必须同时成功或同时失败。

### 2.1 在 Service 层使用事务

GORM 的 `Transaction` 方法非常方便。

修改 `internal/service/article_service.go`:

```go
package service

import (
	"go-blog-api/internal/model"
	"go-blog-api/internal/repository"
	"go-blog-api/pkg/db"

	"gorm.io/gorm"
)

type ArticleService struct {
	articleRepo *repository.ArticleRepository
}

// CreateArticle 发布文章 (事务演示)
func (s *ArticleService) CreateArticle(userID uint, title, content string) error {
	return db.DB.Transaction(func(tx *gorm.DB) error {
		// 注意：在事务中，必须使用 tx 而不是 db.DB
		
		// 1. 创建文章
		article := model.Article{
			Title:   title,
			Content: content,
			UserID:  userID,
		}
		if err := tx.Create(&article).Error; err != nil {
			return err // 返回错误，自动回滚
		}

		// 2. 增加用户积分 (假设 User 表有个 Score 字段)
		// UPDATE users SET score = score + 10 WHERE id = ?
		if err := tx.Model(&model.User{}).Where("id = ?", userID).
			UpdateColumn("score", gorm.Expr("score + ?", 10)).Error; err != nil {
			return err // 返回错误，自动回滚
		}

		return nil // 返回 nil，自动提交
	})
}
```

## 3. 分页设计

前端通常需要两个参数：`page` (页码) 和 `page_size` (每页数量)。后端需要转换为数据库的 `offset` 和 `limit`。

### 3.1 封装分页请求

在 `pkg/util/pagination.go` 中：

```go
package util

import (
	"strconv"

	"github.com/gin-gonic/gin"
)

func GetPage(c *gin.Context) (int, int) {
	pageStr := c.Query("page")
	sizeStr := c.Query("page_size")

	page, _ := strconv.Atoi(pageStr)
	if page <= 0 {
		page = 1
	}

	size, _ := strconv.Atoi(sizeStr)
	switch {
	case size > 100:
		size = 100
	case size <= 0:
		size = 10
	}

	offset := (page - 1) * size
	return offset, size
}
```

### 3.2 Controller 实现

在 `internal/api/v1/article.go` 中：

```go
func (ctrl *ArticleController) List(c *gin.Context) {
	offset, limit := util.GetPage(c)

	articles, total, err := ctrl.articleService.List(offset, limit)
	if err != nil {
		util.Error(c, http.StatusInternalServerError, 500, err.Error())
		return
	}

	util.Success(c, gin.H{
		"list":  articles,
		"total": total,
		"page":  c.Query("page"),
		"size":  limit,
	})
}
```

## 4. 验证

1.  **发布文章**：调用接口，观察数据库，文章创建成功，且用户积分增加。
2.  **列表查询**：调用 `/api/v1/articles?page=1&page_size=10`。
    -   观察返回的 JSON，`user` 字段应该包含作者信息。
    -   查看控制台 SQL 日志，确认是否只执行了两条 SQL（Preload 生效）。

## 5. 总结

本章我们完成了：
1.  **解决 N+1**：使用 `Preload` 优雅地加载关联数据。
2.  **事务控制**：使用 `db.Transaction` 保证了数据的一致性。
3.  **分页实现**：封装了通用的分页逻辑。

**下一章预告**：
随着文章越来越多，数据库查询会变慢。下一章我们将引入 **Redis**，实现**缓存策略**（Cache-Aside Pattern），并探讨在高并发下如何处理**缓存穿透**和**缓存雪崩**。
