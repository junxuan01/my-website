---
title: "实战二：支付回调与全链路联调"
description: "模拟第三方支付网关，从创建支付单到回调 Webhook，讲解幂等更新订单状态与前端轮询/通知配合，完成电商交易闭环的最后一环。"
date: "2025-12-13"
seriesOrder: 22
---

# 22. 实战二：支付回调与全链路联调

> 这一篇，我们要把整个电商交易闭环补完：从下单到支付，再到支付结果回调与订单状态更新，并和前端联调贯通。

目前为止，你已经拥有：

- 商品建模（SPU/SKU/属性/分类）；
- 商品列表与详情（含 Redis 缓存）；
- 购物车（Redis Hash）；
- 订单创建与状态机；
- 高并发库存扣减 + RabbitMQ 削峰机制。

还缺的最后一块拼图就是：**支付与回调**。

真实环境中你会接入支付宝、微信支付等三方网关，但出于学习目的，我们会：

1. 设计一个“模拟支付网关”的简单协议；
2. 实现支付创建接口（生成支付 URL 或二维码链接）；
3. 实现支付网关的回调 Webhook：重点讲幂等与安全校验；
4. 展示前端如何从下单 → 跳转支付页 → 等待回调 → 展示结果；
5. 做一个整体链路的串联回顾。

---

## 1. 支付流程总览（简化版）

我们设计一个简化版的支付流程：

1. 用户在订单详情页点击“去支付”；
2. 前端调用：`POST /api/pay/create`，携带 `order_id`；
3. 后端创建一条“支付记录”，返回一个模拟支付 URL：
   - 例如：`https://pay.example.com/mockpay?pay_id=xxx`；
4. 前端打开这个 URL（新窗口或内嵌 Iframe）；
5. 用户在“模拟支付页面”点击“支付成功”；
6. 支付服务调用我们的回调接口：`POST /api/pay/callback`，携带：
   - `pay_id` / `order_id` / `status` / `sign` 等；
7. 后端校验签名 → 幂等更新订单状态为“已支付”；
8. 前端轮询订单状态或接收 WebSocket 通知，展示支付结果。

> 在真实环境中，第 3 步和第 5 步由第三方支付平台（支付宝/微信）完成，我们这里只是自己搭了一个“小号支付网关”。

---

## 2. 支付记录表设计

既然要模拟一个第三方支付网关，我们需要一张“支付记录表”，记录每一次支付尝试：

```sql
CREATE TABLE `payments` (
  `id`            BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '支付记录ID',
  `order_id`      BIGINT UNSIGNED NOT NULL COMMENT '订单ID',
  `user_id`       BIGINT UNSIGNED NOT NULL COMMENT '用户ID',
  `amount`        DECIMAL(10,2)   NOT NULL DEFAULT 0 COMMENT '支付金额',
  `status`        TINYINT         NOT NULL DEFAULT 0 COMMENT '支付状态：0待支付 1成功 2失败',
  `pay_channel`   TINYINT         NOT NULL DEFAULT 0 COMMENT '渠道: 1模拟支付宝 2模拟微信',
  `pay_sn`        VARCHAR(64)     NOT NULL COMMENT '第三方支付平台交易号（这里模拟）',
  `created_at`    DATETIME        NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at`    DATETIME        NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_order` (`order_id`),
  KEY `idx_user` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='支付记录表';
```

在 Go 中对应模型：

```go
// internal/model/payment.go

package model

import "time"

type PaymentStatus int8

const (
    PaymentStatusPending PaymentStatus = iota // 0 待支付
    PaymentStatusSuccess                      // 1 成功
    PaymentStatusFailed                       // 2 失败
)

type Payment struct {
    ID         uint64        `gorm:"primaryKey;autoIncrement" json:"id"`
    OrderID    uint64        `gorm:"not null;index" json:"order_id"`
    UserID     uint64        `gorm:"not null;index" json:"user_id"`
    Amount     float64       `gorm:"type:decimal(10,2);not null;default:0" json:"amount"`
    Status     PaymentStatus `gorm:"not null;default:0" json:"status"`
    PayChannel int8          `gorm:"not null;default:0" json:"pay_channel"`
    PaySN      string        `gorm:"size:64;not null" json:"pay_sn"`
    CreatedAt  time.Time     `json:"created_at"`
    UpdatedAt  time.Time     `json:"updated_at"`
}
```

---

## 3. 创建支付：`POST /api/pay/create`

### 3.1 接口行为

- 输入：`order_id`、`pay_channel`（例如 1=模拟支付宝）；
- 校验：
  - 订单存在且属于当前用户；
  - 订单状态为“待支付”；
- 创建一条 `payments` 记录（状态 Pending）；
- 返回一个“模拟支付 URL”：
  - 例如：`https://your-backend.com/mockpay?pay_id=xxx`。

### 3.2 Service 实现

```go
// internal/service/payment_service.go

package service

import (
    "context"
    "fmt"

    "gorm.io/gorm"

    "yourapp/internal/model"
)

type PaymentService struct {
    db *gorm.DB
}

func NewPaymentService(db *gorm.DB) *PaymentService {
    return &PaymentService{db: db}
}

type CreatePaymentRequest struct {
    UserID     uint64 `json:"-"`
    OrderID    uint64 `json:"order_id"`
    PayChannel int8   `json:"pay_channel"`
}

type CreatePaymentResponse struct {
    PayID   uint64 `json:"pay_id"`
    PayURL  string `json:"pay_url"`
}

func (s *PaymentService) CreatePayment(ctx context.Context, req CreatePaymentRequest) (*CreatePaymentResponse, error) {
    var order model.Order
    if err := s.db.WithContext(ctx).
        Where("id = ? AND user_id = ?", req.OrderID, req.UserID).
        First(&order).Error; err != nil {
        return nil, err
    }

    if order.Status != model.OrderStatusPendingPay {
        return nil, fmt.Errorf("order status invalid")
    }

    pay := model.Payment{
        OrderID:    order.ID,
        UserID:     order.UserID,
        Amount:     order.PayAmount,
        Status:     model.PaymentStatusPending,
        PayChannel: req.PayChannel,
        PaySN:      fmt.Sprintf("mock-%d", order.ID),
    }

    if err := s.db.WithContext(ctx).Create(&pay).Error; err != nil {
        return nil, err
    }

    // 生成一个模拟支付页面 URL
    payURL := fmt.Sprintf("https://your-domain.com/mockpay?pay_id=%d", pay.ID)

    return &CreatePaymentResponse{
        PayID:  pay.ID,
        PayURL: payURL,
    }, nil
}
```

### 3.3 Gin Handler

```go
// internal/handler/payment.go

package handler

import (
    "net/http"

    "github.com/gin-gonic/gin"

    "yourapp/internal/service"
)

type CreatePaymentHTTPReq struct {
    OrderID    uint64 `json:"order_id" binding:"required"`
    PayChannel int8   `json:"pay_channel" binding:"required"` // 1 mock alipay 2 mock wechat
}

func CreatePaymentHandler(paySvc *service.PaymentService) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID, ok := getUserIDFromContext(c)
        if !ok || userID == 0 {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
            return
        }

        var req CreatePaymentHTTPReq
        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        resp, err := paySvc.CreatePayment(c.Request.Context(), service.CreatePaymentRequest{
            UserID:     userID,
            OrderID:    req.OrderID,
            PayChannel: req.PayChannel,
        })
        if err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        c.JSON(http.StatusOK, resp)
    }
}
```

前端此时只要拿到 `pay_url`，就可以：

- 在新窗口 `window.open(pay_url)`；
- 或在 Iframe 中加载模拟支付页。

---

## 4. 模拟支付页面与回调 Webhook

为了完整演示，我们在同一个后端里写一个“假的支付页”和一个“回调接口”。

### 4.1 模拟支付页面（前后端分离项目可另起 Next.js 路由）

假设你在 Next.js 里新增一个简单页面：`/mockpay`：

```tsx
// app/mockpay/page.tsx (简单示意)

'use client';

import { useSearchParams } from 'next/navigation';

export default function MockPayPage() {
  const params = useSearchParams();
  const payId = params.get('pay_id');

  async function handlePay() {
    await fetch('/api/pay/mock-callback', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ pay_id: Number(payId), status: 'SUCCESS' }),
    });
    alert('支付成功，您可以回到订单页查看状态。');
  }

  return (
    <main className="flex min-h-screen flex-col items-center justify-center gap-4">
      <h1 className="text-2xl font-bold">模拟支付页面</h1>
      <p>当前支付单号：{payId}</p>
      <button
        className="rounded bg-blue-600 px-4 py-2 text-white"
        onClick={handlePay}
      >
        模拟支付成功
      </button>
    </main>
  );
}
```

在真实环境中，这个页面应该是第三方支付平台的页面，这里我们自建一个方便调试。

### 4.2 支付回调 Webhook：幂等与安全

回调接口：`POST /api/pay/callback`。

实际第三方支付平台会带上：

- `pay_sn`（第三方交易号）；
- `order_sn`（我们传给它的商户订单号）；
- `status`（成功/失败）；
- `sign`（签名，用于验证请求未被篡改）。

我们为简化，假设只校验一个简单的“伪签名逻辑”（生产中必须使用 HMAC/RSA 等安全方案）：

```go
// internal/service/payment_callback.go

package service

import (
    "context"
    "fmt"
    "time"

    "gorm.io/gorm"

    "yourapp/internal/model"
)

type PaymentCallbackRequest struct {
    PayID  uint64 `json:"pay_id"`
    Status string `json:"status"` // SUCCESS / FAILED
    Sign   string `json:"sign"`   // 简化: 假设是 pay_id + secret 的 md5
}

func (s *PaymentService) HandleCallback(ctx context.Context, req PaymentCallbackRequest) error {
    // TODO: 校验 Sign（此处略）

    return s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        var pay model.Payment
        if err := tx.Where("id = ?", req.PayID).First(&pay).Error; err != nil {
            return err
        }

        // 幂等: 如果已经是成功或失败，直接返回
        if pay.Status == model.PaymentStatusSuccess || pay.Status == model.PaymentStatusFailed {
            return nil
        }

        var newStatus model.PaymentStatus
        var newOrderStatus model.OrderStatus

        switch req.Status {
        case "SUCCESS":
            newStatus = model.PaymentStatusSuccess
            newOrderStatus = model.OrderStatusPaid
        case "FAILED":
            newStatus = model.PaymentStatusFailed
            // 这里可以考虑是否要把订单标记为取消，暂时不改
        default:
            return fmt.Errorf("unknown callback status")
        }

        if err := tx.Model(&model.Payment{}).
            Where("id = ? AND status = ?", pay.ID, model.PaymentStatusPending).
            Updates(map[string]any{"status": newStatus}).Error; err != nil {
            return err
        }

        if newStatus == model.PaymentStatusSuccess {
            // 更新订单状态
            var order model.Order
            if err := tx.Where("id = ?", pay.OrderID).First(&order).Error; err != nil {
                return err
            }

            if order.Status != model.OrderStatusPendingPay {
                // 已经不是待支付，幂等处理
                return nil
            }

            now := time.Now()
            if err := tx.Model(&model.Order{}).
                Where("id = ? AND status = ?", order.ID, model.OrderStatusPendingPay).
                Updates(map[string]any{
                    "status":   model.OrderStatusPaid,
                    "pay_time": &now,
                }).Error; err != nil {
                return err
            }
        }

        return nil
    })
}
```

对应 Gin Handler：

```go
func PaymentCallbackHandler(paySvc *service.PaymentService) gin.HandlerFunc {
    return func(c *gin.Context) {
        var req service.PaymentCallbackRequest
        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        if err := paySvc.HandleCallback(c.Request.Context(), req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        c.JSON(http.StatusOK, gin.H{"message": "ok"})
    }
}
```

> 幂等性关键点：
>
> - 回调可能被重复发送（第三方为了保证通知到达，会多次重试）；
> - 通过检查 `Payment.status` 和 `Order.status` 是否已经是目标状态，避免重复修改带来的副作用；
> - 更新语句中带上原状态 `WHERE id = ? AND status = ?` 作为乐观锁的一种形式。

---

## 5. 前端联调：从“去支付”到“看到结果”

我们用一个典型的订单详情页（Next.js 16 App Router）来串联整个流程。

### 5.1 订单详情页中“去支付”按钮

```tsx
// app/orders/[id]/page.tsx (简化示意)

'use client';

import { useRouter, useSearchParams } from 'next/navigation';
import { useState } from 'react';

async function createPayment(orderId: number) {
  const res = await fetch('/api/pay/create', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ order_id: orderId, pay_channel: 1 }),
    credentials: 'include',
  });
  if (!res.ok) throw new Error('创建支付失败');
  return res.json() as Promise<{ pay_id: number; pay_url: string }>;
}

export default function OrderDetailPage({ params }: { params: { id: string } }) {
  const orderId = Number(params.id);
  const [paying, setPaying] = useState(false);

  async function handlePay() {
    try {
      setPaying(true);
      const { pay_url } = await createPayment(orderId);
      window.open(pay_url, '_blank');
    } catch (e) {
      console.error(e);
      alert('发起支付失败');
    } finally {
      setPaying(false);
    }
  }

  return (
    <main className="container mx-auto py-8">
      {/* ...订单信息展示... */}
      <button
        disabled={paying}
        onClick={handlePay}
        className="rounded bg-green-600 px-4 py-2 text-white"
      >
        {paying ? '正在跳转支付...' : '去支付'}
      </button>
    </main>
  );
}
```

### 5.2 支付结果轮询

回调到达后，订单状态会被改为 `PAID`。前端可以在订单详情页：

- 定时轮询 `/api/orders/:id`，检查 `status` 字段；
- 如果检测到从 `PENDING_PAY` 变为 `PAID`，显示“支付成功”。

简单轮询逻辑示意：

```tsx
import { useEffect, useState } from 'react';

function useOrderStatus(orderId: number, initialStatus: string) {
  const [status, setStatus] = useState(initialStatus);

  useEffect(() => {
    if (status !== 'PENDING_PAY') return;

    const timer = setInterval(async () => {
      const res = await fetch(`/api/orders/${orderId}`, { credentials: 'include' });
      if (!res.ok) return;
      const data = await res.json();
      setStatus(data.status);
    }, 3000);

    return () => clearInterval(timer);
  }, [orderId, status]);

  return status;
}
```

> 生产环境中，你可以用 WebSocket 代替轮询，但轮询对初学者更直观且容易实现。

---

## 6. 安全性与健壮性补充

这一节简单点出在真实生产环境中你需要注意的点：

1. **回调签名验证**：
   - 真实的支付平台会使用 HMAC-SHA256 或 RSA 签名；
   - 你需要用平台提供的公钥/密钥来验证回调请求未被篡改。

2. **幂等性**：
   - 回调接口可能被重复调用；
   - 通过检查当前状态是否已经是“已支付”，以及通过`WHERE id = ? AND status = ?`进行条件更新，防止重复处理。

3. **日志与审计**：
   - 记录每一次回调请求的原始报文；
   - 一旦出现账务对不上，可以快速排查。

4. **超时与退款**：
   - 未在规定时间内完成支付的订单，需要定时任务将其关闭；
   - 退款流程相对复杂，这里不展开，你可以在后续拓展中尝试设计一个“退款申请”流程。

---

## 7. 全链路回顾：从商品到支付

到这里，一个简化但架构完整的 B2C 电商后端已经成型：

1. **商品与库存**：
   - 用 SPU/SKU/属性/分类建模；
   - 用 MySQL + GORM 存储基础信息；
   - 用 Redis 维护热点数据和库存信息。

2. **查询与展示**：
   - 商品列表与详情支持复杂查询条件；
   - 使用 Redis Cache-Aside 模式缓存详情，提升读性能；
   - Next.js 16 通过 SSR/SSG 获取数据，兼顾 SEO 与性能。

3. **购物车**：
   - 使用 Redis Hash 存储购物车，支持未登录/登录态合并；
   - 前端 Zustand 与后端购物车 API 同步状态。

4. **订单与交易**：
   - 订单主表 + 明细表，配合 Snowflake 分布式 ID；
   - 订单状态机与合法流转规则；
   - 使用事务保证创建订单的一致性。

5. **高并发与削峰**：
   - Redis + Lua 实现原子库存预扣减；
   - RabbitMQ 队列将订单创建异步化，削峰填谷，保护数据库。

6. **支付与回调**：
   - 支付记录表与支付创建接口；
   - 模拟支付网关 + Webhook 回调；
   - 幂等更新订单状态，并与前端轮询/通知配合。

---

## 8. 下一步可以做什么？

如果你想继续把这个项目打磨得更接近生产实践，可以考虑：

- **引入网关与统一鉴权**：
  - 用 API Gateway 或自研网关做统一的认证、限流与日志统计。
- **微服务拆分**：
  - 将商品、订单、库存、支付拆成多个服务，通过 gRPC 或 HTTP 通信；
- **观测性建设**：
  - 加入 Prometheus/Grafana，监控 QPS、错误率、RT、库存扣减失败率等指标；
- **自动化测试与 CI/CD**：
  - 为关键链路编写单元测试和集成测试；
  - 在 GitHub Actions 中增加更多检查步骤（lint、测试覆盖率、e2e 测试）。

但即便只停留在当前阶段，你已经拥有了：

- 一个完整的、从 0 开始的 Go Web 电商后端蓝本；
- 足够多可以和前端经验类比的知识（接口设计、状态机、缓存与消息队列）。

如果你愿意，我们后续还可以围绕这个项目继续拓展：

- 添加“优惠券系统”、“积分系统”、“推荐系统”；
- 或开启“实战项目三：即时聊天应用”，专注在 WebSocket、消息存储与在线状态管理。