---
title: "实战二：高并发库存扣减与 RabbitMQ 削峰填谷"
description: "面向秒杀与大促场景，结合 Redis + Lua 实现库存原子预扣减，并使用 RabbitMQ 将下单流程异步化，构建一条防止超卖且能有效削峰填谷的高并发下单链路。"
date: "2025-12-13"
seriesOrder: 21
---

# 21. 实战二：高并发库存扣减与 RabbitMQ 削峰填谷

> 这一篇我们专门解决一个核心问题：当很多人同时下单时，如何防止“超卖”和数据库被打垮？

如果说前几篇是在搭“业务骨架”，这一篇就是在给你的电商系统装上**防爆护甲**：

- 正常流量下，MySQL + GORM 足够；
- 秒杀、大促场景下，如果再沿用“下单直接 UPDATE 库存”的方式，很容易：
  - 发生**超卖**（库存被扣成负数）
  - 数据库被**瞬时流量压垮**，整个站点宕机。

这一章我们会分几步升级你的系统：

1. 回顾传统的库存扣减方式以及它们的问题；
2. 使用 Redis + Lua 实现**原子扣减库存**；
3. 使用 RabbitMQ 将下单逻辑“异步化”，实现**削峰填谷**；
4. 串联起“请求 -> Redis 预扣减库存 -> MQ 异步下单 -> MySQL 落库”的完整链路。

---

## 1. 传统库存扣减方式及问题

### 1.1 简单粗暴版：直接 UPDATE

很多教程是这么写的：

```sql
UPDATE product_skus
SET stock = stock - ?
WHERE id = ? AND stock >= ?;
```

配合 Go：

```go
res := db.Exec("UPDATE product_skus SET stock = stock - ? WHERE id = ? AND stock >= ?", qty, skuID, qty)
rows, _ := res.RowsAffected()
if rows == 0 {
    // 扣减失败，库存不足
}
```

这种做法在**中小流量场景**其实是可行的，但在高并发下容易遇到：

- 数据库成为“串行化瓶颈”：所有请求都在抢这几行库存记录的行锁；
- QPS 上不去，连接数堆积，拖垮整个实例。

### 1.2 仅靠数据库锁并不够

你可能会想到：

- 用事务 + `SELECT ... FOR UPDATE`；
- 或者用乐观锁版本号字段 `version`。

这些确实能在**数据库层**保证不超卖，但无法解决：

- 短时间内数十万请求同时打到同一张表的**承载能力问题**；
- 数据库本身仍是“第一道网关”，容易被洪峰压垮。

所以主流做法是：

- 把**库存扣减的第一道防线移动到 Redis**；
- 再通过消息队列将真正的“写订单 + 扣 DB 库存”异步化。

---

## 2. 设计 Redis 中的库存数据

### 2.1 Key 设计

我们可以为每个 SKU 维护一个 Redis Key：

```text
stock:sku:{skuID} -> 整数，表示当前可售库存
```

初始化时：

- 从数据库的 `product_skus.stock` 同步过来：
- 例如：

```shell
SET stock:sku:1001 100
SET stock:sku:1002 50
```

### 2.2 Redis 扣减的基本思路

在下单入口时，不再直接访问 MySQL，而是：

1. 对应 `skuID` 先做 Redis 扣减：`DECRBY`；
2. 如果结果 < 0，说明库存不足，需要**回滚**并提示抢光了；
3. 如果结果 >= 0，则认为预扣减成功，后续再异步落库。

但这样写会有一个短暂的“负数窗口”，所以更安全的做法是使用 **Lua 脚本** 保证原子检查与扣减。

---

## 3. 使用 Lua 脚本实现原子性库存扣减

### 3.1 Lua 脚本示例

```lua
-- KEYS[1] = stock key, ARGV[1] = 扣减数量
local stock = tonumber(redis.call('GET', KEYS[1]) or "0")
local qty = tonumber(ARGV[1])

if stock <= 0 or stock < qty then
    return -1
end

stock = stock - qty
redis.call('SET', KEYS[1], stock)
return stock
```

这个脚本保证了：

- 在 Redis 单线程执行模型下，`GET` + 判断 + `SET` 是原子执行；
- `stock < qty` 时直接返回 `-1`，表示库存不足；
- 成功时返回剩余库存。

### 3.2 在 Go 中调用 Lua 脚本

```go
// internal/repository/stock_repository.go

package repository

import (
    "context"
    "fmt"

    "github.com/redis/go-redis/v9"
)

var luaDecrStock = redis.NewScript(`
local stock = tonumber(redis.call('GET', KEYS[1]) or "0")
local qty = tonumber(ARGV[1])

if stock <= 0 or stock < qty then
    return -1
end

stock = stock - qty
redis.call('SET', KEYS[1], stock)
return stock
`)

type StockRepository struct {
    rdb *redis.Client
}

func NewStockRepository(rdb *redis.Client) *StockRepository {
    return &StockRepository{rdb: rdb}
}

func (r *StockRepository) stockKey(skuID uint64) string {
    return fmt.Sprintf("stock:sku:%d", skuID)
}

// TryDeductStock 预扣减库存，返回是否成功
func (r *StockRepository) TryDeductStock(ctx context.Context, skuID uint64, qty int) (bool, error) {
    key := r.stockKey(skuID)
    res, err := luaDecrStock.Run(ctx, r.rdb, []string{key}, qty).Int()
    if err != nil {
        return false, err
    }
    if res < 0 {
        return false, nil
    }
    return true, nil
}
```

现在，在高并发场景下，所有“抢购请求”会先集中到 Redis 的 Lua 脚本上，而不是 MySQL。

---

## 4. RabbitMQ：为什么要“削峰填谷”？

假设一个极端场景：

- 秒杀开始的 1 秒内，来了 10 万个请求；
- 即使 Redis 可以轻松扛住这些预扣减，
- 但如果每个请求都同步往 MySQL 写订单、扣库存，MySQL 依旧会被压垮。

解决思路：

- 前端请求到达后：
  - 先用 Redis 预扣减库存；
  - 预扣减成功后，把“下单任务”塞进 RabbitMQ 的队列；
  - 立即返回“排队中/下单成功（待支付）”等结果给前端；
- 后端有一个或多个“订单消费者”进程：
  - 从 MQ 里按一定速率消费消息；
  - 在消费者中执行真实的 “写订单 + MySQL 扣减库存” 操作；
  - 这样可以把高峰流量“拉长”，保护数据库。

这就是**削峰填谷（throttling & smoothing）**：

- 峰值请求压力被 Redis 扛；
- 数据库只看到一个“平滑”的下单节奏。

---

## 5. RabbitMQ 模型设计

### 5.1 队列与交换机

我们可以使用一个简单直连交换机：

- 交换机：`order.exchange`
- 队列：`order.create.queue`
- Routing Key：`order.create`

消息体可以是一个 JSON：

```json
{
  "user_id": 123,
  "sku_id": 1001,
  "quantity": 1,
  "client_order_no": "front-uuid-xxx"  // 可选，前端生成的请求ID
}
```

### 5.2 Go 中的生产者（Publisher）

以 `github.com/rabbitmq/amqp091-go` 为例：

```go
// internal/mq/order_publisher.go

package mq

import (
    "context"
    "encoding/json"

    amqp "github.com/rabbitmq/amqp091-go"
)

type OrderCreateMessage struct {
    UserID  uint64 `json:"user_id"`
    SkuID   uint64 `json:"sku_id"`
    Qty     int    `json:"quantity"`
}

type OrderPublisher struct {
    ch        *amqp.Channel
    exchange  string
    routingKey string
}

func NewOrderPublisher(ch *amqp.Channel, exchange, routingKey string) *OrderPublisher {
    return &OrderPublisher{ch: ch, exchange: exchange, routingKey: routingKey}
}

func (p *OrderPublisher) PublishOrderCreate(ctx context.Context, msg OrderCreateMessage) error {
    body, err := json.Marshal(msg)
    if err != nil {
        return err
    }

    return p.ch.PublishWithContext(ctx,
        p.exchange,  // exchange
        p.routingKey, // routing key
        false,       // mandatory
        false,       // immediate
        amqp.Publishing{
            ContentType: "application/json",
            Body:        body,
        },
    )
}
```

---

## 6. 下单入口：Redis 预扣减 + MQ 投递

在高并发秒杀场景下，我们会有一个专门的“秒杀下单接口”：

- `POST /api/seckill/orders`

流程：

1. 校验用户登录态；
2. 使用 Redis Lua 预扣减库存；
3. 成功则往 RabbitMQ 投递一个订单创建消息；
4. 立即给用户返回“排队中/下单请求已受理”；

示例代码：

```go
// internal/service/seckill_service.go

package service

import (
    "context"
    "fmt"

    "yourapp/internal/mq"
    "yourapp/internal/repository"
)

type SeckillService struct {
    stockRepo   *repository.StockRepository
    orderPub    *mq.OrderPublisher
}

func NewSeckillService(stockRepo *repository.StockRepository, orderPub *mq.OrderPublisher) *SeckillService {
    return &SeckillService{stockRepo: stockRepo, orderPub: orderPub}
}

func (s *SeckillService) SeckillOrder(ctx context.Context, userID, skuID uint64, qty int) error {
    // 1. Redis 预扣减
    ok, err := s.stockRepo.TryDeductStock(ctx, skuID, qty)
    if err != nil {
        return err
    }
    if !ok {
        return fmt.Errorf("stock not enough")
    }

    // 2. 投递 MQ 消息
    msg := mq.OrderCreateMessage{
        UserID: userID,
        SkuID:  skuID,
        Qty:    qty,
    }

    if err := s.orderPub.PublishOrderCreate(ctx, msg); err != nil {
        // MQ 发送失败，理论上要考虑补偿
        // 这里可以考虑把预扣减的库存加回去，简化起见先忽略
        return err
    }

    return nil
}
```

对应 Gin Handler：

```go
func SeckillOrderHandler(svc *service.SeckillService) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID, ok := getUserIDFromContext(c)
        if !ok || userID == 0 {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
            return
        }

        var req struct {
            SkuID uint64 `json:"sku_id" binding:"required"`
            Qty   int    `json:"quantity" binding:"required,min=1"`
        }
        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        if err := svc.SeckillOrder(c.Request.Context(), userID, req.SkuID, req.Qty); err != nil {
            if err.Error() == "stock not enough" {
                c.JSON(http.StatusBadRequest, gin.H{"error": "sold out"})
                return
            }
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }

        c.JSON(http.StatusOK, gin.H{"message": "queued"})
    }
}
```

前端此时可以直接给出“排队中/抢购请求已受理”的提示，而不必等待订单真正落库。

---

## 7. RabbitMQ 消费者：异步创建订单 + 扣减 MySQL 库存

消费者负责：

1. 从队列中取出消息；
2. 在数据库事务中：
   - 再次校验库存（避免 Redis 与 DB 长期不一致）；
   - 创建订单主表、明细表；
   - 扣减 MySQL 中的 `product_skus.stock`；
3. 将库存不足或其他异常订单进行日志记录及补偿处理。

示意代码：

```go
// internal/mq/order_consumer.go

package mq

import (
    "context"
    "encoding/json"
    "log"

    amqp "github.com/rabbitmq/amqp091-go"
    "gorm.io/gorm"

    "yourapp/internal/model"
    "yourapp/internal/pkg/snowflake"
)

type OrderConsumer struct {
    ch *amqp.Channel
    db *gorm.DB
}

func NewOrderConsumer(ch *amqp.Channel, db *gorm.DB) *OrderConsumer {
    return &OrderConsumer{ch: ch, db: db}
}

func (csm *OrderConsumer) StartConsume(queue string) error {
    msgs, err := csm.ch.Consume(
        queue,
        "order-consumer",
        false, // auto-ack
        false,
        false,
        false,
        nil,
    )
    if err != nil {
        return err
    }

    go func() {
        for msg := range msgs {
            if err := csm.handleMessage(msg); err != nil {
                log.Printf("handle order message error: %v", err)
                // 可以根据情况决定是否 Nack 重回队列 / 丢弃 / 进入死信队列
                _ = msg.Nack(false, false)
                continue
            }
            _ = msg.Ack(false)
        }
    }()

    return nil
}

func (csm *OrderConsumer) handleMessage(msg amqp.Delivery) error {
    var m OrderCreateMessage
    if err := json.Unmarshal(msg.Body, &m); err != nil {
        return err
    }

    ctx := context.Background()

    return csm.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error {
        var sku model.ProductSku
        if err := tx.Clauses(clause.Locking{Strength: "UPDATE"}).
            Where("id = ?", m.SkuID).First(&sku).Error; err != nil {
            return err
        }

        if sku.Stock < m.Qty {
            return fmt.Errorf("db stock not enough, sku=%d", m.SkuID)
        }

        sku.Stock -= m.Qty
        if err := tx.Model(&model.ProductSku{}).
            Where("id = ?", m.SkuID).
            Update("stock", sku.Stock).Error; err != nil {
            return err
        }

        orderID := uint64(snowflake.NextOrderID())
        order := model.Order{
            ID:          orderID,
            OrderSN:     fmt.Sprintf("%d", orderID),
            UserID:      m.UserID,
            Status:      model.OrderStatusPendingPay,
            TotalAmount: sku.Price * float64(m.Qty),
            PayAmount:   sku.Price * float64(m.Qty),
        }
        if err := tx.Create(&order).Error; err != nil {
            return err
        }

        item := model.OrderItem{
            OrderID:   order.ID,
            UserID:    m.UserID,
            ProductID: sku.ProductID,
            SkuID:     sku.ID,
            Title:     "",        // 应从SKU/SPU快照填充
            Image:     sku.Image,
            Price:     sku.Price,
            Quantity:  m.Qty,
            Attrs:     sku.Attrs,
        }

        if err := tx.Create(&item).Error; err != nil {
            return err
        }

        return nil
    })
}
```

> 注意：上面的代码略去了部分错误处理与补偿逻辑，重点在于演示“在消费者中进行真实的 DB 扣减 + 订单落库”。

---

## 8. 前端视角：如何与“排队中”流程配合？

从前端的体验来看，高并发下的下单流程一般是：

1. 用户点击“立即抢购”；
2. 前端发送请求到 `/api/seckill/orders`；
3. 后端立即返回 `{ message: "queued" }`；
4. 前端轮询或通过 WebSocket 查询订单创建结果：
   - 比如轮询 `/api/orders/seckill/status?sku_id=xxx`；
   - 返回结果可能是 `PENDING`, `SUCCESS`, `FAILED`；

简单示例：

```ts
async function seckillOrder(skuId: number, quantity: number) {
  const res = await fetch('/api/seckill/orders', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ sku_id: skuId, quantity }),
    credentials: 'include',
  });

  if (!res.ok) {
    throw new Error('抢购失败');
  }

  // queued
}
```

轮询订单结果可以交给另一个接口实现，这里不展开细节，你可以根据自己的业务设计一个“秒杀结果查询” API。

---

## 9. 小结：Redis + MQ 的组合拳

这一篇，我们完成了从“单机 MySQL 扣库存”到“Redis + RabbitMQ 高并发架构”的升级：

1. **Redis 层**：
   - 使用 `stock:sku:{id}` Key 保存可售库存；
   - 使用 Lua 脚本实现原子性库存预扣减；
2. **应用层**：
   - 秒杀 API 不再直接操作数据库，而是：
     - 首先通过 Redis 预扣减库存；
     - 成功后往 RabbitMQ 投递一个下单消息；
3. **MQ 层**：
   - 使用 RabbitMQ 的队列将订单创建请求排队；
   - 消费者进程按可控速率消费消息，在事务中进行 MySQL 扣减与订单落库；
4. **整体效果**：
   - 即使瞬间来了 10 万请求，数据库也只需要跟着 MQ 消费速率处理，比如每秒几千条；
   - 有效避免了库存超卖和数据库被打垮的风险。

---

## 10. 下一篇预告：支付回调与全链路联调

在下一篇《实战二：支付回调与全链路联调》中，我们将：

- 模拟一个支付网关（例如“假支付宝/假微信支付”）；
- 处理支付结果的回调 Webhook，实现**幂等**的订单状态更新；
- 从“下单 → 支付 → 支付回调 → 订单完成”的完整链路出发，看如何设计前后端联调；
- 前端会实现一个简单的“支付结果轮询 + 倒计时”组件，让整体体验完整闭环。

到那时，你将拥有：

- 一个从商品 → 购物车 → 订单 → 库存 → 支付的完整电商后端链路；
- 并且这条链路在高并发下依旧具有较强的抗压能力。