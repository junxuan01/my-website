---
title: "事务：复杂查询、事务与分页"
description: "站在前端视角理解数据库事务、复杂查询与分页。用 GORM 实现多表关联查询、显式事务与通用分页结构，为后续真实业务打基础。"
date: "2025-12-08"
seriesOrder: 6
---

# 6. 事务：复杂查询、事务与分页

## 引言

前几章我们已经有了 `User`、`Article`、`Comment` 三张表，也能做基本的增删改查。

但你很快会发现：真正的业务需求远不止“查单表、插一行”。

- 列表页一般要展示：文章 + 作者昵称 + 评论数量；
- 点赞、下单、转账这类操作，往往要**同时改多张表**，而且要么都成功，要么都失败；
- 列表接口必须要有**分页**，否则一口气查 10 万条记录，数据库和接口都吃不消。

这一章，我们就从前端熟悉的“列表、详情、批量操作”出发，来理解后端世界中的三个关键能力：

1.  **复杂查询**：多表关联、聚合（`COUNT`）、条件拼装。
2.  **事务 (Transaction)**：保证多步数据库操作的“要么都做，要么都不做”。
3.  **分页 (Pagination)**：在接口层提供稳定的分页结构。

> 可以把这一章想象成：把你在前端写列表查询、批量操作时经常吐槽的“后端不给力”那一块，自己学会怎么设计。

## 1. 复杂查询：列表页需要什么数据？

先从一个最典型的需求开始：**文章列表页**。

假设前端期望的接口返回结构大概是这样（伪 TypeScript 类型）：

```ts
type ArticleListItem = {
  id: number
  title: string
  summary: string
  authorName: string
  commentCount: number
  createdAt: string
}

type ArticleListResponse = {
  list: ArticleListItem[]
  total: number
}
```

从后端角度看，要拿到这些字段，至少需要：

- `articles` 表：`id`、`title`、`summary`（可以取 content 前几百字）、`created_at`；
- `users` 表：作者昵称 `username`；
- `comments` 表：统计每篇文章的评论数量 `COUNT(*)`。

### 1.1 N+1 问题：一眼就能踩的坑

如果你只会最朴素的写法，很可能会这么做：

1. 先查出文章列表 `SELECT * FROM articles LIMIT 10 OFFSET 0`；
2. 遍历每一篇文章：
    - 再查一次作者 `SELECT * FROM users WHERE id = ?`；
    - 再查一次评论数 `SELECT COUNT(*) FROM comments WHERE article_id = ?`。

看起来没什么问题，但如果一页 10 条文章，就会多出 10 次查用户 + 10 次查评论，合计 **21 条 SQL**。

这就是经典的 **N+1 查询问题**：

- 1 条 SQL 查出 N 条主数据；
- 然后为每一条再发 1 条 SQL 去查关联数据，最终得到 1 + N 条甚至 1 + 2N 条 SQL。

在本地测试时你可能感觉不到，但线上一旦并发上来，这种写法会严重拖垮数据库。

### 1.2 使用 GORM 预加载解决 N+1

在 GORM 中，可以通过 `Preload` 预加载关联，尽量把数据在**一到两条 SQL** 里查完。

假设我们的模型定义中，`Article` 里已经有：

```go
type Article struct {
  BaseModel
  Title   string
  Content string

  UserID uint
  User   User `gorm:"foreignKey:UserID"`
}
``;

我们可以在 Repository 层写一个列表查询：

```go
// internal/repository/article_repo.go
type ArticleRepository struct {
  db *gorm.DB
}

func (r *ArticleRepository) ListWithUser(offset, limit int) ([]*model.Article, int64, error) {
  var articles []*model.Article
  var total int64

  // 先查总数
  if err := r.db.Model(&model.Article{}).Count(&total).Error; err != nil {
    return nil, 0, err
  }

  // 再查分页数据，并预加载作者信息
  if err := r.db.Preload("User").
    Order("created_at DESC").
    Offset(offset).
    Limit(limit).
    Find(&articles).Error; err != nil {
    return nil, 0, err
  }

  return articles, total, nil
}
```

这样，GORM 会帮我们发出类似：

1. `SELECT count(*) FROM articles;`
2. `SELECT * FROM articles ORDER BY created_at DESC LIMIT ? OFFSET ?;`
3. `SELECT * FROM users WHERE id IN (...);`

只用 3 条 SQL，就拿到了所有文章和对应的作者信息，不再是 N+1。

### 1.3 评论数的聚合查询

评论数不适合用 `Preload`，因为那会变成查出所有评论的行，然后在代码里 `len()` 统计，太浪费。

更好的方式是用 SQL 的 `GROUP BY` 聚合：

```go
type ArticleCommentCount struct {
  ArticleID    uint
  CommentCount int64
}

func (r *ArticleRepository) GetCommentCountMap(articleIDs []uint) (map[uint]int64, error) {
  var results []ArticleCommentCount

  if err := r.db.
    Table("comments").
    Select("article_id as article_id, COUNT(*) as comment_count").
    Where("article_id IN ?", articleIDs).
    Group("article_id").
    Scan(&results).Error; err != nil {
    return nil, err
  }

  m := make(map[uint]int64)
  for _, r := range results {
    m[r.ArticleID] = r.CommentCount
  }
  return m, nil
}
```

Service 层再把这些数据组装成前端需要的 `ArticleListItem` 即可。

> 这里的思路和前端很像：尽量在“数据源”那一端（数据库）做聚合、筛选，让传输到前端的数据尽量简洁。

## 2. 事务：要么全部成功，要么全部失败

接下来回到一个非常典型的后端问题：**多步操作的一致性**。

举个例子：

- 用户发布文章时，我们要：
  - 向 `articles` 表插入一条记录；
  - 向 `user_stats` 表（假设有这张表）给该用户的 `article_count` +1。

如果第一步成功、第二步失败，那么数据就不一致了：文章表里有新文章，但统计表没加 1。

这就需要**事务 (Transaction)**：

> 事务保证一组数据库操作要么全部成功提交，要么全部回滚，好像这组操作从没发生过一样。

这和前端里的“一起改多个状态，要么都改成功、要么都不生效”有点类似，只不过在数据库里，如果中间出错，不能让部分更新“残留”下来。

### 2.1 GORM 中的事务用法

在 GORM 中，有两种常见写法：

1. 手动 `Begin` / `Commit` / `Rollback`；
2. 使用 `db.Transaction(func(tx *gorm.DB) error { ... })` 封装。

推荐第二种，代码更整洁，也更不容易忘记 `Rollback`。

```go
func (s *ArticleService) CreateArticleWithStats(req *CreateArticleRequest) error {
  return s.db.Transaction(func(tx *gorm.DB) error {
    article := &model.Article{
      Title:   req.Title,
      Content: req.Content,
      UserID:  req.UserID,
    }

    if err := tx.Create(article).Error; err != nil {
      return err // 返回 error 会触发自动 Rollback
    }

    // 更新用户统计表
    if err := tx.Model(&model.UserStats{}).
      Where("user_id = ?", req.UserID).
      UpdateColumn("article_count", gorm.Expr("article_count + ?", 1)).Error; err != nil {
      return err
    }

    // 如果整个函数没有返回 error，GORM 会自动 Commit
    return nil
  })
}
```

可以这样理解这段代码：

- `Transaction` 里面的所有数据库操作会被包裹在同一个事务中；
- 任意一步返回 `error`，GORM 会帮你回滚之前所有操作；
- 整个函数返回 `nil`，才会真正 `Commit` 到数据库。

### 2.2 什么时候需要事务？

经验规则：

- 涉及到**钱、库存、计数**等强一致性数据时，几乎都要用事务；
- 同一个接口里写多张表，而且这些写入之间有强关联关系时，建议用事务；
- 读操作（`SELECT`）一般不需要事务，除非是非常特殊的一致性要求。

也不要“为了高级而高级”，所有写操作都包事务，反而会增加数据库压力。

## 3. 分页：后端要给一个统一的结构

分页是前后端都非常熟的概念，但在很多项目里，后端返回的分页结构五花八门，让前端写一堆适配代码。

站在你已经是“前后端都写”的角度，我们可以给接口统一一个分页返回结构，比如：

```json
{
  "list": [ /* 数据数组 */ ],
  "total": 120,
  "page": 1,
  "pageSize": 10
}
```

这样无论是文章列表、评论列表还是用户列表，前端都可以用同一套分页组件直接对接。

### 3.1 分页参数的约定

我们约定所有列表接口接受两个 Query 参数：

- `page`：第几页，从 1 开始；
- `pageSize`：每页多少条，一般限制一个上限，比如 50。

在 Controller 里解析：

```go
func (ctrl *ArticleController) List(c *gin.Context) {
  page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
  pageSize, _ := strconv.Atoi(c.DefaultQuery("pageSize", "10"))

  if page < 1 {
    page = 1
  }
  if pageSize <= 0 || pageSize > 50 {
    pageSize = 10
  }

  resp, err := ctrl.articleService.ListArticles(page, pageSize)
  if err != nil {
    util.Fail(c, e.ErrorDatabase, "获取文章列表失败")
    return
  }

  util.Success(c, resp)
}
```

Service 层计算 `offset` 与 `limit`：

```go
type ArticleListResponse struct {
  List     []ArticleListItem `json:"list"`
  Total    int64             `json:"total"`
  Page     int               `json:"page"`
  PageSize int               `json:"pageSize"`
}

func (s *ArticleService) ListArticles(page, pageSize int) (*ArticleListResponse, error) {
  offset := (page - 1) * pageSize

  articles, total, err := s.articleRepo.ListWithUser(offset, pageSize)
  if err != nil {
    return nil, err
  }

  // 组装评论数等信息，这里略

  // 映射到 DTO
  list := make([]ArticleListItem, 0, len(articles))
  for _, a := range articles {
    list = append(list, ArticleListItem{
      ID:           a.ID,
      Title:        a.Title,
      AuthorName:   a.User.Username,
      CommentCount: 0, // 待补充
      CreatedAt:    a.CreatedAt.Format(time.RFC3339),
    })
  }

  return &ArticleListResponse{
    List:     list,
    Total:    total,
    Page:     page,
    PageSize: pageSize,
  }, nil
}
```

从前端视角看，这个接口非常友好：拿到数据就能直接喂给分页组件，不需要再计算总页数之类的东西（当然你也可以再加一个 `totalPages` 字段）。

## 4. 运行与验证

本章的改动涉及：

- 新增或修改 `ArticleRepository` 的查询方法；
- 在 `ArticleService` 中增加列表接口和事务示例；
- 在 `ArticleController` 中增加 `/api/v1/articles` 列表路由。

你可以按以下步骤自测：

1.  本地准备一些测试数据：插入几条用户、文章、评论记录；
2.  运行服务：

    ```bash
    go run cmd/server/main.go
    ```

3.  用 curl 或 Postman 调用列表接口：

    ```bash
    curl "http://localhost:8080/api/v1/articles?page=1&pageSize=5"
    ```

4.  观察返回：
    - 是否包含 `list`、`total`、`page`、`pageSize` 四个字段；
    - 每一项是否带上作者昵称、创建时间；
    - 多插入一些评论，检查评论统计是否正常。

5.  刻意制造事务失败场景（比如在事务中某一步 `Update` 写错字段名，让它报错），验证整体是否回滚：
    - 操作前后对比数据库中几张表的数据是否保持一致。

## 5. 本章小结与练习

这一章，我们从“前端列表与批量操作”的视角，逐步落地了后端世界中非常重要的三个能力：

- **复杂查询**：
  - 利用 GORM 的 `Preload` 避免 N+1 查询问题；
  - 使用 `GROUP BY` 在数据库侧完成聚合统计。
- **事务**：
  - 使用 `db.Transaction` 将多步写操作打包，保证要么全部成功，要么全部失败；
  - 理解哪些场景必须用事务，哪些可以不必滥用。
- **分页**：
  - 设计统一的分页请求参数和返回结构；
  - 在 Service 层负责 offset/limit 的计算和 DTO 的拼装。

从这一章开始，你写的接口已经开始有“业务味道”了，而不再只是 CRUD 的练习题。

### 思考题 / 练习

1. **增加筛选条件**：
   - 为文章列表接口增加按作者、按创建时间区间筛选的功能；
   - 设计好 Query 参数的命名和含义（比如 `authorId`、`startDate`、`endDate`）。

2. **实现评论列表分页接口**：
   - 为单篇文章的评论实现 `/articles/:id/comments` 的分页接口；
   - 返回结构继续复用统一的分页结构。

3. **更多事务场景**：
   - 设计一个“转账”的伪接口：`/accounts/transfer`，需要同时扣减 A 账户余额、增加 B 账户余额；
   - 用 GORM 的事务保证这两步的一致性，并在本地写一个简单的程序不断调用，观察是否会出现不一致。

> 建议你亲手把这一章涉及的 SQL 和 GORM 代码都跑一遍，顺便打开数据库客户端看看真实的行数据。只有在“看见”数据如何变化时，事务和复杂查询这些概念才会真正变得清晰。
