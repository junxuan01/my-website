---
title: "实战一：生产环境部署与 CI/CD"
description: "实战项目的最后一公里。编写多阶段构建 Dockerfile，配置 Nginx 反向代理实现前后端同域部署。使用 GitHub Actions 搭建自动化 CI/CD 流水线。"
date: "2025-12-18"
seriesOrder: 16
---

# 16. 实战一：生产环境部署与 CI/CD

## 引言

经过前面 5 章的开发，我们的 RBAC 权限管理系统已经功能完备。
现在，我们需要把它部署到互联网上，让真实用户可以使用。

本章我们将实现一套标准的**容器化部署方案**，并搭建 **GitHub Actions** 自动化流水线，实现"代码提交即上线"。

## 1. 容器化构建

### 1.1 后端 Dockerfile

我们在第 10 章已经写过一个基础的 Dockerfile。针对本项目，我们需要确保 `configs` 目录和 `rbac_model.conf` 被正确复制。

```dockerfile
# Dockerfile.backend
FROM golang:1.25-alpine AS builder

ENV GOPROXY=https://goproxy.cn,direct
WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN go build -o server cmd/server/main.go

FROM alpine:latest
WORKDIR /app

COPY --from=builder /app/server .
COPY --from=builder /app/configs ./configs
# 别忘了复制 Casbin 模型文件
COPY --from=builder /app/configs/rbac_model.conf ./configs/

EXPOSE 8080
CMD ["./server"]
```

### 1.2 前端 Dockerfile

Next.js 的容器化稍微复杂一点，推荐使用 standalone 模式。

首先修改 `next.config.js`:
```javascript
module.exports = {
  output: 'standalone',
}
```

然后编写 `Dockerfile.frontend`:

```dockerfile
FROM node:20-alpine AS base

FROM base AS deps
WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN npm install -g pnpm && pnpm i --frozen-lockfile

FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN npm install -g pnpm && pnpm build

FROM base AS runner
WORKDIR /app
ENV NODE_ENV production

COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static

EXPOSE 3000
CMD ["node", "server.js"]
```

## 2. Nginx 反向代理

为了解决跨域问题 (CORS) 并统一入口，我们通常使用 Nginx 作为网关。

-   `example.com` -> 前端 (Next.js)
-   `example.com/api` -> 后端 (Go)

创建 `nginx.conf`:

```nginx
server {
    listen 80;
    server_name example.com;

    # 前端
    location / {
        proxy_pass http://frontend:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # 后端 API
    location /api/ {
        # 去掉 /api 前缀再转发 (如果后端路由没带 /api 前缀的话)
        # rewrite ^/api/(.*) /$1 break;
        
        proxy_pass http://backend:8080;
        proxy_set_header Host $host;
    }
}
```

## 3. Docker Compose 编排

创建 `docker-compose.prod.yml`:

```yaml
version: '3.8'

services:
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
    volumes:
      - mysql_data:/var/lib/mysql

  redis:
    image: redis:7.0

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.backend
    environment:
      - CONFIG_PATH=configs/config.prod.yaml
    depends_on:
      - mysql
      - redis

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.frontend
    depends_on:
      - backend

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/conf.d/default.conf
    depends_on:
      - frontend
      - backend

volumes:
  mysql_data:
```

## 4. CI/CD 流水线 (GitHub Actions)

我们希望每次 push 到 `main` 分支时，自动构建镜像并部署。

创建 `.github/workflows/deploy.yml`:

```yaml
name: Deploy

on:
  push:
    branches: [ main ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    # 1. 登录 Docker Hub (或阿里云 ACR)
    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    # 2. 构建并推送后端镜像
    - name: Build and push Backend
      uses: docker/build-push-action@v4
      with:
        context: ./backend
        push: true
        tags: myuser/rbac-backend:latest

    # 3. 构建并推送前端镜像
    - name: Build and push Frontend
      uses: docker/build-push-action@v4
      with:
        context: ./frontend
        push: true
        tags: myuser/rbac-frontend:latest

    # 4. SSH 登录服务器并重启容器
    - name: Deploy to Server
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        script: |
          cd /data/rbac-project
          docker-compose -f docker-compose.prod.yml pull
          docker-compose -f docker-compose.prod.yml up -d
```

## 5. 总结

至此，**实战项目一：RBAC 权限管理系统** 已经全部完结！

我们从数据库设计开始，一路经历了 GORM 建模、JWT 双令牌认证、Casbin 权限控制、Next.js 前端对接，最后完成了容器化部署。

这是一个非常标准的**全栈开发流程**。掌握了这套流程，你已经具备了独立开发中型企业级应用的能力。

**下一步计划**：
在接下来的实战项目二中，我们将挑战更高并发的场景 —— **电商平台**。我们将深入研究**秒杀系统**的设计、**分布式事务**的处理以及**微服务**的拆分。敬请期待！
