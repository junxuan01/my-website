---
title: "实战一：生产环境部署与 CI/CD"
description: "实战项目的最后一公里。编写多阶段构建 Dockerfile，配置 Nginx 反向代理实现前后端同域部署。使用 GitHub Actions 搭建自动化 CI/CD 流水线。"
date: "2025-12-18"
seriesOrder: 16
---

# 16. 实战一：生产环境部署与 CI/CD

## 引言

代码写完了，测试通过了，前后端联调也没问题了。

但如果代码只能在你的电脑上跑，那还不能算"产品"。这一章，我们要把整个 RBAC 系统**部署到服务器上**，让真实用户可以访问。

> **前端同学可能会问**：
> 
> "我以前部署前端项目，`npm run build` 然后把 `dist` 目录丢到服务器就行了，后端也这么简单吗？"
> 
> 答案是：差不多，但有一些额外考虑：
> 
> - 后端需要连接数据库（MySQL）、缓存（Redis），这些服务也要部署；
> - 前端和后端如果不在同一个域名下，会有跨域问题；
> - 我们希望代码提交后自动部署，而不是每次手动 SSH 上去操作。

本章我们将解决以上所有问题。

### 本章目标

学完这一章，你将能够：

1. 理解 Docker 的基本概念（镜像、容器、Dockerfile）；
2. 为 Go 后端和 Next.js 前端编写 Dockerfile；
3. 使用 Nginx 反向代理，让前后端使用同一个域名（解决跨域）；
4. 用 Docker Compose 一键启动所有服务（App + MySQL + Redis + Nginx）；
5. 用 GitHub Actions 实现"代码提交即部署"的 CI/CD 流水线。

## 1. 容器化构建

### 1.0 前端同学的 Docker 快速入门

如果你没接触过 Docker，可以这样理解：

> Docker 就像一个**超轻量的虚拟机**，它把你的代码、运行环境、依赖库全部打包成一个"镜像"。无论在谁的电脑上，只要装了 Docker，运行这个镜像，效果都一模一样。

几个核心概念：

| 概念 | 类比 | 说明 |
|---|---|---|
| 镜像 (Image) | 安装包 / ISO 文件 | 一个只读的模板，包含运行程序所需的一切 |
| 容器 (Container) | 运行中的程序 | 从镜像启动的一个实例，可以有多个 |
| Dockerfile | 安装脚本 | 告诉 Docker 如何一步步构建镜像 |
| Docker Compose | 批量安装器 | 一次性启动多个容器（App + DB + Redis） |

为什么要用 Docker？

- **环境一致**：不会出现"在我电脑上是好的"这种问题；
- **隔离**：每个服务运行在独立容器里，互不干扰；
- **便于部署**：服务器上只需要装 Docker，然后 `docker run` 就能跑起来。

### 1.1 后端 Dockerfile

我们在第 10 章已经写过一个基础的 Dockerfile。针对本项目，我们需要确保 `configs` 目录和 `rbac_model.conf` 被正确复制。

```dockerfile
# Dockerfile.backend
FROM golang:1.25-alpine AS builder

ENV GOPROXY=https://goproxy.cn,direct
WORKDIR /app

COPY go.mod go.sum ./
RUN go mod download

COPY . .
RUN go build -o server cmd/server/main.go

FROM alpine:latest
WORKDIR /app

COPY --from=builder /app/server .
COPY --from=builder /app/configs ./configs
# 别忘了复制 Casbin 模型文件
COPY --from=builder /app/configs/rbac_model.conf ./configs/

EXPOSE 8080
CMD ["./server"]
```

### 1.2 前端 Dockerfile

Next.js 的容器化稍微复杂一点，推荐使用 standalone 模式。

首先修改 `next.config.js`:
```javascript
module.exports = {
  output: 'standalone',
}
```

然后编写 `Dockerfile.frontend`:

```dockerfile
FROM node:20-alpine AS base

FROM base AS deps
WORKDIR /app
COPY package.json pnpm-lock.yaml ./
RUN npm install -g pnpm && pnpm i --frozen-lockfile

FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN npm install -g pnpm && pnpm build

FROM base AS runner
WORKDIR /app
ENV NODE_ENV production

COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static

EXPOSE 3000
CMD ["node", "server.js"]
```

## 2. Nginx 反向代理

### 2.1 为什么需要 Nginx？

如果前端部署在 `http://example.com:3000`，后端部署在 `http://example.com:8080`，前端调用后端 API 会遇到**跨域问题 (CORS)**。

虽然可以在后端配置 CORS 头来解决，但更优雅的方式是用 **Nginx 反向代理**：

- 用户访问 `http://example.com` → Nginx 转发给前端 (3000)
- 用户访问 `http://example.com/api` → Nginx 转发给后端 (8080)

这样前后端在同一个域名下，就不存在跨域问题了。

### 2.2 Nginx 配置

创建 `nginx.conf`:

```nginx
server {
    listen 80;
    server_name example.com;

    # 前端
    location / {
        proxy_pass http://frontend:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # 后端 API
    location /api/ {
        # 去掉 /api 前缀再转发 (如果后端路由没带 /api 前缀的话)
        # rewrite ^/api/(.*) /$1 break;
        
        proxy_pass http://backend:8080;
        proxy_set_header Host $host;
    }
}
```

## 3. Docker Compose 编排

创建 `docker-compose.prod.yml`:

```yaml
version: '3.8'

services:
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
    volumes:
      - mysql_data:/var/lib/mysql

  redis:
    image: redis:7.0

  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.backend
    environment:
      - CONFIG_PATH=configs/config.prod.yaml
    depends_on:
      - mysql
      - redis

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile.frontend
    depends_on:
      - backend

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
    volumes:
      - ./nginx.conf:/etc/nginx/conf.d/default.conf
    depends_on:
      - frontend
      - backend

volumes:
  mysql_data:
```

## 4. CI/CD 流水线 (GitHub Actions)

我们希望每次 push 到 `main` 分支时，自动构建镜像并部署。

创建 `.github/workflows/deploy.yml`:

```yaml
name: Deploy

on:
  push:
    branches: [ main ]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    # 1. 登录 Docker Hub (或阿里云 ACR)
    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    # 2. 构建并推送后端镜像
    - name: Build and push Backend
      uses: docker/build-push-action@v4
      with:
        context: ./backend
        push: true
        tags: myuser/rbac-backend:latest

    # 3. 构建并推送前端镜像
    - name: Build and push Frontend
      uses: docker/build-push-action@v4
      with:
        context: ./frontend
        push: true
        tags: myuser/rbac-frontend:latest

    # 4. SSH 登录服务器并重启容器
    - name: Deploy to Server
      uses: appleboy/ssh-action@master
      with:
        host: ${{ secrets.SERVER_HOST }}
        username: ${{ secrets.SERVER_USER }}
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        script: |
          cd /data/rbac-project
          docker-compose -f docker-compose.prod.yml pull
          docker-compose -f docker-compose.prod.yml up -d
```

## 5. 本章小结与练习

至此，**实战项目一：RBAC 权限管理系统** 已经全部完结！

让我们回顾一下整个项目的旅程：

| 章节 | 主题 | 关键技术 |
|---|---|---|
| 11 | 数据库建模 | RBAC 模型、GORM 多对多、种子数据 |
| 12 | 用户认证 | JWT 双令牌、Redis 黑名单、强制下线 |
| 13 | 菜单管理 | 扁平转树形算法、多对多关联更新 |
| 14 | 权限控制 | Casbin、PERM 模型、Gin 中间件 |
| 15 | 前端对接 | Axios 拦截器、Zustand、动态菜单、按钮权限 |
| 16 | 生产部署 | Docker、Nginx、Docker Compose、GitHub Actions |

这是一个非常标准的**全栈开发流程**。掌握了这套流程，你已经具备了独立开发中型企业级应用的能力。

### 思考题 / 练习

1. **本地验证部署流程**：
   - 在本地安装 Docker Desktop；
   - 运行 `docker-compose up -d --build`；
   - 访问 `http://localhost`，验证前后端是否正常工作。

2. **优化镜像大小**：
   - 查看 `docker images` 输出的镜像大小；
   - 研究如何进一步减小镜像体积（提示：使用 `scratch` 基础镜像、静态编译）。

3. **增加健康检查**：
   - 在 `docker-compose.yml` 中为后端服务添加 `healthcheck`；
   - 确保服务真正可用后，再启动依赖它的其他服务。

4. **实现滚动更新**：
   - 目前的部署是"停机更新"—— `docker-compose down` 再 `up`；
   - 研究如何实现"滚动更新"，让用户无感知。

5. **配置 HTTPS**：
   - 使用 Let's Encrypt 申请免费证书；
   - 修改 Nginx 配置，监听 443 端口并配置 SSL 证书。

---

## 结语：从入门到架构师

恭喜你！你已经完成了《Go Web 后端架构实战》的第一个实战项目！

我们从 RBAC 概念开始，一路经历了：

- **数据库设计**：理解了多对多关系在 MySQL 中的实现
- **认证与授权**：掌握了 JWT 双令牌机制和 Casbin 权限引擎
- **前后端协作**：学会了如何设计对前端友好的 API
- **生产部署**：搭建了完整的 CI/CD 流水线

这不仅仅是一个 RBAC 系统，更是一套**可复用的企业级后端架构模板**。

**接下来的计划**：

在实战项目二中，我们将挑战更高并发的场景 —— **电商平台**。我们将深入研究：

- **秒杀系统**的设计（Redis + Lua 脚本）
- **分布式事务**的处理（TCC / Saga 模式）
- **微服务**的拆分与通信（gRPC / 服务发现）

敬请期待！

**Keep Coding, Keep Learning!**
