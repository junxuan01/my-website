---
title: "实战一：用户认证与 JWT 刷新机制"
description: "构建生产级认证体系。实现 Access Token + Refresh Token 双令牌机制，解决 JWT 无法废止的痛点。引入 Redis 黑名单实现用户登出与强制下线。"
date: "2025-12-14"
seriesOrder: 12
---

# 12. 实战一：用户认证与 JWT 刷新机制

## 引言

在第 5 章中，我们实现了一个简单的 JWT 登录功能。但在企业级应用中，简单的 JWT 存在两个严重问题：

1.  **续期问题**：Token 一旦签发，过期时间就固定了。如果设置太短（如 15 分钟），用户体验极差（频繁登录）；如果设置太长（如 7 天），一旦 Token 泄露，黑客有 7 天的时间为所欲为。
2.  **废止问题**：JWT 是无状态的。用户修改密码、管理员封禁账号、或者用户点击"退出登录"后，旧的 Token 依然有效，直到它自然过期。

> **前端同学可能会想**：
> 
> "我在前端把 localStorage 里的 token 删掉不就行了？"
> 
> 这只是"眼不见为净"。如果有人之前抄走了你的 token，他依然可以用这个 token 调接口。真正的"退出登录"必须让服务端也认为这个 token 无效。

本章我们将通过 **双令牌机制 (Access + Refresh Token)** 和 **Redis 黑名单** 来彻底解决这两个问题。

### 本章目标

学完这一章，你将能够：

1. 理解 Access Token 和 Refresh Token 的分工，以及为什么需要两个 Token；
2. 在 Go 中实现双令牌的生成和校验逻辑；
3. 使用 Redis 实现"退出登录"和"强制下线"功能；
4. 了解前端 Axios 拦截器如何配合后端实现"无感刷新"。

## 1. 双令牌机制原理

### 1.1 为什么需要两个 Token？

你可能会问："一个 Token 不够吗？为什么要搞两个？"

我们来对比一下：

| 方案 | Access Token 有效期 | 用户体验 | 安全性 |
|---|---|---|---|
| 单 Token（短期） | 15 分钟 | ❌ 差（频繁登录） | ✅ 好（泄露影响小） |
| 单 Token（长期） | 7 天 | ✅ 好（一周不用登录） | ❌ 差（泄露影响大） |
| **双 Token** | Access 1小时 + Refresh 7天 | ✅ 好（自动续期） | ✅ 好（各司其职） |

双令牌的核心思想是**分工**：

-   **Access Token**：
    -   **有效期**: 短（如 15 分钟 - 2 小时）
    -   **作用**: 访问业务接口
    -   **载荷**: 包含用户 ID、角色等关键信息
    -   **存储建议**: 前端存在内存或 localStorage

-   **Refresh Token**：
    -   **有效期**: 长（如 7 天 - 30 天）
    -   **作用**: **仅用于**换取新的 Access Token，不能用来访问业务接口
    -   **存储建议**: 前端存在 `HttpOnly Cookie` 中（防止 XSS），或者 localStorage

### 1.2 刷新流程图解

用一个时序图来理解整个流程：

```
前端                                后端
 │
 │──── 1. 登录 (用户名+密码) ─────────>│
 │<─── 返回 AccessToken + RefreshToken ─│
 │
 │──── 2. 请求业务接口 ─────────────────>│
 │     (Header: Bearer AccessToken)
 │<─── 200 OK (正常返回数据) ────────────│
 │
 │     ... 1 小时后，AccessToken 过期 ...
 │
 │──── 3. 请求业务接口 ─────────────────>│
 │<─── 401 Unauthorized (Token 过期) ───│
 │
 │──── 4. 请求刷新接口 ─────────────────>│
 │     (Body: RefreshToken)
 │<─── 返回 新的 AccessToken ───────────│
 │
 │──── 5. 重试原来的业务接口 ───────────>│
 │     (Header: Bearer 新的AccessToken)
 │<─── 200 OK ──────────────────────────│
```

**前端视角 (Axios Interceptor)**：

前端同学通常会在 Axios 的响应拦截器中处理这个逻辑：

1. 拦截到 401 错误
2. 暂停当前请求
3. 调用刷新接口拿新 Token
4. 更新 localStorage 和 Header
5. 自动重发原请求

这对用户是**完全无感**的——他只是感觉页面稍微慢了一点点。

## 2. 后端实现

### 2.1 更新 JWT 工具类

修改 `pkg/util/jwt.go`，支持生成两种 Token。

```go
package util

import (
	"time"
	"github.com/golang-jwt/jwt/v5"
)

// ... 原有的 Claims 定义 ...

// GenerateTokens 生成双令牌
func GenerateTokens(userID uint, username string) (accessToken, refreshToken string, err error) {
	// 1. 生成 Access Token (1小时)
	accessClaims := Claims{
		UserID:   userID,
		Username: username,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(1 * time.Hour)),
			Issuer:    "go-blog-api",
		},
	}
	accessToken, err = jwt.NewWithClaims(jwt.SigningMethodHS256, accessClaims).SignedString(jwtSecret)
	if err != nil {
		return "", "", err
	}

	// 2. 生成 Refresh Token (7天)
	// Refresh Token 可以只包含 UserID，或者包含一个随机串用于撤销
	refreshClaims := jwt.RegisteredClaims{
		Subject:   "refresh",
		ExpiresAt: jwt.NewNumericDate(time.Now().Add(7 * 24 * time.Hour)),
		Issuer:    "go-blog-api",
	}
	refreshToken, err = jwt.NewWithClaims(jwt.SigningMethodHS256, refreshClaims).SignedString(jwtSecret)
	if err != nil {
		return "", "", err
	}

	return accessToken, refreshToken, nil
}

// ParseRefreshToken 单独解析 Refresh Token
func ParseRefreshToken(tokenString string) (*jwt.RegisteredClaims, error) {
    // ... 类似 ParseToken，但返回 RegisteredClaims
}
```

### 2.2 登录接口升级

修改 `internal/service/user_service.go` 的 `Login` 方法。

```go
type LoginResponse struct {
	AccessToken  string     `json:"access_token"`
	RefreshToken string     `json:"refresh_token"`
	User         model.User `json:"user"`
}

func (s *UserService) Login(req *LoginRequest) (*LoginResponse, error) {
	// ... 验证账号密码逻辑 ...

	// 生成双令牌
	at, rt, err := util.GenerateTokens(user.ID, user.Username)
	if err != nil {
		return nil, err
	}

	return &LoginResponse{
		AccessToken:  at,
		RefreshToken: rt,
		User:         *user,
	}, nil
}
```

### 2.3 刷新 Token 接口

创建 `internal/api/v1/auth.go` (或者在 user.go 中)，添加 `RefreshToken` 接口。

```go
func (ctrl *UserController) RefreshToken(c *gin.Context) {
	type RefreshReq struct {
		RefreshToken string `json:"refresh_token" binding:"required"`
	}
	var req RefreshReq
	if err := c.ShouldBindJSON(&req); err != nil {
		util.Error(c, http.StatusBadRequest, 400, "Invalid request")
		return
	}

	// 1. 校验 Refresh Token 是否有效
	claims, err := util.ParseRefreshToken(req.RefreshToken)
	if err != nil {
		util.Error(c, http.StatusUnauthorized, 401, "Invalid refresh token")
		return
	}

	// 2. (可选) 检查 Redis 中该 Refresh Token 是否被废弃
	// ...

	// 3. 这里的 claims 里可能没有 UserID (取决于你生成时放没放)
	// 如果没放，你可能需要把 UserID 放在 RefreshToken 的 Subject 里，或者查库
	// 假设我们之前生成时把 UserID 放在了 Subject 或者自定义 Claims 里
    // 这里简化逻辑，假设我们能获取到 UserID
    // userID := ... 

	// 4. 生成新的 Access Token
	// 注意：通常刷新接口只返回新的 Access Token，Refresh Token 可以复用，也可以一起轮换 (Rotation)
	// 为了安全，建议一起轮换
	newAt, newRt, _ := util.GenerateTokens(userID, username)

	util.Success(c, gin.H{
		"access_token":  newAt,
		"refresh_token": newRt,
	})
}
```

## 3. 退出登录与 Redis 黑名单

### 3.0 前端同学的 Redis 快速回顾

在第 7 章我们介绍过 Redis，这里再快速回顾一下它在认证场景的作用：

> Redis 是一个**内存数据库**，读写速度极快（微秒级）。我们用它来存储"需要快速判断"的数据。

在 JWT 黑名单场景中：

- **为什么用 Redis？** 因为每个请求都要检查 Token 是否被拉黑，这个操作必须非常快；
- **为什么不用 MySQL？** MySQL 是磁盘数据库，每次查询都要走磁盘 IO，太慢了；
- **存什么？** 存被废止的 Token 字符串，Key 可以是 `blacklist:{token}`，Value 随便写个 `1`；
- **存多久？** 只需要存到 Token 自然过期为止。过期后 Token 本身就无效了，没必要再占 Redis 空间。

JWT 自身无法销毁。要实现"退出登录"，我们必须在服务端记录"哪些 Token 是无效的"。

### 3.1 Redis 黑名单工具

在 `pkg/cache/redis.go` 中添加：

```go
// SetBlacklist 将 Token 加入黑名单
func SetBlacklist(token string, expiration time.Duration) error {
	return RDB.Set(Ctx, "blacklist:"+token, "1", expiration).Err()
}

// IsBlacklisted 检查 Token 是否在黑名单中
func IsBlacklisted(token string) bool {
	val, err := RDB.Get(Ctx, "blacklist:"+token).Result()
	return err == nil && val == "1"
}
```

### 3.2 退出登录接口

```go
func (ctrl *UserController) Logout(c *gin.Context) {
	// 1. 获取当前的 Access Token
	token := c.GetHeader("Authorization")
	if len(token) > 7 && token[:7] == "Bearer " {
		token = token[7:]
	}

	// 2. 计算 Token 剩余有效期
	// 我们只需要把 Token 封禁到它自然过期为止。过期后它本身就无效了，没必要永久占 Redis 空间。
	claims, _ := util.ParseToken(token)
	expiration := claims.ExpiresAt.Time.Sub(time.Now())

	// 3. 加入 Redis 黑名单
	if expiration > 0 {
		_ = cache.SetBlacklist(token, expiration)
	}

	util.Success(c, nil)
}
```

### 3.3 升级鉴权中间件

修改 `internal/middleware/auth.go`，在校验 Token 签名之前，先查 Redis 黑名单。

```go
func JWT() gin.HandlerFunc {
	return func(c *gin.Context) {
		// ... 获取 token ...
        
        // 1. 检查黑名单
        if cache.IsBlacklisted(token) {
            util.Error(c, http.StatusUnauthorized, 401, "Token invalidated")
            c.Abort()
            return
        }

		// 2. 解析 Token
		claims, err := util.ParseToken(token)
        // ...
    }
}
```

## 4. 强制下线 (Force Logout)

在 RBAC 系统中，管理员修改了用户权限或封禁了用户后，需要让该用户**立即下线**。

原理与退出登录类似，但我们需要一种方式找到该用户的所有有效 Token。
或者，我们可以换一种思路：**版本号机制**。

1.  在 `users` 表中增加 `token_version` 字段 (int, 默认 0)。
2.  生成 Token 时，将当前的 `token_version` 放入 Token 载荷。
3.  中间件校验时，对比 Token 中的 version 和数据库(或 Redis 缓存)中的 version。
4.  **强制下线**：管理员将该用户的 `token_version` + 1。
5.  此时，用户手里的旧 Token (version=0) 虽然签名有效，但版本号不匹配，被中间件拒绝。

这种方式比记录所有 Token 到黑名单更高效。

## 5. 本章小结与练习

这一章，我们构建了一个生产级的认证体系，解决了简单 JWT 的两大痛点：

1. **双令牌 (Access + Refresh)**：
   - Access Token 短期有效，用于访问业务接口；
   - Refresh Token 长期有效，仅用于换取新的 Access Token；
   - 两者分工明确，平衡了安全性和用户体验。

2. **Redis 黑名单**：
   - 弥补了 JWT "无法废止"的缺陷；
   - 用户退出登录时，把当前 Token 加入黑名单；
   - 中间件在每次请求时先查黑名单，再校验签名。

3. **强制下线（版本号机制）**：
   - 在用户表增加 `token_version` 字段；
   - Token 载荷中也存一份 version；
   - 管理员想踢人下线，只需把数据库里的 version +1，旧 Token 自动失效。

> **前端配合要点**：
> 
> - 前端需要在 Axios 响应拦截器中处理 401，自动调用刷新接口；
> - 刷新成功后更新 localStorage 并重发原请求；
> - 刷新失败（Refresh Token 也过期）则跳转登录页。

### 思考题 / 练习

1. **实现完整的刷新逻辑**：
   - 补全 `ParseRefreshToken` 函数，让它能正确解析 Refresh Token 并提取 UserID；
   - 测试：登录后等 Access Token 过期，调用刷新接口，观察返回的新 Token。

2. **测试退出登录**：
   - 登录后记录 Access Token；
   - 调用退出登录接口；
   - 用刚才记录的 Token 再调业务接口，验证是否返回 401。

3. **实现版本号强制下线**：
   - 在 `User` 模型中增加 `TokenVersion` 字段；
   - 修改 `GenerateTokens` 函数，把 version 放入 Access Token 载荷；
   - 修改 JWT 中间件，对比 Token 中的 version 和数据库中的 version；
   - 写一个管理员接口 `POST /users/:id/kick`，把该用户的 version +1。

> 双令牌机制是目前业界最主流的 JWT 使用方式，几乎所有的 OAuth 2.0 实现（Google、GitHub、微信登录）都采用这套模式。理解了这一章，你就掌握了认证的核心套路。
