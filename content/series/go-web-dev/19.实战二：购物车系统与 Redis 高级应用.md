---
title: "实战二：购物车系统与 Redis 高级应用"
description: "以前端购物车组件为出发点，使用 Redis Hash 设计高性能购物车存储，实现登录/未登录场景下的购物车增删改查与合并策略，并通过 Go + Gin 暴露完整 API。"
date: "2025-12-13"
seriesOrder: 19
---

# 19. 实战二：购物车系统与 Redis 高级应用

> 这一篇，我们从你最熟悉的“前端购物车组件状态”出发，把它一步步翻译成 Redis 数据结构 + Go API，并讨论未登录/登录态的购物车合并策略。

在电商系统里，购物车有几个典型特征：

- **读写都很频繁**：每次加减数量、勾选/取消勾选都会触发请求；
- **对一致性要求没那么严格**：数量稍微有一点延迟通常可以接受，真正扣库存时会再校验；
- **和用户强绑定**：通常是“用户维度”的数据；
- **适合放在 Redis**：性能要求高、数据结构相对简单、体量相对订单要小很多。

这就是为什么“购物车”是 Redis 的**明星场景之一**。

本篇我们会完成：

1. 设计购物车的数据结构（先用 TypeScript，后用 Redis 表达）。
2. 用 Redis Hash 实现购物车存储（含 key 设计）。
3. 用 Go 实现购物车的增删改查 API。
4. 讨论“未登录购物车”和“登录后购物车”的合并策略，并给到一个落地实现思路。

---

## 1. 从前端视角设计购物车数据结构

先看一眼前端里最自然的购物车类型定义（TypeScript）：

```ts
// 单个购物车条目
interface CartItem {
  skuId: number;
  productId: number;
  title: string;
  price: number;      // 当前售价
  quantity: number;   // 数量
  checked: boolean;   // 是否勾选
  image: string;      // 展示用的缩略图
  attrs: Array<{ name: string; value: string }>; // 规格信息
}

// 购物车整体
interface CartState {
  items: CartItem[];
  updatedAt: string;
}
```

在 Zustand 里，你可能这样管理状态：

```ts
interface CartStore {
  items: CartItem[];
  addItem: (item: CartItem) => void;
  removeItem: (skuId: number) => void;
  updateQuantity: (skuId: number, quantity: number) => void;
}
```

后端要做的事情，本质上就是：

- 把这份 **CartState** 从内存状态，搬到 **Redis 里**；
- 通过 HTTP API 暴露出来，让前端 Zustand 可以“托管”到后端；
- 支持多端（H5、App、小程序）共享同一份购物车。

---

## 2. 为什么购物车适合放在 Redis？

几个关键理由：

1. **高频读写**：
   - 每次加减数量、选择/取消选择、删除商品，都要命中购物车；
   - 用 MySQL 每次 `UPDATE` 会有较高的 IO 成本，还可能产生行锁冲突。

2. **可容忍一定程度的不一致**：
   - 真正扣库存是在创建订单/支付扣减那一刻；
   - 购物车更多是一个“临时状态”，允许短暂的延迟或覆盖。

3. **数据体量可控**：
   - 一般每个用户的购物车条目不会超过几十条；
   - 可以设置过期时间（比如 30 天不访问就自动清除）。

4. **Redis 的数据结构非常适合表达购物车**：
   - 使用 `Hash` 可以快速根据 `skuId` 访问某条记录；
   - 结合 `TTL`、`EXPIRE` 轻松回收过期购物车。

---

## 3. Redis 中购物车数据结构设计

我们先决定几件事情：

1. **Key 设计**：
   - 登录用户：`cart:user:{userID}`
   - 未登录用户（基于临时 `cart_token`）：`cart:guest:{cartToken}`

2. **Value 结构**：
   - 使用 Redis Hash：

```text
HSET cart:user:123  "sku:1001"  "{...CartItemJSON...}"
HSET cart:user:123  "sku:1002"  "{...CartItemJSON...}"
```

每个 field 的命名可以是：`sku:{skuID}`，value 是 JSON 字符串。

对应的数据结构：

```ts
// Redis Hash 中的 value 序列化格式
interface CartItemRedis {
  sku_id: number;
  product_id: number;
  title: string;
  price: number;
  quantity: number;
  checked: boolean;
  image: string;
  attrs: Array<{ name: string; value: string }>;
}
```

和前端基本一致，只是走 snake_case，方便在 Go 里直接使用。

---

## 4. Go 中的购物车模型定义

我们先在 Go 中定义这两个结构：

```go
// internal/model/cart.go

package model

type CartItem struct {
    SkuID     uint64   `json:"sku_id"`
    ProductID uint64   `json:"product_id"`
    Title     string   `json:"title"`
    Price     float64  `json:"price"`
    Quantity  int      `json:"quantity"`
    Checked   bool     `json:"checked"`
    Image     string   `json:"image"`
    Attrs     SkuAttrs `json:"attrs"` // 复用前面 SKU 的属性类型
}

type Cart struct {
    Items []CartItem `json:"items"`
}
```

> 注意：这里的 `SkuAttrs` 可以直接复用上一篇里的定义（`[]SkuAttr`）。

---

## 5. Cart Redis 仓储层：增删改查

我们封装一个 `CartRepository` 专门操作 Redis：

```go
// internal/repository/cart_repository.go

package repository

import (
    "context"
    "encoding/json"
    "fmt"
    "strconv"
    "time"

    "github.com/redis/go-redis/v9"
    "yourapp/internal/model"
)

type CartRepository struct {
    rdb *redis.Client
}

func NewCartRepository(rdb *redis.Client) *CartRepository {
    return &CartRepository{rdb: rdb}
}

// key 生成逻辑
func (r *CartRepository) userCartKey(userID uint64) string {
    return fmt.Sprintf("cart:user:%d", userID)
}

func (r *CartRepository) guestCartKey(token string) string {
    return fmt.Sprintf("cart:guest:%s", token)
}

// SetTTL 设置购物车过期时间
func (r *CartRepository) SetTTL(ctx context.Context, key string, ttl time.Duration) error {
    return r.rdb.Expire(ctx, key, ttl).Err()
}

// AddOrUpdateItem 添加或更新条目
func (r *CartRepository) AddOrUpdateItem(ctx context.Context, key string, item model.CartItem) error {
    b, err := json.Marshal(item)
    if err != nil {
        return err
    }

    field := r.skuField(item.SkuID)

    pipe := r.rdb.TxPipeline()
    pipe.HSet(ctx, key, field, string(b))
    pipe.Expire(ctx, key, 30*24*time.Hour) // 30 天

    _, err = pipe.Exec(ctx)
    return err
}

func (r *CartRepository) skuField(skuID uint64) string {
    return "sku:" + strconv.FormatUint(skuID, 10)
}

// GetAllItems 获取整个购物车
func (r *CartRepository) GetAllItems(ctx context.Context, key string) ([]model.CartItem, error) {
    values, err := r.rdb.HGetAll(ctx, key).Result()
    if err != nil {
        return nil, err
    }
    items := make([]model.CartItem, 0, len(values))
    for _, v := range values {
        var item model.CartItem
        if err := json.Unmarshal([]byte(v), &item); err != nil {
            // 单条解析失败可以选择跳过
            continue
        }
        items = append(items, item)
    }
    return items, nil
}

// RemoveItem 删除某个 SKU
func (r *CartRepository) RemoveItem(ctx context.Context, key string, skuID uint64) error {
    field := r.skuField(skuID)
    return r.rdb.HDel(ctx, key, field).Err()
}

// UpdateChecked 更新勾选状态
func (r *CartRepository) UpdateChecked(ctx context.Context, key string, skuID uint64, checked bool) error {
    items, err := r.GetAllItems(ctx, key)
    if err != nil {
        return err
    }
    for i := range items {
        if items[i].SkuID == skuID {
            items[i].Checked = checked
            return r.AddOrUpdateItem(ctx, key, items[i])
        }
    }
    return nil
}

// Clear 清空购物车
func (r *CartRepository) Clear(ctx context.Context, key string) error {
    return r.rdb.Del(ctx, key).Err()
}
```

这里做了几个事情：

- 统一通过 `userCartKey` / `guestCartKey` 生成 Redis key；
- 通过 `HSET` 把每个 `CartItem` 按 `sku:{id}` 存成一个 JSON；
- 给购物车设置 30 天过期时间，避免垃圾数据积累。

---

## 6. 购物车 Service：业务逻辑封装

在 Repository 之上，我们再加一层 Service，处理一些业务规则：

```go
// internal/service/cart_service.go

package service

import (
    "context"

    "yourapp/internal/model"
    "yourapp/internal/repository"
)

type CartService struct {
    cartRepo *repository.CartRepository
}

func NewCartService(cartRepo *repository.CartRepository) *CartService {
    return &CartService{cartRepo: cartRepo}
}

// AddItemToUserCart 登录用户添加购物车
func (s *CartService) AddItemToUserCart(ctx context.Context, userID uint64, item model.CartItem) error {
    key := s.cartRepo.userCartKey(userID)

    // 业务规则：同一个 SKU 再次添加时，叠加数量
    items, err := s.cartRepo.GetAllItems(ctx, key)
    if err != nil {
        return err
    }

    for _, it := range items {
        if it.SkuID == item.SkuID {
            item.Quantity += it.Quantity
            break
        }
    }

    return s.cartRepo.AddOrUpdateItem(ctx, key, item)
}

// GetUserCart 获取用户购物车
func (s *CartService) GetUserCart(ctx context.Context, userID uint64) (*model.Cart, error) {
    key := s.cartRepo.userCartKey(userID)
    items, err := s.cartRepo.GetAllItems(ctx, key)
    if err != nil {
        return nil, err
    }
    return &model.Cart{Items: items}, nil
}

// RemoveItemFromUserCart 删除某个 SKU
func (s *CartService) RemoveItemFromUserCart(ctx context.Context, userID, skuID uint64) error {
    key := s.cartRepo.userCartKey(userID)
    return s.cartRepo.RemoveItem(ctx, key, skuID)
}

// UpdateChecked 更新勾选状态
func (s *CartService) UpdateChecked(ctx context.Context, userID, skuID uint64, checked bool) error {
    key := s.cartRepo.userCartKey(userID)
    return s.cartRepo.UpdateChecked(ctx, key, skuID, checked)
}

// ClearUserCart 清空购物车
func (s *CartService) ClearUserCart(ctx context.Context, userID uint64) error {
    key := s.cartRepo.userCartKey(userID)
    return s.cartRepo.Clear(ctx, key)
}
```

这一层与 Repository 的区别在于：

- 更关注“业务规则”而不是“Redis 操作细节”；
- 比如“同一个 SKU 重复添加要叠加数量”等逻辑就属于 Service 层。

---

## 7. Gin 购物车接口设计

我们设计几条典型接口：

- `GET /api/cart`：获取当前用户购物车；
- `POST /api/cart/items`：添加商品到购物车；
- `PATCH /api/cart/items/:skuId`：更新数量或勾选状态；
- `DELETE /api/cart/items/:skuId`：删除某个 SKU；
- `DELETE /api/cart`：清空购物车。

### 7.1 请求/响应结构体

```go
// internal/handler/cart.go

package handler

import (
    "net/http"
    "strconv"

    "github.com/gin-gonic/gin"

    "yourapp/internal/model"
    "yourapp/internal/service"
)

type AddCartItemRequest struct {
    SkuID     uint64  `json:"sku_id" binding:"required"`
    ProductID uint64  `json:"product_id" binding:"required"`
    Quantity  int     `json:"quantity" binding:"required,min=1"`
}

type UpdateCartItemRequest struct {
    Quantity *int  `json:"quantity"` // 可选，如果为 nil 表示不更新
    Checked  *bool `json:"checked"`  // 可选
}
```

这里用了一个常见技巧：

- 在 `UpdateCartItemRequest` 中使用指针 `*int` 和 `*bool` 来区分“未传字段”和“传了但值为 0/false”的情况。

### 7.2 获取当前用户 ID 的中间件

我们假设你已经在 RBAC 实战中实现了 JWT 中间件，这里只用一个简化示意：

```go
func getUserIDFromContext(c *gin.Context) (uint64, bool) {
    // 实际上应该从 JWT 中读取
    v, exists := c.Get("user_id")
    if !exists {
        return 0, false
    }
    id, ok := v.(uint64)
    return id, ok
}
```

### 7.3 Handler 实现

```go
func GetCart(svc *service.CartService) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID, ok := getUserIDFromContext(c)
        if !ok || userID == 0 {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
            return
        }

        cart, err := svc.GetUserCart(c.Request.Context(), userID)
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }

        c.JSON(http.StatusOK, cart)
    }
}

func AddCartItem(svc *service.CartService) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID, ok := getUserIDFromContext(c)
        if !ok || userID == 0 {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
            return
        }

        var req AddCartItemRequest
        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        // 正常场景这里还需要根据 skuId 查询 SKU 信息
        item := model.CartItem{
            SkuID:     req.SkuID,
            ProductID: req.ProductID,
            Quantity:  req.Quantity,
            // Price, Title, Image, Attrs 等也应从 SKU 表中查出，避免前端传入篡改
        }

        if err := svc.AddItemToUserCart(c.Request.Context(), userID, item); err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }

        c.JSON(http.StatusOK, gin.H{"message": "ok"})
    }
}

func UpdateCartItem(svc *service.CartService) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID, ok := getUserIDFromContext(c)
        if !ok || userID == 0 {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
            return
        }

        skuIDStr := c.Param("skuId")
        skuID, err := strconv.ParseUint(skuIDStr, 10, 64)
        if err != nil || skuID == 0 {
            c.JSON(http.StatusBadRequest, gin.H{"error": "invalid skuId"})
            return
        }

        var req UpdateCartItemRequest
        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        ctx := c.Request.Context()
        key := svc.CartRepo().UserCartKey(userID) // 假设对外暴露
        items, err := svc.CartRepo().GetAllItems(ctx, key)
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }

        for _, it := range items {
            if it.SkuID == skuID {
                if req.Quantity != nil {
                    it.Quantity = *req.Quantity
                }
                if req.Checked != nil {
                    it.Checked = *req.Checked
                }
                if err := svc.CartRepo().AddOrUpdateItem(ctx, key, it); err != nil {
                    c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                    return
                }
                c.JSON(http.StatusOK, gin.H{"message": "ok"})
                return
            }
        }

        c.JSON(http.StatusNotFound, gin.H{"error": "item not found"})
    }
}

func DeleteCartItem(svc *service.CartService) gin.HandlerFunc {
    return func(c *gin.Context) {
        userID, ok := getUserIDFromContext(c)
        if !ok || userID == 0 {
            c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
            return
        }

        skuIDStr := c.Param("skuId")
        skuID, err := strconv.ParseUint(skuIDStr, 10, 64)
        if err != nil || skuID == 0 {
            c.JSON(http.StatusBadRequest, gin.H{"error": "invalid skuId"})
            return
        }

        if err := svc.RemoveItemFromUserCart(c.Request.Context(), userID, skuID); err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }

        c.JSON(http.StatusOK, gin.H{"message": "ok"})
    }
}
```

> 上面 `UpdateCartItem` 中对 `CartRepo()` 的访问实际项目中可以通过更规范的封装完成，这里为了展示逻辑路径写得略直白，你在真实项目中可以再做一层封装。

---

## 8. 未登录购物车与登录后合并策略

现实中用户经常会：

- 在未登录状态下加购物车（比如游客模式）；
- 登录后希望原来的购物车内容还在，并和账号下的购物车合并。

典型流程：

1. 首次访问站点时，前端生成一个 `cart_token`（UUID），存到 LocalStorage / Cookie；
2. 未登录时，所有购物车操作带上这个 `cart_token`，后端使用 `cart:guest:{token}` 存储；
3. 用户登录成功时：
   - 后端拿到 `userID` 和 `cart_token`；
   - 把 `guest` 购物车和 `user` 购物车进行合并；
   - 删除 `guest` 购物车 key；
   - 返回合并后的购物车给前端。

### 8.1 合并策略

当同一个 `skuId` 在 guest cart 和 user cart 中都存在时：

- 一般做法是：**数量相加**，勾选状态取“任意一个为 true 则为 true”；
- 或者遵循某个优先级（比如已登录购物车优先）。

我们实现一个简单合并：

```go
// internal/service/cart_merge.go

package service

import (
    "context"

    "yourapp/internal/model"
)

// MergeGuestCartToUser 将 guest 购物车合并到 user 购物车
func (s *CartService) MergeGuestCartToUser(ctx context.Context, userID uint64, guestToken string) error {
    userKey := s.cartRepo.UserCartKey(userID)
    guestKey := s.cartRepo.GuestCartKey(guestToken)

    guestItems, err := s.cartRepo.GetAllItems(ctx, guestKey)
    if err != nil {
        return err
    }
    if len(guestItems) == 0 {
        return nil
    }

    userItems, err := s.cartRepo.GetAllItems(ctx, userKey)
    if err != nil {
        return err
    }

    // 构建一个 map 方便合并
    userMap := make(map[uint64]model.CartItem, len(userItems))
    for _, it := range userItems {
        userMap[it.SkuID] = it
    }

    for _, g := range guestItems {
        if u, ok := userMap[g.SkuID]; ok {
            // 同一 SKU，数量相加，勾选取“或”
            u.Quantity += g.Quantity
            u.Checked = u.Checked || g.Checked
            userMap[g.SkuID] = u
        } else {
            userMap[g.SkuID] = g
        }
    }

    // 回写到 user cart
    for _, it := range userMap {
        if err := s.cartRepo.AddOrUpdateItem(ctx, userKey, it); err != nil {
            return err
        }
    }

    // 删除 guest 购物车
    if err := s.cartRepo.Clear(ctx, guestKey); err != nil {
        return err
    }

    return nil
}
```

前端配合：

- 登录接口调用成功后，将当前客户端保存的 `cart_token` 传给后端；
- 后端在登录完成后的逻辑中调用 `MergeGuestCartToUser`；
- 合并完成后返回最新购物车给前端，前端更新本地状态。

---

## 9. 前端（Next.js + Zustand）与后端购物车 API 联动示例

从你熟悉的前端视角，看一下如何对接这些 API。

### 9.1 定义 API 客户端

```ts
// lib/api/cart.ts

export interface AddCartItemPayload {
  sku_id: number;
  product_id: number;
  quantity: number;
}

export async function addCartItem(payload: AddCartItemPayload) {
  const res = await fetch('/api/cart/items', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
    credentials: 'include',
  });

  if (!res.ok) {
    throw new Error('Failed to add cart item');
  }
}

export async function fetchCart() {
  const res = await fetch('/api/cart', { credentials: 'include' });
  if (!res.ok) throw new Error('Failed to fetch cart');
  return res.json();
}
```

### 9.2 在 Zustand 中同步后端状态

```ts
// store/cart.ts

import { create } from 'zustand';
import { addCartItem, fetchCart } from '@/lib/api/cart';

interface CartItem {
  sku_id: number;
  product_id: number;
  title: string;
  price: number;
  quantity: number;
  checked: boolean;
  image: string;
  attrs: Array<{ name: string; value: string }>;
}

interface CartStore {
  items: CartItem[];
  loading: boolean;
  fetchCart: () => Promise<void>;
  addItem: (payload: { sku_id: number; product_id: number; quantity: number }) => Promise<void>;
}

export const useCartStore = create<CartStore>((set, get) => ({
  items: [],
  loading: false,
  fetchCart: async () => {
    set({ loading: true });
    try {
      const data = await fetchCart();
      set({ items: data.items, loading: false });
    } catch (e) {
      set({ loading: false });
    }
  },
  addItem: async (payload) => {
    await addCartItem(payload);
    // 添加成功后重新拉取一次，确保和后端数据对齐
    await get().fetchCart();
  },
}));
```

这里有一个重要理念：

- **购物车的真实“单一事实来源”在后端 Redis；**
- 前端 Zustand 只是一层“缓存视图”，每次关键操作后都以服务端状态为准。

---

## 10. 小结与下一步

本篇我们完成了：

1. 从前端 `CartItem` 结构出发，设计了 Redis 中的 Hash 存储模型；
2. 在 Go 中定义了购物车模型，并实现了基于 `go-redis v9` 的仓储层（Hash 操作）；
3. 封装了购物车 Service，包括添加、删除、更新、清空等业务逻辑；
4. 使用 Gin 实现了购物车 API，与前端保持良好的对接契约；
5. 设计并实现了“未登录购物车”和“登录后购物车”的合并策略；
6. 展示了 Next.js 16 + Zustand 如何与后端购物车 API 联动。

在下一篇《实战二：订单状态机与分布式 ID 生成》中，我们会在购物车的基础上：

- 从“勾选购物车条目”生成订单；
- 引入**分布式 ID 生成方案**（雪花算法 Snowflake 等）；
- 设计一个可维护的订单状态机（已创建、待支付、已支付、已发货、已完成、已取消）；
- 并用 GORM 事务保证下单时的基本一致性。

到那时，你会看到：

- Redis 中的购物车只是交易链路的“前奏”；
- 真正的业务核心在于“如何从购物车安全地走向订单与库存”。
