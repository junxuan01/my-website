---
title: "架构：分层架构与依赖注入"
description: "告别面条代码。深入理解 Controller-Service-Repository 分层架构，实现业务逻辑与数据访问的解耦。使用依赖注入（DI）构建可测试、可维护的 Go 应用。"
date: "2025-12-06"
seriesOrder: 4
---

# 4. 架构：分层架构与依赖注入

## 引言

在写前端代码时，我们习惯将逻辑拆分为：

- `Component`：负责 UI 展示；
- `Hook`：封装可复用的逻辑；
- `API` 封装：集中管理请求调用。

在后端开发中，为了应对复杂的业务逻辑，我们同样需要分层，否则所有东西都堆在一起，很快就会变成难以维护的“大泥球”。

最经典、也最贴合前端思维的分层架构是 **Controller-Service-Repository (CSR)** 模式：

- **Controller (API 层)**：负责解析 HTTP 请求，参数校验，调用 Service，返回响应；
- **Service (业务层)**：核心业务逻辑（如：注册时检查用户名是否存在、加密密码、发送欢迎邮件）；
- **Repository (数据层)**：直接操作数据库（CRUD）。

可以粗略类比成：

- Controller ≈ API Route Handler（Next.js API Route / Node 路由函数）；
- Service ≈ 复杂业务 Hook / 业务逻辑模块；
- Repository ≈ axios 封装 / SDK，专门和后端（这里是数据库）打交道。

本章我们会用一个完整的“用户注册”功能，把这三层都串起来，并顺便引出 **依赖注入（DI）** 的概念，为后面的测试和维护打基础。

> 本章目标：
>
> - 看懂并写出一个清晰的 CSR 分层结构；
> - 把“用户注册”这个功能拆到 Repository 和 Service，再到 Controller；
> - 初步理解什么是依赖注入，以及它能解决什么痛点。

## 0. 为什么要分层？（从前端“可维护性”说起）

很多人第一次写后端，最常见的写法是把所有逻辑堆在一个 handler 里：

```go
func Register(c *gin.Context) {
		// 解析参数
		// 校验参数
		// 查数据库：用户名是否存在
		// 加密密码
		// 写数据库：创建用户
		// 返回 JSON
}
```

短期看“能跑”，长期会出现几个典型问题：

1. **复用困难**：注册、登录、修改资料都会用到“查用户/写用户”，但你只能复制粘贴；
2. **测试困难**：你想测“加密密码是否正确”，结果必须连数据库、走完整 HTTP；
3. **改动放大**：改一处校验逻辑，可能要改 5 个接口；
4. **团队协作困难**：多人同时改同一个文件，冲突频发。

> **前端类比**：
> - 不分层 ≈ 把所有逻辑都塞进一个 React 组件里（请求、状态、校验、渲染全混在一起）
> - 分层 ≈ Component 只负责渲染；业务放 Hook；请求放 api client；类型放 DTO

### 0.1 CSR 分层到底在“分”什么？

把一次请求想象成一条流水线：

```
HTTP 请求
	↓
Controller：解析/校验/路由
	↓
Service：业务编排（规则、流程）
	↓
Repository：数据读写（SQL）
	↓
DB / Cache / MQ
```

每一层只做自己“最擅长”的事：

- **Controller**：处理 HTTP 世界的细节（参数来源、状态码、返回结构）；
- **Service**：只关心业务规则（用户名是否允许、密码怎么加密、要不要发邮件）；
- **Repository**：只关心数据访问（用什么 SQL/GORM 查、怎么分页、怎么更新）。

### 0.2 为什么 Service 层是关键？

前端同学经常会问："Repository 都能查库了，为什么还要 Service？"

因为真实业务很少是“查一次库就结束”：

- 注册：查重 → 加密 → 写库 → 可能发邮件/写日志；
- 下单：校验库存 → 扣库存 → 写订单 → 发 MQ；
- 改密码：校验旧密码 → 更新密码 → 让旧 Token 失效。

这些**跨多个仓储/组件的编排**，就是 Service 的职责。

## 1. Repository 层：数据访问

我们从最底层开始看起：**Repository 层只关心“数据怎么存取”，不关心业务逻辑。**

可以把它想象成“一个只负责发 SQL 的 axios 封装模块”。

创建 `internal/repository/user_repo.go`：

```go
package repository

import (
	"go-blog-api/internal/model"
	"go-blog-api/pkg/db"

	"gorm.io/gorm"
)

type UserRepository struct {
	db *gorm.DB
}

func NewUserRepository() *UserRepository {
	return &UserRepository{
		db: db.DB,
	}
}

// Create 创建用户
func (r *UserRepository) Create(user *model.User) error {
	return r.db.Create(user).Error
}

// GetByUsername 根据用户名获取用户
func (r *UserRepository) GetByUsername(username string) (*model.User, error) {
	var user model.User
	err := r.db.Where("username = ?", username).First(&user).Error
	if err != nil {
		return nil, err
	}
	return &user, nil
}

// GetByEmail 根据邮箱获取用户
func (r *UserRepository) GetByEmail(email string) (*model.User, error) {
	var user model.User
	err := r.db.Where("email = ?", email).First(&user).Error
	if err != nil {
		return nil, err
	}
	return &user, nil
}
```

在这一层，我们约定几点基本原则：

- 不在 Repository 里写业务逻辑（例如“用户名是否存在”“邮箱是否占用”等都不属于这里）；
- 不关心 HTTP、JSON、请求/响应，只专注于 SQL 和模型；
- 所有数据库相关的错误都原样返回给上层，由 Service 再决定如何处理。

## 2. Service 层：业务逻辑

Service 层是系统的“心脏”。它负责编排 Repository，处理复杂的业务规则。

你可以把它想象成一个“复杂的业务 Hook”：

- 输入是某个请求 DTO（例如注册信息）；
- 内部会调用多个 Repository / 第三方服务；
- 输出是一个“干净”的结果或者错误。

创建 `internal/service/user_service.go`：

```go
package service

import (
	"errors"

	"go-blog-api/internal/model"
	"go-blog-api/internal/repository"
	"go-blog-api/pkg/util"

	"golang.org/x/crypto/bcrypt"
)

// UserService 负责和“用户相关”的业务逻辑
type UserService struct {
	userRepo *repository.UserRepository
}

// NewUserService 构造函数，目前内部自己创建依赖
// 后面我们会讨论如何通过依赖注入把这个依赖从外部传进来
func NewUserService() *UserService {
	return &UserService{
		userRepo: repository.NewUserRepository(),
	}
}

type RegisterRequest struct {
	Username string `json:"username" binding:"required"`
	Password string `json:"password" binding:"required,min=6"`
	Email    string `json:"email" binding:"required,email"`
}

// Register 用户注册逻辑
func (s *UserService) Register(req *RegisterRequest) error {
	// 1. 检查用户名是否存在
	if _, err := s.userRepo.GetByUsername(req.Username); err == nil {
		return errors.New("username already exists")
	}

	// 2. 检查邮箱是否存在
	if _, err := s.userRepo.GetByEmail(req.Email); err == nil {
		return errors.New("email already exists")
	}

	// 3. 密码加密
	hashedPwd, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	if err != nil {
		return err
	}

	// 4. 创建用户
	user := &model.User{
		Username: req.Username,
		Password: string(hashedPwd),
		Email:    req.Email,
		Avatar:   "https://example.com/default-avatar.png",
	}

	return s.userRepo.Create(user)
}
```

**注意**：这里我们引入了 `bcrypt` 进行密码加密。
```bash
go get golang.org/x/crypto/bcrypt
```

在这个函数里可以看到典型的“业务逻辑编排流程”：

1. 通过 Repository 查重（用户名/邮箱）；
2. 对传入的明文密码进行加密（永远不要明文入库）；
3. 构造 `User` 模型并调用 Repository 写入数据库；
4. 出错时只返回错误到上层，由 Controller 再决定如何映射到 HTTP 状态码和响应体。

> 前端类比：
> - 可以把 `Register` 看成一个复杂的 `useRegisterUser` Hook，只对外暴露“我需要你提供哪些字段，最后告诉你成功还是失败”，内部细节完全封装。

## 3. Controller 层：请求处理

Controller 层负责接收 HTTP 请求，调用 Service，并返回结果。它是“HTTP 世界”和“业务世界”的桥梁。

创建 `internal/api/v1/user.go`：

```go
package v1

import (
	"net/http"

	"go-blog-api/internal/service"
	"go-blog-api/pkg/util"

	"github.com/gin-gonic/gin"
)

// UserController 负责处理用户相关的 HTTP 请求
type UserController struct {
	userService *service.UserService
}

// NewUserController 构造函数，目前内部直接创建 UserService
// 后续可以通过依赖注入将 userService 作为参数传入
func NewUserController() *UserController {
	return &UserController{
		userService: service.NewUserService(),
	}
}

// Register 用户注册接口
func (ctrl *UserController) Register(c *gin.Context) {
	var req service.RegisterRequest
	// 参数绑定与校验
	if err := c.ShouldBindJSON(&req); err != nil {
		util.Error(c, http.StatusBadRequest, 40001, err.Error())
		return
	}

	// 调用业务逻辑
	if err := ctrl.userService.Register(&req); err != nil {
		util.Error(c, http.StatusInternalServerError, 50001, err.Error())
		return
	}

	util.Success(c, nil)
}
```

## 4. 注册路由

修改 `internal/router/router.go`，注册用户相关的路由：

```go
// ...
	userCtrl := v1.NewUserController()

	apiV1 := r.Group("/api/v1")
	{
		// 用户相关
		auth := apiV1.Group("/auth")
		{
			auth.POST("/register", userCtrl.Register)
			// auth.POST("/login", userCtrl.Login)
		}
        // ...
    }
// ...
```

## 5. 依赖注入 (Dependency Injection)

你可能注意到了，我们在 `NewUserController` 中直接调用了 `NewUserService`，在 `NewUserService` 中直接调用了 `NewUserRepository`：

```go
func NewUserController() *UserController {
	return &UserController{
		userService: service.NewUserService(), // 硬编码依赖
	}
}
```

这种方式虽然简单，但导致层与层之间**强耦合**。如果我们要写单元测试，想 Mock 掉 `UserService` 或 `UserRepository`，就会非常困难。

### 5.1 从前端视角理解依赖注入

在前端你可能见过这样的写法：

```ts
// 反例：Hook 里直接创建 axios 实例
function useUserService() {
	const axiosInstance = axios.create({ baseURL: '/api/v1' })
  
  const register = (payload) => axiosInstance.post('/auth/register', payload)
  return { register }
}
```

这样一来，如果你想在测试里 Mock 掉 `axiosInstance`，会非常麻烦，因为 Hook 里面把依赖“写死”了。

更好的做法是把依赖“注入”进去：

```ts
function createUserService(httpClient) {
  const register = (payload) => httpClient.post('/auth/register', payload)
  return { register }
}

const userService = createUserService(axiosInstance)
```

这样在测试里，你就可以传一个假的 `httpClient`，完全不需要真的发请求。

后端里的依赖注入（DI）本质上也是一样的思想：

> **不要在组件内部偷偷创建依赖，而是通过构造函数/参数把依赖“传进来”。**

### 5.2 手动依赖注入的简单示例

我们可以先不用任何 DI 框架，只用最简单的“构造函数 + 接口”来改善当前结构。

第一步，让 `UserService` 依赖一个接口，而不是具体的 `UserRepository` 结构体：

```go
// internal/repository/user_repo.go
type IUserRepository interface {
	Create(user *model.User) error
	GetByUsername(username string) (*model.User, error)
	GetByEmail(email string) (*model.User, error)
}

type UserRepository struct {
	db *gorm.DB
}

// 确保 UserRepository 实现了接口
var _ IUserRepository = (*UserRepository)(nil)
```

然后修改 Service：

```go
// internal/service/user_service.go
type UserService struct {
	userRepo repository.IUserRepository
}

func NewUserService(userRepo repository.IUserRepository) *UserService {
	return &UserService{userRepo: userRepo}
}
```

最后在 Controller 或更上层“组装”这些依赖：

```go
// internal/api/v1/user.go
func NewUserController() *UserController {
	repo := repository.NewUserRepository()
	service := service.NewUserService(repo)

	return &UserController{
		userService: service,
	}
}
```

这样一来：

- 在正式环境中，我们传入真实的 `UserRepository`；
- 在单元测试中，我们可以实现一个 `MockUserRepository` 来替代真实仓储，实现“只测业务、不访问数据库”。

在大型 Go 项目中，我们通常会使用 **Wire**（Google 出品）或 **Fx**（Uber 出品）这样的依赖注入框架来自动完成这一“组装”过程。但为了保持本教程的简洁性，我们暂时通过**手动依赖注入 + 接口**的方式来演示理念。

## 6. 验证

运行项目，使用 Postman 发送注册请求：

**POST** `http://localhost:8080/api/v1/auth/register`

**Body:**
```json
{
    "username": "junxuan",
    "password": "password123",
    "email": "junxuan@example.com"
}
```

**Response:**
```json
{
    "code": 0,
    "message": "success",
    "data": null
}
```

再次发送相同的请求，应该返回错误：
```json
{
    "code": 50001,
    "message": "username already exists",
    "data": null
}
```


本章我们把“分层架构”这件事从抽象概念落到了具体代码上：

1. **Repository 层**：
	- 编写了 `UserRepository`，专注于 `users` 表的增/查；
	- 明确了“只做数据存取，不写业务逻辑”的职责边界。
2. **Service 层**：
	- 在 `UserService.Register` 中完整实现了“检查用户名/邮箱、加密密码、创建用户”的业务流程；
	- 用前端 Hook 的类比帮助你理解：Service 只关心业务输入/输出，不关心 HTTP 细节。
3. **Controller 层**：
	- 负责参数绑定、调用 Service、用统一响应结构返回结果；
	- 是前端真正打交道的“接口入口”。
4. **依赖注入理念**：
	- 从前端 Hook + axios 的例子出发，解释了“为什么不要在内部偷偷 new 依赖”；
	- 展示了用接口 + 构造函数手动注入依赖的思路，为后续写单元测试打基础。

### 贯穿任务线（本章验收：CSR 分层 + 注册链路跑通）

- [ ] 已按 CSR 分层组织：Controller 只做 HTTP，Service 做业务编排，Repository 做数据访问
- [ ] 已跑通“用户注册”接口：`POST /api/v1/auth/register`
- [ ] 重复注册能返回明确的业务错误（例如用户名已存在），并保持统一响应结构
- [ ] Service 层不直接关心 Gin/HTTP 细节（入参/出参是 DTO 和 error）
- [ ] （可选但推荐）开始把依赖改成“接口 + 构造函数注入”，为第 09 章单测做铺垫

### 推荐练习

1. 把 `UserService` 按小节中的方式改造成依赖接口的形式：
	- 定义 `IUserRepository` 接口；
	- 修改 `UserService` 的构造函数签名；
	- 修改 `NewUserController`，在其中“组装”真实的 `UserRepository` 和 `UserService`。
2. 为 `UserService` 写一个简单的“假仓储”实现，用于测试：
	- 创建一个 `MockUserRepository`，内部用内存切片代替数据库；
	- 在一个独立的 `main_mock.go` 或测试代码中创建 `UserService`，验证 `Register` 的查重逻辑是否工作正常。
3. 思考还有哪些地方适合引入 Service 层：
	- 比如“文章发布时顺便给作者加 10 积分”，你会怎么拆分到 Service 和 Repository？

**下一章预告**：
用户注册了，接下来就是**登录**。下一章我们将学习 **JWT (JSON Web Token)** 认证机制，并编写 Gin 的**中间件 (Middleware)** 来保护我们的 API，确保只有登录用户才能发布文章；同时也会从“前端调接口”的视角，讲清楚 Token 的签发、存储与使用方式。
用户注册了，接下来就是**登录**。下一章我们将学习 **JWT (JSON Web Token)** 认证机制，并编写 Gin 的**中间件 (Middleware)** 来保护我们的 API，确保只有登录用户才能发布文章。
