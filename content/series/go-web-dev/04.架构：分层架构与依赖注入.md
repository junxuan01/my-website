---
title: "架构：分层架构与依赖注入"
description: "告别面条代码。深入理解 Controller-Service-Repository 分层架构，实现业务逻辑与数据访问的解耦。使用依赖注入（DI）构建可测试、可维护的 Go 应用。"
date: "2025-12-06"
seriesOrder: 4
---

# 4. 架构：分层架构与依赖注入

## 引言

在写前端代码时，我们习惯将逻辑拆分为 `Component` (UI), `Hook` (逻辑), `API` (请求)。
在后端开发中，为了应对复杂的业务逻辑，我们同样需要分层。

最经典的分层架构是 **Controller-Service-Repository (CSR)** 模式。

-   **Controller (API 层)**: 负责解析 HTTP 请求，参数校验，调用 Service，返回响应。
-   **Service (业务层)**: 核心业务逻辑（如：注册时检查用户名是否存在，加密密码，生成 Token）。
-   **Repository (数据层)**: 直接操作数据库（CRUD）。

本章我们将实现 **用户注册** 功能，并贯穿这三层。

## 1. Repository 层：数据访问

Repository 层只关心数据怎么存取，不关心业务逻辑。

创建 `internal/repository/user_repo.go`:

```go
package repository

import (
	"go-blog-api/internal/model"
	"go-blog-api/pkg/db"

	"gorm.io/gorm"
)

type UserRepository struct {
	db *gorm.DB
}

func NewUserRepository() *UserRepository {
	return &UserRepository{
		db: db.DB,
	}
}

// Create 创建用户
func (r *UserRepository) Create(user *model.User) error {
	return r.db.Create(user).Error
}

// GetByUsername 根据用户名获取用户
func (r *UserRepository) GetByUsername(username string) (*model.User, error) {
	var user model.User
	err := r.db.Where("username = ?", username).First(&user).Error
	if err != nil {
		return nil, err
	}
	return &user, nil
}

// GetByEmail 根据邮箱获取用户
func (r *UserRepository) GetByEmail(email string) (*model.User, error) {
	var user model.User
	err := r.db.Where("email = ?", email).First(&user).Error
	if err != nil {
		return nil, err
	}
	return &user, nil
}
```

## 2. Service 层：业务逻辑

Service 层是系统的灵魂。它负责编排 Repository，处理复杂的业务规则。

创建 `internal/service/user_service.go`:

```go
package service

import (
	"errors"
	"go-blog-api/internal/model"
	"go-blog-api/internal/repository"
	"go-blog-api/pkg/util"

	"golang.org/x/crypto/bcrypt"
)

type UserService struct {
	userRepo *repository.UserRepository
}

func NewUserService() *UserService {
	return &UserService{
		userRepo: repository.NewUserRepository(),
	}
}

type RegisterRequest struct {
	Username string `json:"username" binding:"required"`
	Password string `json:"password" binding:"required,min=6"`
	Email    string `json:"email" binding:"required,email"`
}

// Register 用户注册逻辑
func (s *UserService) Register(req *RegisterRequest) error {
	// 1. 检查用户名是否存在
	if _, err := s.userRepo.GetByUsername(req.Username); err == nil {
		return errors.New("username already exists")
	}

	// 2. 检查邮箱是否存在
	if _, err := s.userRepo.GetByEmail(req.Email); err == nil {
		return errors.New("email already exists")
	}

	// 3. 密码加密
	hashedPwd, err := bcrypt.GenerateFromPassword([]byte(req.Password), bcrypt.DefaultCost)
	if err != nil {
		return err
	}

	// 4. 创建用户
	user := &model.User{
		Username: req.Username,
		Password: string(hashedPwd),
		Email:    req.Email,
		Avatar:   "https://example.com/default-avatar.png",
	}

	return s.userRepo.Create(user)
}
```

**注意**：这里我们引入了 `bcrypt` 进行密码加密。
```bash
go get golang.org/x/crypto/bcrypt
```

## 3. Controller 层：请求处理

Controller 层负责接收 HTTP 请求，调用 Service，并返回结果。

创建 `internal/api/v1/user.go`:

```go
package v1

import (
	"go-blog-api/internal/service"
	"go-blog-api/pkg/util"
	"net/http"

	"github.com/gin-gonic/gin"
)

type UserController struct {
	userService *service.UserService
}

func NewUserController() *UserController {
	return &UserController{
		userService: service.NewUserService(),
	}
}

// Register 用户注册接口
func (ctrl *UserController) Register(c *gin.Context) {
	var req service.RegisterRequest
	// 参数绑定与校验
	if err := c.ShouldBindJSON(&req); err != nil {
		util.Error(c, http.StatusBadRequest, 40001, err.Error())
		return
	}

	// 调用业务逻辑
	if err := ctrl.userService.Register(&req); err != nil {
		util.Error(c, http.StatusInternalServerError, 50001, err.Error())
		return
	}

	util.Success(c, nil)
}
```

## 4. 注册路由

修改 `internal/router/router.go`，注册用户相关的路由：

```go
// ...
	userCtrl := v1.NewUserController()

	apiV1 := r.Group("/api/v1")
	{
		// 用户相关
		auth := apiV1.Group("/auth")
		{
			auth.POST("/register", userCtrl.Register)
			// auth.POST("/login", userCtrl.Login)
		}
        // ...
    }
// ...
```

## 5. 依赖注入 (Dependency Injection)

你可能注意到了，我们在 `NewUserController` 中直接调用了 `NewUserService`，在 `NewUserService` 中直接调用了 `NewUserRepository`。

```go
func NewUserController() *UserController {
	return &UserController{
		userService: service.NewUserService(), // 硬编码依赖
	}
}
```

这种方式虽然简单，但导致层与层之间**强耦合**。如果我们要写单元测试，想 Mock 掉 `UserService`，就会非常困难。

在大型 Go 项目中，我们通常使用 **Wire** (Google 出品) 或 **Fx** (Uber 出品) 这样的依赖注入框架。

但为了保持本教程的简洁性，我们暂时手动管理依赖，或者在后续的“稳健”章节中引入 Wire。目前的结构对于中小型项目来说已经足够清晰。

## 6. 验证

运行项目，使用 Postman 发送注册请求：

**POST** `http://localhost:8080/api/v1/auth/register`

**Body:**
```json
{
    "username": "junxuan",
    "password": "password123",
    "email": "junxuan@example.com"
}
```

**Response:**
```json
{
    "code": 0,
    "message": "success",
    "data": null
}
```

再次发送相同的请求，应该返回错误：
```json
{
    "code": 50001,
    "message": "username already exists",
    "data": null
}
```

## 7. 总结

本章我们完成了：
1.  **分层架构落地**：实现了 CSR 三层架构，代码职责清晰。
2.  **业务逻辑实现**：完成了用户注册的核心逻辑（查重、加密、入库）。
3.  **密码安全**：学会了使用 `bcrypt` 对密码进行哈希处理，永远不要明文存储密码。

**下一章预告**：
用户注册了，接下来就是**登录**。下一章我们将学习 **JWT (JSON Web Token)** 认证机制，并编写 Gin 的**中间件 (Middleware)** 来保护我们的 API，确保只有登录用户才能发布文章。
