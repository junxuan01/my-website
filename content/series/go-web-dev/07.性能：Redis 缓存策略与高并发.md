---
title: "性能：Redis 缓存策略与高并发"
description: "提升系统性能的关键。引入 Redis 实现 Cache-Aside 缓存模式。深入探讨缓存穿透、缓存击穿与缓存雪崩的解决方案，以及使用 Redis 实现分布式锁。"
date: "2025-12-09"
seriesOrder: 7
---

# 7. 性能：Redis 缓存策略与高并发

## 引言

在前端项目里，你可能已经用过各种“缓存”手段：

- 浏览器缓存（`Cache-Control`、`ETag`）；
- SWR/React Query 这样的数据缓存 Hook；
- `localStorage` / `sessionStorage` / IndexedDB 存一些不常变的数据。

这些缓存大多发生在“用户的浏览器里”。但当你的后端接口被越来越多用户访问时，**单靠浏览器缓存是不够的**：

- 当你有 10 个用户刷新同一篇热门文章页面，还好；
- 当你有 100 万个用户同时刷首页，如果每一次都直接查 MySQL，数据库就会成为瓶颈。

这时候就轮到 Redis 登场了。你可以把它理解成“部署在后端侧的、极其高性能的 Key-Value 缓存服务器”。

本章我们会从零解释 Redis 是什么、它和 MySQL 的分工关系，并实现经典的 **Cache-Aside (旁路缓存)** 模式，解决高并发下常见的缓存三大问题：**穿透、击穿、雪崩**。

> 本章目标：
>
> - 从前端视角理解 Redis 在系统中的位置和作用；
> - 在项目中接入 Redis 客户端，并实现文章详情的缓存；
> - 了解缓存穿透/击穿/雪崩三种典型问题及对应解决方案；
> - 初步掌握 Redis 实现简单分布式锁的方式。

## 1. Redis 是什么，它和 MySQL 有什么关系？

先用一个你熟悉的前端类比：

- **MySQL** 更像是“后端的数据源 of truth”，就像前端项目里的远程 API：
	- 读写速度相对慢，但数据可靠、安全、持久；
	- 非常适合存“订单”“账户余额”“用户信息”这种核心数据。
- **Redis** 更像是“服务端的内存级缓存/状态库”，有点类似：
	- 前端的内存状态（React state、Zustand store）；
	- 再加上一整套高性能的数据结构：字符串、列表、哈希、集合、有序集合等。

它们之间的分工可以简单理解为：

- **MySQL**：我要一份“永远不会丢”的正式存档版本；
- **Redis**：我要一份“最近很常用”的数据副本，放在离 CPU 最近的地方，方便快速读取。

所以很多高并发系统的读请求路径其实是：

```text
客户端 → Nginx → 应用服务 → Redis（命中直接返回）
															 ↓ 未命中
														MySQL → 回写 Redis → 返回
```

接下来我们先在项目中接入 Redis 客户端，写一个最小示例，然后再把它用到文章详情的缓存上。

### 1.1 Redis 快速入门：它不只是 Key-Value

很多同学第一次听 Redis，会以为它只有 `key -> value`。

实际上 Redis 提供了多种数据结构（这也是它“能做很多事”的原因）：

| 数据结构 | 典型用途 | 例子（类比前端） |
|---------|---------|------------------|
| String | 缓存一个 JSON、计数器 | `localStorage.setItem(key, JSON.stringify(obj))` |
| Hash | 存对象字段（用户信息、配置） | JS 对象的 key/value |
| List | 队列、消息列表 | 数组 push/pop（但在 Redis 侧） |
| Set | 去重（点赞用户集合） | `new Set()` |
| ZSet | 排行榜（分数 + 排序） | “按 score 排序的列表” |

你不需要一次学完所有结构，但至少要知道：

- Redis 不止能做缓存；
- 选择合适的数据结构，性能和表达能力都会更好。

### 1.2 为什么 Redis 这么快？（你只要记住 3 点）

1. **内存访问**：数据主要在内存里，避免磁盘 I/O；
2. **高效的数据结构**：很多操作是 O(1) 或接近 O(1)；
3. **事件循环模型**：Redis 处理命令的模型很清晰，吞吐高（你可以把它想象成“服务端的高性能事件循环”）。

### 1.3 TTL：为什么缓存一定要过期？

缓存如果“永不过期”，你会遇到两个问题：

1. 数据可能变旧（用户改昵称了，但你一直读旧值）；
2. Redis 内存有限，不控制会被塞满。

所以缓存通常会设置 TTL（过期时间）：

- 热点数据：TTL 可以短一些（比如 5-10 分钟），保证新鲜；
- 不常变数据：TTL 可以长一些（比如 1 小时 / 1 天）；
- 关键点：**一定要有“失效策略”**，否则迟早出问题。

### 1.4 淘汰策略（了解即可）

当 Redis 内存不够时，会根据配置的淘汰策略删除部分 key（比如 LRU/LFU 等）。

基础篇你只要知道：

- Redis 不是无限大；
- 线上要监控内存、命中率、慢查询；
- 缓存 key 的设计和 TTL 策略同样重要。

## 2. Redis 初始化

我们使用 `go-redis` 作为 Redis 客户端库。

安装：

```bash
go get github.com/redis/go-redis/v9
```

创建 `pkg/cache/redis.go`：

```go
package cache

import (
	"context"
	"time"

	"github.com/redis/go-redis/v9"
)

var RDB *redis.Client
var Ctx = context.Background()

func InitRedis() {
	RDB = redis.NewClient(&redis.Options{
		Addr:     config.AppConfig.Redis.Addr, // 从配置读取
		Password: "",
		DB:       0,
		PoolSize: 100,
	})

	_, err := RDB.Ping(Ctx).Result()
	if err != nil {
		panic(err)
	}
}

> 如果你还没有在 `configs/config.yaml` 里加 Redis 配置，可以先加一个最小版本：
>
> ```yaml
> redis:
>   addr: "127.0.0.1:6379"
>   password: ""
>   db: 0
> ```
>
> 然后在 config 结构体里增加对应字段（第 1 章已经讲过 Viper 的配置映射）。
```

## 3. Cache-Aside 模式实战

**读取逻辑**：先查缓存 -> 命中则返回 -> 未命中查数据库 -> 写入缓存 -> 返回。
**更新逻辑**：先更新数据库 -> 删除缓存 (Delete Cache)。

### 3.1 封装 ArticleService

修改 `internal/service/article_service.go`，为文章详情页添加缓存。

```go
import (
	"encoding/json"
	"fmt"
	"go-blog-api/pkg/cache"
	"time"
)

func (s *ArticleService) GetArticle(id int) (*model.Article, error) {
	cacheKey := fmt.Sprintf("article:%d", id)

	// 1. 查缓存：先从 Redis 里看看有没有这篇文章
	val, err := cache.RDB.Get(cache.Ctx, cacheKey).Result()
	if err == nil {
		// 缓存命中：直接反序列化返回，完全不访问数据库
		var article model.Article
		json.Unmarshal([]byte(val), &article)
		return &article, nil
	}

	// 2. 查数据库：只有缓存未命中时才访问 MySQL
	article, err := s.articleRepo.GetByID(id)
	if err != nil {
		return nil, err
	}

	// 3. 写缓存 (设置过期时间，防止雪崩)
	data, _ := json.Marshal(article)
	cache.RDB.Set(cache.Ctx, cacheKey, data, 10*time.Minute)

	return article, nil
}
```

## 4. 缓存三大问题与解决方案

### 4.1 缓存穿透 (Cache Penetration)

**现象**：查询一个**根本不存在**的数据（如 ID=-1）。缓存不命中，数据库也不命中，导致每次请求都打到数据库。
**解决**：
1.  **缓存空值**：如果数据库没查到，也在 Redis 存一个 `null`，过期时间设置短一点（如 1 分钟）。
2.  **布隆过滤器 (Bloom Filter)**：在请求到达 Redis 前先判断 ID 是否存在。

### 4.2 缓存击穿 (Cache Breakdown)

**现象**：一个**热点 Key**（如微博热搜）突然过期，此时大量并发请求同时打过来，瞬间击垮数据库。
**解决**：
1.  **互斥锁 (Mutex)**：在查数据库前先抢锁，抢不到的等待。
2.  **逻辑过期**：永不过期，在 Value 里存一个过期时间，异步更新。

**使用 `singleflight` 解决击穿**：
Go 标准库 `golang.org/x/sync/singleflight` 是解决击穿的神器。它能让同时到来的 1000 个请求只执行一次数据库查询，共享结果。

```go
import "golang.org/x/sync/singleflight"

var g singleflight.Group

func (s *ArticleService) GetArticleSafe(id int) (*model.Article, error) {
    // ... 查缓存逻辑 ...

    // 使用 SingleFlight 合并请求
    v, err, _ := g.Do(fmt.Sprintf("article_%d", id), func() (interface{}, error) {
        // 这里是真正的查库逻辑
        return s.articleRepo.GetByID(id)
    })
    
    if err != nil {
        return nil, err
    }
    
    // ... 写缓存逻辑 ...
    return v.(*model.Article), nil
}
```

### 4.3 缓存雪崩 (Cache Avalanche)

**现象**：大量 Key 在**同一时间过期**，或者 Redis 宕机。
**解决**：
1.  **随机过期时间**：在原有的过期时间上加一个随机值（如 1-5 分钟），让过期时间分散开。
2.  **高可用**：Redis Sentinel 或 Cluster。

```go
// 随机过期时间
expiration := 10*time.Minute + time.Duration(rand.Intn(300))*time.Second
cache.RDB.Set(cache.Ctx, cacheKey, data, expiration)
```

## 5. 分布式锁 (Distributed Lock)

在前面的章节中，我们用数据库事务保证了积分更新的原子性。但在分布式系统中（多台服务器），我们需要分布式锁。

Redis 实现分布式锁的核心命令：`SETNX` (Set if Not Exists)。

```go
func AcquireLock(key string, ttl time.Duration) bool {
	ok, err := cache.RDB.SetNX(cache.Ctx, key, "1", ttl).Result()
	return err == nil && ok
}

func ReleaseLock(key string) {
	cache.RDB.Del(cache.Ctx, key)
}
```

**注意**：生产环境建议使用 `redsync` 库，它实现了 Redlock 算法，更安全。

## 6. 本章小结与练习

本章我们从“前端缓存”的类比出发，构建了一个更贴近真实高并发场景的服务端缓存体系：

1. **认识 Redis**：
	- 理解了 Redis 和 MySQL 在系统中的分工：一个负责“真相存档”，一个负责“高性能副本”；
	- 使用 `go-redis` 初始化了 Redis 客户端，为后续模块提供基础能力。
2. **Cache-Aside 模式**：
	- 明确了典型的读写路径：先查缓存，再查数据库，最后回写缓存；
	- 在 `ArticleService.GetArticle` 中实现了文章详情的缓存逻辑。
3. **三大缓存问题**：
	- 缓存穿透：针对不存在的数据频繁打到数据库；
	- 缓存击穿：热点 Key 过期瞬间引发的流量洪峰；
	- 缓存雪崩：大量 Key 在同一时间过期或 Redis 故障导致的系统压力骤增；
	- 并分别给出了空值缓存、singleflight、随机过期时间等解决方案。
4. **分布式锁**：
	- 使用 Redis 的 `SETNX` 实现了最基础的分布式锁；
	- 为后续更复杂的并发控制（如库存扣减、幂等控制）打下基础。

### 贯穿任务线（本章验收：缓存能带来可观察的收益）

- [ ] 本地 Redis 可用（Docker/本机皆可），服务启动能成功连接
- [ ] 已对“文章详情”做了 Cache-Aside：第一次请求查库，后续命中缓存
- [ ] 缓存 Key 设计稳定（包含文章 ID），并设置了合理 TTL
- [ ] 至少覆盖一个“缓存问题”策略：缓存空值 / singleflight / 随机过期
- [ ] 你能用日志或简单压测对比出：有缓存时平均耗时下降或 DB 查询次数减少

### 推荐练习

1. 为文章列表接口增加缓存：
	- 按照 `GetArticle` 的思路，为列表查询实现 Cache-Aside；
	- 思考分页参数（page/size）对缓存 Key 设计的影响。
2. 实现“缓存空值”策略：
	- 当数据库中不存在某篇文章时，在 Redis 中缓存一个特殊标记并设置较短过期时间；
	- 验证在高频访问不存在 ID 时数据库压力是否明显下降。
3. 尝试在本地压测：
	- 使用简单的脚本或工具（如 `ab`、`wrk`）对有/无缓存的接口进行压力测试；
	- 观察在 QPS 较高时，接口响应时间和 MySQL 连接数的差异。

**下一章预告**：
有些任务不需要实时处理（如：发送注册邮件、统计报表）。下一章我们将引入 **RabbitMQ** 消息队列，实现业务的**解耦**和**异步处理**，继续从“性能”和“稳定性”的角度进化我们的博客系统。
