---
title: "性能：Redis 缓存策略与高并发"
description: "提升系统性能的关键。引入 Redis 实现 Cache-Aside 缓存模式。深入探讨缓存穿透、缓存击穿与缓存雪崩的解决方案，以及使用 Redis 实现分布式锁。"
date: "2025-12-09"
seriesOrder: 7
---

# 7. 性能：Redis 缓存策略与高并发

## 引言

当你的博客访问量从 100 涨到 100 万时，MySQL 就会成为瓶颈。
**Redis** 是后端性能优化的第一把瑞士军刀。

本章我们将实现经典的 **Cache-Aside (旁路缓存)** 模式，并解决高并发下常见的缓存三大问题：**穿透、击穿、雪崩**。

## 1. Redis 初始化

安装 Redis 客户端库 `go-redis`：

```bash
go get github.com/redis/go-redis/v9
```

创建 `pkg/cache/redis.go`：

```go
package cache

import (
	"context"
	"go-blog-api/pkg/config"
	"time"

	"github.com/redis/go-redis/v9"
)

var RDB *redis.Client
var Ctx = context.Background()

func InitRedis() {
	RDB = redis.NewClient(&redis.Options{
		Addr:     "localhost:6379", // 实际应从 config 读取
		Password: "",
		DB:       0,
		PoolSize: 100,
	})

	_, err := RDB.Ping(Ctx).Result()
	if err != nil {
		panic(err)
	}
}
```

## 2. Cache-Aside 模式实战

**读取逻辑**：先查缓存 -> 命中则返回 -> 未命中查数据库 -> 写入缓存 -> 返回。
**更新逻辑**：先更新数据库 -> 删除缓存 (Delete Cache)。

### 2.1 封装 ArticleService

修改 `internal/service/article_service.go`，为文章详情页添加缓存。

```go
import (
	"encoding/json"
	"fmt"
	"go-blog-api/pkg/cache"
	"time"
)

func (s *ArticleService) GetArticle(id int) (*model.Article, error) {
	cacheKey := fmt.Sprintf("article:%d", id)

	// 1. 查缓存
	val, err := cache.RDB.Get(cache.Ctx, cacheKey).Result()
	if err == nil {
		// 缓存命中
		var article model.Article
		json.Unmarshal([]byte(val), &article)
		return &article, nil
	}

	// 2. 查数据库
	article, err := s.articleRepo.GetByID(id)
	if err != nil {
		return nil, err
	}

	// 3. 写缓存 (设置过期时间，防止雪崩)
	data, _ := json.Marshal(article)
	cache.RDB.Set(cache.Ctx, cacheKey, data, 10*time.Minute)

	return article, nil
}
```

## 3. 缓存三大问题与解决方案

### 3.1 缓存穿透 (Cache Penetration)

**现象**：查询一个**根本不存在**的数据（如 ID=-1）。缓存不命中，数据库也不命中，导致每次请求都打到数据库。
**解决**：
1.  **缓存空值**：如果数据库没查到，也在 Redis 存一个 `null`，过期时间设置短一点（如 1 分钟）。
2.  **布隆过滤器 (Bloom Filter)**：在请求到达 Redis 前先判断 ID 是否存在。

### 3.2 缓存击穿 (Cache Breakdown)

**现象**：一个**热点 Key**（如微博热搜）突然过期，此时大量并发请求同时打过来，瞬间击垮数据库。
**解决**：
1.  **互斥锁 (Mutex)**：在查数据库前先抢锁，抢不到的等待。
2.  **逻辑过期**：永不过期，在 Value 里存一个过期时间，异步更新。

**使用 `singleflight` 解决击穿**：
Go 标准库 `golang.org/x/sync/singleflight` 是解决击穿的神器。它能让同时到来的 1000 个请求只执行一次数据库查询，共享结果。

```go
import "golang.org/x/sync/singleflight"

var g singleflight.Group

func (s *ArticleService) GetArticleSafe(id int) (*model.Article, error) {
    // ... 查缓存逻辑 ...

    // 使用 SingleFlight 合并请求
    v, err, _ := g.Do(fmt.Sprintf("article_%d", id), func() (interface{}, error) {
        // 这里是真正的查库逻辑
        return s.articleRepo.GetByID(id)
    })
    
    if err != nil {
        return nil, err
    }
    
    // ... 写缓存逻辑 ...
    return v.(*model.Article), nil
}
```

### 3.3 缓存雪崩 (Cache Avalanche)

**现象**：大量 Key 在**同一时间过期**，或者 Redis 宕机。
**解决**：
1.  **随机过期时间**：在原有的过期时间上加一个随机值（如 1-5 分钟），让过期时间分散开。
2.  **高可用**：Redis Sentinel 或 Cluster。

```go
// 随机过期时间
expiration := 10*time.Minute + time.Duration(rand.Intn(300))*time.Second
cache.RDB.Set(cache.Ctx, cacheKey, data, expiration)
```

## 4. 分布式锁 (Distributed Lock)

在前面的章节中，我们用数据库事务保证了积分更新的原子性。但在分布式系统中（多台服务器），我们需要分布式锁。

Redis 实现分布式锁的核心命令：`SETNX` (Set if Not Exists)。

```go
func AcquireLock(key string, ttl time.Duration) bool {
	ok, err := cache.RDB.SetNX(cache.Ctx, key, "1", ttl).Result()
	return err == nil && ok
}

func ReleaseLock(key string) {
	cache.RDB.Del(cache.Ctx, key)
}
```

**注意**：生产环境建议使用 `redsync` 库，它实现了 Redlock 算法，更安全。

## 5. 总结

本章我们完成了：
1.  **Redis 集成**：实现了基础的 KV 读写。
2.  **Cache-Aside**：实现了标准的缓存读写策略。
3.  **高并发防护**：引入 `singleflight` 解决缓存击穿，使用随机过期时间防止雪崩。

**下一章预告**：
有些任务不需要实时处理（如：发送注册邮件、统计报表）。下一章我们将引入 **RabbitMQ** 消息队列，实现业务的**解耦**和**异步处理**。
