---
title: "实战一：角色与菜单权限管理"
description: "实现 RBAC 的核心管理功能。编写递归算法将扁平菜单数据转换为树形结构，对接前端 Ant Design 的 Tree 组件。实现角色创建与权限分配接口。"
date: "2025-12-15"
seriesOrder: 13
---

# 13. 实战一：角色与菜单权限管理

## 引言

在 RBAC 系统中，**菜单 (Menu)** 和 **角色 (Role)** 是权限的载体。
前端页面（如 Ant Design Pro）的侧边栏菜单通常需要一个**树形结构 (Tree)** 的 JSON 数据，而我们的数据库存储的是**扁平结构 (Flat)**（通过 `parent_id` 关联）。

本章我们将重点攻克两个难点：
1.  **树形结构转换**：在 Go 中高效地将扁平切片转换为树形切片。
2.  **权限分配**：如何优雅地处理角色与菜单的多对多关系更新。

## 1. 菜单管理：从扁平到树形

### 1.1 定义响应结构

前端需要的树形结构通常长这样：

```json
[
  {
    "id": 1,
    "title": "系统管理",
    "children": [
      { "id": 2, "title": "用户管理" },
      { "id": 3, "title": "角色管理" }
    ]
  }
]
```

我们在 `internal/model/menu.go` 中已经定义了 `Children []*Menu` 字段（带 `gorm:"-"`），现在派上用场了。

### 1.2 编写转换算法

在 JS 中，我们常用 `reduce` 或递归来做 arrayToTree。在 Go 中，利用 **Map** 可以实现 O(n) 时间复杂度的转换。

创建 `pkg/util/tree.go`：

```go
package util

import "go-blog-api/internal/model"

// BuildMenuTree 将扁平的菜单列表转换为树形结构
func BuildMenuTree(menus []*model.Menu) []*model.Menu {
	// 1. 创建 ID -> Node 的映射
	nodeMap := make(map[uint]*model.Menu)
	for _, menu := range menus {
		// 初始化 Children 为空切片，防止 JSON 输出 null
		menu.Children = []*model.Menu{}
		nodeMap[menu.ID] = menu
	}

	// 2. 组装树
	var root []*model.Menu
	for _, menu := range menus {
		// 如果是根节点 (ParentID == 0)
		if menu.ParentID == 0 {
			root = append(root, menu)
			continue
		}

		// 如果有父节点，挂载到父节点的 Children 下
		if parent, ok := nodeMap[menu.ParentID]; ok {
			parent.Children = append(parent.Children, menu)
		}
	}

	return root
}
```

### 1.3 实现菜单列表接口

在 `internal/service/menu_service.go` 中：

```go
func (s *MenuService) GetMenuTree() ([]*model.Menu, error) {
	var menus []*model.Menu
	// 查询所有菜单，按 Sort 排序
	if err := s.db.Order("sort").Find(&menus).Error; err != nil {
		return nil, err
	}

	return util.BuildMenuTree(menus), nil
}
```

在 Controller 中暴露接口 `GET /api/v1/menus`。

## 2. 角色管理：权限分配

角色管理的核心是**给角色分配菜单**。这涉及到更新 `sys_role_menus` 中间表。

### 2.1 创建/更新角色

GORM 的 `Association` 方法让多对多更新变得非常简单。

在 `internal/service/role_service.go` 中：

```go
type RoleRequest struct {
	Name    string `json:"name" binding:"required"`
	NameZh  string `json:"name_zh" binding:"required"`
	MenuIDs []uint `json:"menu_ids"` // 前端传来的菜单 ID 列表
}

func (s *RoleService) CreateRole(req *RoleRequest) error {
	return db.DB.Transaction(func(tx *gorm.DB) error {
		// 1. 创建角色基本信息
		role := model.Role{
			Name:   req.Name,
			NameZh: req.NameZh,
		}
		if err := tx.Create(&role).Error; err != nil {
			return err
		}

		// 2. 关联菜单
		if len(req.MenuIDs) > 0 {
			// 构造 Menu 对象切片 (只需要 ID)
			var menus []model.Menu
			for _, id := range req.MenuIDs {
				menus = append(menus, model.Menu{BaseModel: model.BaseModel{ID: id}})
			}
			
			// GORM 会自动向中间表插入记录
			if err := tx.Model(&role).Association("Menus").Replace(menus); err != nil {
				return err
			}
		}
		return nil
	})
}

func (s *RoleService) UpdateRole(id uint, req *RoleRequest) error {
	return db.DB.Transaction(func(tx *gorm.DB) error {
		var role model.Role
		if err := tx.First(&role, id).Error; err != nil {
			return err
		}

		// 1. 更新基本信息
		role.Name = req.Name
		role.NameZh = req.NameZh
		if err := tx.Save(&role).Error; err != nil {
			return err
		}

		// 2. 更新菜单关联 (Replace 会先删除旧关联，再插入新关联)
		var menus []model.Menu
		for _, mid := range req.MenuIDs {
			menus = append(menus, model.Menu{BaseModel: model.BaseModel{ID: mid}})
		}
		
		return tx.Model(&role).Association("Menus").Replace(menus)
	})
}
```

### 2.2 获取角色的菜单 ID

前端在编辑角色时，需要回显该角色已有的权限。

```go
func (s *RoleService) GetRoleMenuIDs(roleID uint) ([]uint, error) {
	var role model.Role
	// Preload 加载关联的 Menus
	if err := s.db.Preload("Menus").First(&role, roleID).Error; err != nil {
		return nil, err
	}

	var ids []uint
	for _, menu := range role.Menus {
		ids = append(ids, menu.ID)
	}
	return ids, nil
}
```

## 3. 获取当前用户的菜单树

这是前端最关键的接口：用户登录后，侧边栏显示什么菜单？

逻辑：
1.  根据 UserID 查出用户拥有的所有 Roles。
2.  根据 Roles 查出所有 Menus (去重)。
3.  将 Menus 转换为 Tree。

```go
func (s *UserService) GetUserMenus(userID uint) ([]*model.Menu, error) {
	var user model.User
	
	// 多级 Preload: User -> Roles -> Menus
	if err := s.db.Preload("Roles.Menus").First(&user, userID).Error; err != nil {
		return nil, err
	}

	// 去重 (因为不同角色可能拥有相同的菜单)
	menuMap := make(map[uint]*model.Menu)
	for _, role := range user.Roles {
		for _, menu := range role.Menus {
			// 过滤掉按钮类型的权限 (type=3)，只保留目录和菜单
			if menu.Type != 3 {
				menuMap[menu.ID] = menu
			}
		}
	}

	var menus []*model.Menu
	for _, m := range menuMap {
		menus = append(menus, m)
	}

	// 排序 (可选，建议在 SQL 或内存中按 Sort 字段排序)
	// ...

	return util.BuildMenuTree(menus), nil
}
```

## 4. 总结

本章我们完成了 RBAC 的管理后台功能：
1.  **树形转换**：实现了 O(n) 复杂度的 `BuildMenuTree` 算法，完美对接前端组件。
2.  **关联更新**：利用 GORM 的 `Association().Replace()` 轻松处理了复杂的中间表更新。
3.  **动态菜单**：实现了根据用户角色动态计算侧边栏菜单的逻辑。

**下一章预告**：
现在我们只是在数据库里记录了"谁有什么权限"，但 API 接口本身还没有受到保护。下一章我们将引入强大的 **Casbin** 权限引擎，编写中间件，实现**基于角色的 API 访问控制**。
