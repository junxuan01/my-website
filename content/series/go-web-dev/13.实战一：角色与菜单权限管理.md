---
title: "实战一：角色与菜单权限管理"
description: "实现 RBAC 的核心管理功能。编写递归算法将扁平菜单数据转换为树形结构，对接前端 Ant Design 的 Tree 组件。实现角色创建与权限分配接口。"
date: "2025-12-15"
seriesOrder: 13
---

# 13. 实战一：角色与菜单权限管理

## 引言

在 RBAC 系统中，**菜单 (Menu)** 和 **角色 (Role)** 是权限的载体。

如果你写过前端的管理后台，一定对"侧边栏菜单"不陌生：

```tsx
// Ant Design Pro 的菜单配置
const menuData = [
  {
    path: '/system',
    name: '系统管理',
    icon: 'setting',
    children: [
      { path: '/system/users', name: '用户管理' },
      { path: '/system/roles', name: '角色管理' },
    ],
  },
];
```

前端需要的是这种**树形结构 (Tree)** 的 JSON 数据，但我们在数据库里存的是**扁平结构 (Flat)**——每行一条记录，通过 `parent_id` 关联父级。

本章我们将重点攻克两个难点：

1. **树形结构转换**：在 Go 中高效地将扁平切片转换为树形切片。
2. **权限分配**：如何优雅地处理角色与菜单的多对多关系更新。

### 本章目标

学完这一章，你将能够：

1. 理解数据库"扁平存储"和前端"树形渲染"的差异，以及为什么要在后端做转换；
2. 用 Go 实现 O(n) 时间复杂度的 `arrayToTree` 算法；
3. 使用 GORM 的 `Association` 方法更新多对多关系；
4. 实现"获取当前用户菜单"接口，让前端侧边栏能动态渲染。

## 1. 菜单管理：从扁平到树形

### 1.1 理解数据结构的差异

先来看一下数据库里存的"扁平结构"长什么样：

```
| id | parent_id | title      | path          |
|----|-----------|------------|---------------|
| 1  | 0         | 系统管理    | /system       |
| 2  | 1         | 用户管理    | /system/users |
| 3  | 1         | 角色管理    | /system/roles |
| 4  | 0         | 内容管理    | /content      |
| 5  | 4         | 文章管理    | /content/articles |
```

`parent_id = 0` 表示顶级菜单，`parent_id = 1` 表示父级是 id=1 的菜单。

而前端需要的是这种嵌套的树形结构：

```json
[
  {
    "id": 1,
    "title": "系统管理",
    "path": "/system",
    "children": [
      { "id": 2, "title": "用户管理", "path": "/system/users", "children": [] },
      { "id": 3, "title": "角色管理", "path": "/system/roles", "children": [] }
    ]
  },
  {
    "id": 4,
    "title": "内容管理",
    "path": "/content",
    "children": [
      { "id": 5, "title": "文章管理", "path": "/content/articles", "children": [] }
    ]
  }
]
```

### 1.2 为什么在后端转换？

你可能会想："前端也能写 `arrayToTree`，为什么要后端做？"

几个原因：

1. **数据量**：如果菜单有几百上千条，前端每次加载都要做一遍转换，浪费性能；
2. **复用**：移动端 App、小程序也需要菜单数据，不可能每个端都写一遍转换逻辑；
3. **权限过滤**：后端可以在查询时就过滤掉用户没有权限的菜单，前端拿到的就是"干净"的数据。

### 1.3 定义响应结构

我们在 `internal/model/menu.go` 中已经定义了 `Children []*Menu` 字段（带 `gorm:"-"` 表示不映射到数据库），现在派上用场了。

### 1.4 编写转换算法

在 JavaScript 中，我们常用 `reduce` 或递归来做 `arrayToTree`。在 Go 中，我们用 **Map** 来实现 O(n) 时间复杂度的转换。

> **算法思路**（和 JS 版本完全一样）：
> 
> 1. 第一次遍历：建立 `id -> 节点` 的映射表；
> 2. 第二次遍历：把每个节点挂到它父节点的 `children` 下；
> 3. 最后返回所有 `parent_id = 0` 的节点（它们是根节点）。

创建 `pkg/util/tree.go`：

```go
package util

import "go-blog-api/internal/model"

// BuildMenuTree 将扁平的菜单列表转换为树形结构
// 时间复杂度 O(n)，空间复杂度 O(n)
func BuildMenuTree(menus []*model.Menu) []*model.Menu {
	// 1. 创建 ID -> Node 的映射
	nodeMap := make(map[uint]*model.Menu)
	for _, menu := range menus {
		// 初始化 Children 为空切片，防止 JSON 输出 null
		menu.Children = []*model.Menu{}
		nodeMap[menu.ID] = menu
	}

	// 2. 组装树
	var root []*model.Menu
	for _, menu := range menus {
		// 如果是根节点 (ParentID == 0)
		if menu.ParentID == 0 {
			root = append(root, menu)
			continue
		}

		// 如果有父节点，挂载到父节点的 Children 下
		if parent, ok := nodeMap[menu.ParentID]; ok {
			parent.Children = append(parent.Children, menu)
		}
	}

	return root
}
```

**和 JS 版本对比**：

```javascript
// JavaScript 版本
function arrayToTree(items) {
  const map = {};
  const root = [];
  
  items.forEach(item => {
    map[item.id] = { ...item, children: [] };
  });
  
  items.forEach(item => {
    if (item.parentId === 0) {
      root.push(map[item.id]);
    } else if (map[item.parentId]) {
      map[item.parentId].children.push(map[item.id]);
    }
  });
  
  return root;
}
```

思路完全一样，只是语法不同。

### 1.3 实现菜单列表接口

在 `internal/service/menu_service.go` 中：

```go
func (s *MenuService) GetMenuTree() ([]*model.Menu, error) {
	var menus []*model.Menu
	// 查询所有菜单，按 Sort 排序
	if err := s.db.Order("sort").Find(&menus).Error; err != nil {
		return nil, err
	}

	return util.BuildMenuTree(menus), nil
}
```

在 Controller 中暴露接口 `GET /api/v1/menus`。

## 2. 角色管理：权限分配

角色管理的核心是**给角色分配菜单**。这涉及到更新 `sys_role_menus` 中间表。

### 2.1 创建/更新角色

GORM 的 `Association` 方法让多对多更新变得非常简单。

在 `internal/service/role_service.go` 中：

```go
type RoleRequest struct {
	Name    string `json:"name" binding:"required"`
	NameZh  string `json:"name_zh" binding:"required"`
	MenuIDs []uint `json:"menu_ids"` // 前端传来的菜单 ID 列表
}

func (s *RoleService) CreateRole(req *RoleRequest) error {
	return db.DB.Transaction(func(tx *gorm.DB) error {
		// 1. 创建角色基本信息
		role := model.Role{
			Name:   req.Name,
			NameZh: req.NameZh,
		}
		if err := tx.Create(&role).Error; err != nil {
			return err
		}

		// 2. 关联菜单
		if len(req.MenuIDs) > 0 {
			// 构造 Menu 对象切片 (只需要 ID)
			var menus []model.Menu
			for _, id := range req.MenuIDs {
				menus = append(menus, model.Menu{BaseModel: model.BaseModel{ID: id}})
			}
			
			// GORM 会自动向中间表插入记录
			if err := tx.Model(&role).Association("Menus").Replace(menus); err != nil {
				return err
			}
		}
		return nil
	})
}

func (s *RoleService) UpdateRole(id uint, req *RoleRequest) error {
	return db.DB.Transaction(func(tx *gorm.DB) error {
		var role model.Role
		if err := tx.First(&role, id).Error; err != nil {
			return err
		}

		// 1. 更新基本信息
		role.Name = req.Name
		role.NameZh = req.NameZh
		if err := tx.Save(&role).Error; err != nil {
			return err
		}

		// 2. 更新菜单关联 (Replace 会先删除旧关联，再插入新关联)
		var menus []model.Menu
		for _, mid := range req.MenuIDs {
			menus = append(menus, model.Menu{BaseModel: model.BaseModel{ID: mid}})
		}
		
		return tx.Model(&role).Association("Menus").Replace(menus)
	})
}
```

### 2.2 获取角色的菜单 ID

前端在编辑角色时，需要回显该角色已有的权限。

```go
func (s *RoleService) GetRoleMenuIDs(roleID uint) ([]uint, error) {
	var role model.Role
	// Preload 加载关联的 Menus
	if err := s.db.Preload("Menus").First(&role, roleID).Error; err != nil {
		return nil, err
	}

	var ids []uint
	for _, menu := range role.Menus {
		ids = append(ids, menu.ID)
	}
	return ids, nil
}
```

## 3. 获取当前用户的菜单树

这是前端最关键的接口：用户登录后，侧边栏显示什么菜单？

逻辑：
1.  根据 UserID 查出用户拥有的所有 Roles。
2.  根据 Roles 查出所有 Menus (去重)。
3.  将 Menus 转换为 Tree。

```go
func (s *UserService) GetUserMenus(userID uint) ([]*model.Menu, error) {
	var user model.User
	
	// 多级 Preload: User -> Roles -> Menus
	if err := s.db.Preload("Roles.Menus").First(&user, userID).Error; err != nil {
		return nil, err
	}

	// 去重 (因为不同角色可能拥有相同的菜单)
	menuMap := make(map[uint]*model.Menu)
	for _, role := range user.Roles {
		for _, menu := range role.Menus {
			// 过滤掉按钮类型的权限 (type=3)，只保留目录和菜单
			if menu.Type != 3 {
				menuMap[menu.ID] = menu
			}
		}
	}

	var menus []*model.Menu
	for _, m := range menuMap {
		menus = append(menus, m)
	}

	// 排序 (可选，建议在 SQL 或内存中按 Sort 字段排序)
	// ...

	return util.BuildMenuTree(menus), nil
}
```

## 4. 本章小结与练习

这一章，我们完成了 RBAC 系统中"管理功能"的核心部分：

1. **扁平到树形的转换**：
   - 理解了数据库扁平存储和前端树形渲染的差异；
   - 用 Go 实现了 O(n) 复杂度的 `BuildMenuTree` 算法，思路和 JS 版的 `arrayToTree` 完全一致。

2. **角色权限分配**：
   - 使用 GORM 的 `Association().Replace()` 方法，优雅地处理了多对多关系的更新；
   - 更新时自动删除旧关联、插入新关联，不需要手动操作中间表。

3. **动态菜单接口**：
   - 实现了 `GetUserMenus`，根据用户的角色动态计算他能看到的菜单；
   - 前端拿到这个接口返回的树形数据，直接喂给 Ant Design 的 `Menu` 组件即可。

> **前端对接要点**：
> 
> - 登录成功后调用 `GET /api/v1/menus/me` 获取当前用户的菜单树；
> - 把返回的数据存到状态管理（Zustand / Redux / Context）里；
> - 侧边栏组件递归渲染这棵树，不需要任何额外转换。

### 思考题 / 练习

1. **实现菜单排序**：
   - 目前 `BuildMenuTree` 没有考虑排序，如果数据库里有 `sort` 字段，如何保证同级菜单按 `sort` 排序？
   - 提示：可以在组装树之前先对切片排序，或者在 SQL 查询时 `ORDER BY sort`。

2. **实现菜单的增删改查**：
   - 创建菜单：`POST /api/v1/menus`，接收 `parent_id`、`title`、`path` 等字段；
   - 删除菜单：`DELETE /api/v1/menus/:id`，注意如果有子菜单怎么处理（级联删除 or 禁止删除？）；
   - 更新菜单：`PUT /api/v1/menus/:id`。

3. **按钮权限接口**：
   - 目前 `GetUserMenus` 过滤掉了 `type=3`（按钮）的权限；
   - 新增一个接口 `GET /api/v1/permissions/me`，返回当前用户拥有的所有按钮权限标识（如 `['user:add', 'user:delete']`）；
   - 前端拿到这个列表，用于判断按钮是否显示。

> 下一章，我们将引入 **Casbin** 权限引擎，实现真正的 API 级别访问控制——不仅菜单不显示，接口也不能调用。
