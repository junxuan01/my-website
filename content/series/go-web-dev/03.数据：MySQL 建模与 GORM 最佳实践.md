---
title: "数据：MySQL 建模与 GORM 最佳实践"
description: "从前端的 JSON 思维切换到关系型数据库思维。设计 User、Article 等核心表结构，掌握 GORM 的模型定义、自动迁移与逻辑外键策略。"
date: "2025-12-05"
seriesOrder: 3
---

# 3. 数据：MySQL 建模与 GORM 最佳实践

## 引言

前端开发者习惯了 MongoDB 或 JSON 这种非结构化数据，往往觉得“存进去是什么，取出来就是什么”。

在前端项目里，你可能会直接把一整棵对象树塞进 localStorage、IndexedDB 或某个状态管理库里，结构怎么舒服怎么来。但在后端开发中，**关系型数据库 (RDBMS)** 依然是核心业务数据的首选。

**为什么后端更喜欢关系型数据库？**

想象你在管理一家公司的数据：

- **前端的 JSON 方式**：像把所有文件都扔进一个大柜子，需要什么翻什么；
- **关系型数据库**：像把数据分门别类放进标准化的抽屉柜，每个抽屉（表）有固定的格子（字段），方便查找、统计和校验。

这一章，我们要完成从"JSON 思维"到"关系型建模思维"的切换：

- 理解什么是数据库、表、字段、索引、外键；
- 设计博客系统中最核心的几张表（User / Article / Comment）；
- 明白为什么互联网公司里普遍**不建议用物理外键**，而是采用"逻辑外键"；
- 使用 Go 生态中最常用的 ORM 库 **GORM** 连接 MySQL，并完成自动建表；
- 体会"模型（Model）"这一层在整个架构中的角色。

> **本章目标**：
>
> - 理解数据库的基本概念（表、字段、索引、主键）；
> - 在本地启动一个 MySQL（或连接你已有的实例）；
> - 使用 GORM 成功连上数据库，并完成简单的自动迁移；
> - 定义 `User` / `Article` / `Comment` 三个基础模型；
> - 初步理解"逻辑外键"的理念，以及它和物理外键的区别。

## 0. 数据库快速入门

> **这一节是为没接触过数据库的前端同学准备的，有基础的可以跳过。**

### 0.1 什么是数据库？

**数据库 (Database)** = 有组织地存储数据的"仓库"。

前端类比：

- **localStorage/sessionStorage**：像一个简单的键值对小本本，数据量小、结构简单；
- **IndexedDB**：稍微复杂一点，可以建索引、查询；
- **MySQL 这类关系型数据库**：像一个大型的 Excel 文件管理系统，有多个工作表（表），每个工作表有固定的列（字段）。

### 0.2 核心概念

| 概念 | 解释 | 前端类比 |
|------|------|----------|
| **数据库 (Database)** | 数据的集合，通常一个项目一个库 | 一个项目的所有数据 |
| **表 (Table)** | 数据库中的一张二维表格 | Excel 中的一个 Sheet |
| **字段 (Column/Field)** | 表中的一列，有固定的类型 | Excel 的列（姓名、年龄等） |
| **记录 (Row/Record)** | 表中的一行数据 | Excel 的一行 |
| **主键 (Primary Key)** | 唯一标识一行数据的字段 | 数组中的 `id` 字段 |
| **索引 (Index)** | 加速查询的数据结构 | 书的目录 |
| **外键 (Foreign Key)** | 表与表之间的关联字段 | 数组中的 `userId` 引用另一个数组 |

### 0.3 表结构示例

假设我们有一个 `users` 表：

```
+----+----------+----------------------+---------------------+
| id | username | email                | created_at          |
+----+----------+----------------------+---------------------+
| 1  | junxuan  | junxuan@example.com  | 2025-12-01 10:00:00 |
| 2  | alice    | alice@example.com    | 2025-12-02 11:00:00 |
+----+----------+----------------------+---------------------+
```

- 每一**列**是一个字段（id、username、email...）；
- 每一**行**是一条记录；
- `id` 是主键，保证唯一性。

### 0.4 SQL 语言

操作数据库使用 **SQL (Structured Query Language)**：

```sql
-- 查询
SELECT * FROM users WHERE username = 'junxuan';

-- 插入
INSERT INTO users (username, email) VALUES ('bob', 'bob@example.com');

-- 更新
UPDATE users SET email = 'new@example.com' WHERE id = 1;

-- 删除
DELETE FROM users WHERE id = 2;
```

> **前端类比**：
> - `SELECT` ≈ 数组的 `.filter()` + `.find()`
> - `INSERT` ≈ 数组的 `.push()`
> - `UPDATE` ≈ 修改数组中某个对象的属性
> - `DELETE` ≈ 数组的 `.filter()` 排除某个元素

不过别担心，我们用的 **GORM** 会帮我们自动生成 SQL，大部分时候不需要手写。

## 1. 数据库设计哲学

### 1.1 关系型 vs 非关系型

先用你熟悉的前端场景来对比一下：

- **MongoDB / NoSQL**：
	- 很像“把整个组件树的 state 直接存成一坨 JSON”；
	- 结构灵活，字段随便加减，前期开发很爽；
	- 非常适合日志、配置、原型快速迭代等场景。
- **MySQL / 关系型数据库**：
	- 更像是“把数据拆成多个表单，每个表单有固定字段和类型”；
	- 需要一开始就认真设计表结构和字段约束；
	- 非常适合用户、订单、资金等**必须保证强一致性**的核心业务数据。

关系型数据库最大的特点是：

- 有严格的 Schema（表结构）；
- 支持事务（Transaction），保证数据的 **ACID 特性**：
	- **A 原子性**：要么都成功，要么都失败；
	- **C 一致性**：前后状态必须从一个合法状态变成另一个合法状态；
	- **I 隔离性**：多个事务之间互不影响；
	- **D 持久性**：提交后的数据不会因为宕机而丢失。

### 1.2 物理外键 vs 逻辑外键

在传统的数据库教材中，我们会通过 `FOREIGN KEY` 约束来保证数据完整性：

- 比如 `articles.user_id` 是 `users.id` 的外键；
- 如果删除了某个用户，要么禁止删除，要么级联删除这个用户的所有文章；
- 这些规则都由数据库来帮你检查。

这类我们称之为 **物理外键**。

但在高并发的互联网业务中，尤其是做大规模拆分和性能优化时，**我们通常会禁用物理外键**，原因主要有三：

1. **性能损耗**：
	- 每次插入/删除都要校验外键约束，数据库要多做一次检查；
	- 在写入非常频繁的场景（例如下单、写日志）会成为瓶颈。
2. **死锁风险**：
	- 多个事务在高并发下做级联更新/删除时，极容易互相等待锁，导致死锁；
	- 死锁一多，业务就会出现大量超时或失败请求。
3. **分库分表困难**：
	- 当数据量大到需要“按用户分库”、“按时间分表”时，跨库/跨表的物理外键基本失效；
	- 这时候多数团队会选择完全禁用物理外键，转而依赖应用层保证约束。

于是就有了 **逻辑外键** 这个概念：

> **我们仍然在表结构里保留类似 `user_id` 这样的字段，但不在数据库层面加 `FOREIGN KEY` 约束，而是在业务代码（Service 层）里主动校验和维护这些关系。**

比如：

- 创建文章前，先检查 `User` 是否存在；
- 删除用户前，先检查是否还有文章/评论，如果有就禁止删除或标记删除；
- 定期用任务脚本做“脏数据清理”，保证逻辑外键引用的目标存在。

这就是大部分互联网公司在 MySQL 建模时真实采用的策略。接下来我们会按这种思路来设计我们的模型。

## 2. 本地 MySQL 与 GORM 初始化

在写代码之前，需要先准备一个可以访问的 MySQL 实例。这里假设你使用的是本地开发环境（macOS）：

### 2.1 启动一个 MySQL 实例

> **前端同学提示**：如果你之前没用过 MySQL，这里有几种启动方式。

**方式一：使用 Docker（推荐）**

最简单的方式是用 Docker 快速启动一个 MySQL 容器：

```bash
docker run -d \
	--name go-blog-mysql \
	-e MYSQL_ROOT_PASSWORD=root \
	-e MYSQL_DATABASE=blog_db \
	-p 3306:3306 \
	mysql:8.0
```

**方式二：使用 Homebrew（macOS）**

```bash
# 安装
brew install mysql

# 启动服务
brew services start mysql

# 创建数据库
mysql -uroot -e "CREATE DATABASE blog_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;"
```

**方式三：使用云服务**

可以使用阿里云/腾讯云的免费数据库实例，或者 PlanetScale 这类专门给开发者的免费 MySQL 服务。

**验证连接**：

你可以用 GUI 工具连上数据库验证：

- **TablePlus** (macOS/Windows)
- **DBeaver** (跨平台)
- **MySQL Workbench** (官方工具)

连接信息：
- Host: `127.0.0.1`
- Port: `3306`
- User: `root`
- Password: `root`
- Database: `blog_db`

### 2.2 配置 DSN

DSN (Data Source Name) 是数据库连接字符串，格式如下：

```
用户名:密码@tcp(主机:端口)/数据库名?参数1=值1&参数2=值2
```

在 `configs/config.yaml` 中配置：

```yaml
database:
  dsn: "root:root@tcp(127.0.0.1:3306)/blog_db?charset=utf8mb4&parseTime=True&loc=Local"
```

**参数说明**：

| 参数 | 说明 |
|------|------|
| `charset=utf8mb4` | 使用 UTF-8 编码，支持 emoji 等特殊字符 |
| `parseTime=True` | 自动把 MySQL 的 DATETIME 转换成 Go 的 `time.Time` |
| `loc=Local` | 使用本地时区 |

### 2.2 安装 GORM 和 MySQL 驱动

> **什么是 ORM？**
>
> ORM (Object-Relational Mapping) = 对象关系映射。
>
> **前端类比**：
> - **不用 ORM**：就像你直接用 `fetch` 写原始 HTTP 请求；
> - **用 ORM**：就像你用 Axios 或 React Query，自动处理序列化、错误处理等。
>
> ORM 的作用是把"写 SQL"变成"调用方法"，比如：
> ```go
> // 不用 ORM：手写 SQL
> db.Exec("INSERT INTO users (username, email) VALUES (?, ?)", "junxuan", "xx@example.com")
>
> // 用 GORM：链式调用
> db.Create(&User{Username: "junxuan", Email: "xx@example.com"})
> ```

**GORM** 是 Go 语言中最流行的 ORM 库，特点：

- 链式 API，写起来优雅；
- 自动迁移（Auto Migrate）；
- 支持预加载（Preload）解决 N+1 问题；
- 支持钩子（Hook）、事务、软删除等高级特性。

安装 GORM 和 MySQL 驱动：

```bash
go get -u gorm.io/gorm
go get -u gorm.io/driver/mysql
```

### 2.3 创建数据库初始化模块

创建 `pkg/db/db.go`：

```go
package db

import (
	"go-blog-api/pkg/config"
	"log"
	"time"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

var DB *gorm.DB

func InitDB() {
	dsn := config.AppConfig.Database.DSN

	var err error
	DB, err = gorm.Open(mysql.Open(dsn), &gorm.Config{
		Logger: logger.Default.LogMode(logger.Info), // 开启 SQL 日志
	})
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}

	// 设置连接池
	sqlDB, err := DB.DB()
	if err != nil {
		log.Fatalf("Failed to get sql.DB: %v", err)
	}

	sqlDB.SetMaxIdleConns(10)           // 最大空闲连接数
	sqlDB.SetMaxOpenConns(100)          // 最大打开连接数
	sqlDB.SetConnMaxLifetime(time.Hour) // 连接最大存活时间
}
```

这里做了几件事：

- 使用 `gorm.Open` 建立和 MySQL 的连接；
- 开启了 SQL 日志，方便在开发阶段观察 ORM 生成的 SQL 语句；
- 配置了连接池（最大空闲连接数、最大连接数、连接最大存活时间）。

> 和前端类比：
> - 可以把 `DB *gorm.DB` 理解成一个“全局的数据库客户端实例”；
> - 就像你在前端封装一个 `axiosInstance` 一样，后续所有仓储（Repository）层都会复用它。

别忘了在 `cmd/server/main.go` 中调用 `db.InitDB()`，确保程序启动时先初始化数据库连接。

## 3. 定义模型 (Model)

我们将定义三个核心模型：`User` (用户), `Article` (文章), `Comment` (评论)。可以把它们理解成：

- `User`：登录用户，后面会和 JWT、权限等关联；
- `Article`：博客文章主体；
- `Comment`：文章下的评论。

你可以先在纸上或白板上简单画出它们之间的关系：

- 一个用户可以有多篇文章；
- 一篇文章可以有多条评论；
- 评论属于某篇文章，也属于某个用户。

接下来先创建一个公共基础模型，统一管理 ID 和时间字段。

创建 `internal/model/base.go`，定义公共字段：

```go
package model

import (
	"time"

	"gorm.io/gorm"
)

// BaseModel 替代 gorm.Model，使用更符合 JSON 风格的字段名
type BaseModel struct {
	ID        uint           `gorm:"primarykey" json:"id"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
	DeletedAt gorm.DeletedAt `gorm:"index" json:"-"` // 软删除，前端不可见
}
```

这相当于在所有表上都自动加上了：

- 自增主键 `id`；
- 创建时间 `created_at`；
- 更新时间 `updated_at`；
- 软删除标记 `deleted_at`（对应 GORM 的软删除机制）。

后续所有业务模型都可以“组合”这个 `BaseModel`，避免重复代码。

### 3.1 用户模型 (User)

创建 `internal/model/user.go`：

```go
package model

type User struct {
	BaseModel
	Username string `gorm:"type:varchar(100);uniqueIndex;not null" json:"username"`
	Password string `gorm:"type:varchar(255);not null" json:"-"` // 密码不返回给前端
	Email    string `gorm:"type:varchar(100);uniqueIndex" json:"email"`
	Avatar   string `gorm:"type:varchar(255)" json:"avatar"`
}
```

-   `uniqueIndex`: 唯一索引，防止用户名重复。
-   `json:"-"`: 极其重要！防止在序列化时把加密后的密码泄露给前端。

你可以在脑海里想象一条 `users` 表中的记录长这样：

| id | username | email                | avatar                          | created_at           |
|----|----------|----------------------|---------------------------------|----------------------|
| 1  | junxuan  | junxuan@example.com | https://example.com/avatar.png | 2025-12-05 12:00:00 |

`Password` 字段会以哈希形式存在数据库中，但不会通过接口返回给前端。

### 3.2 文章模型 (Article)

创建 `internal/model/article.go`：

```go
package model

type Article struct {
	BaseModel
	Title   string `gorm:"type:varchar(255);not null;index" json:"title"` // 标题加索引，方便搜索
	Content string `gorm:"type:longtext" json:"content"`
	UserID  uint   `gorm:"index;not null" json:"user_id"` // 逻辑外键
	User    User   `gorm:"foreignKey:UserID" json:"user,omitempty"` // 关联关系
}
```

这里有两个关键字段：

- `UserID`：
	- 这是一个普通的无符号整型字段，在数据库里会对应 `user_id` 列；
	- 我们加上 `index` 索引字段，方便根据用户查询文章；
	- 它承载的就是“逻辑外键”的角色 —— 代码层面保证这个 ID 对应的用户存在。
- `User`：
	- 这是 GORM 的“关联字段”；
	- 不会单独建一列，而是帮助 GORM 在查询时用 `JOIN` 或 `IN` 查询把用户信息一并查出；
	- 后续会通过 `Preload("User")` 的方式加载它。

### 3.3 评论模型 (Comment)（可选）

为了让博客系统更贴近真实场景，我们再简单定义一个 `Comment` 模型：

创建 `internal/model/comment.go`：

```go
package model

type Comment struct {
	BaseModel
	Content   string `gorm:"type:text;not null" json:"content"`
	ArticleID uint   `gorm:"index;not null" json:"article_id"`
	UserID    uint   `gorm:"index;not null" json:"user_id"`
}
```

这里我们暂时不加太多花活，先让它简单一点：只记录内容和所属的文章、用户。

### 3.4 自动迁移 (Auto Migrate)

GORM 的一大神器是自动迁移，它能根据 Struct 自动创建或更新数据库表结构。注意：

- 自动迁移适合开发/测试环境；
- 在线上环境通常会结合数据库迁移工具（例如 Flyway、Liquibase、golang-migrate 等），不会直接在业务代码里 `AutoMigrate`。

在这里，我们先用最简单的方式，让 GORM 自动帮我们创建几张基础表。

修改 `pkg/db/db.go`，添加迁移逻辑：

```go
// ... imports

// AutoMigrate 执行数据库迁移
func AutoMigrate(models ...interface{}) {
	if err := DB.AutoMigrate(models...); err != nil {
		log.Fatalf("Database migration failed: %v", err)
	}
}
```

在 `cmd/server/main.go` 中注册模型：

```go
// ...
import "go-blog-api/internal/model"

func main() {
    config.InitConfig()
    db.InitDB()
    
    // 自动迁移
	db.AutoMigrate(&model.User{}, &model.Article{}, &model.Comment{})
    
    // ...
}
```

## 4. 验证

运行程序：
```bash
go run cmd/server/main.go
```

查看 MySQL 数据库（可以使用 DBeaver、TablePlus 或命令行），你会发现 `users`、`articles`、`comments` 三张表已经自动创建好了，并且索引也建立完毕。

## 5. 本章小结与练习

本章我们完成了从“抽象的数据概念”到“落地到 MySQL 表结构”的第一步：

1. **数据库设计哲学**：
	- 对比了关系型数据库和非关系型数据库的适用场景；
	- 理解了为什么在互联网业务中往往不使用物理外键，而采用逻辑外键策略。
2. **GORM 初始化**：
	- 使用 `gorm.Open` 建立了和 MySQL 的连接；
	- 配置了基础的连接池和 SQL 日志输出。
3. **模型定义**：
	- 通过 `BaseModel` 统一了 ID 和时间字段；
	- 定义了 `User`、`Article`、`Comment` 三个核心模型；
	- 在 `Article` 中通过 `UserID` 和 `User` 字段体现了逻辑外键和关联查询的设计。
4. **自动迁移**：
	- 使用 `db.AutoMigrate` 自动创建/更新表结构，快速完成了开发环境的建表工作。

### 贯穿任务线（本章验收：数据库 + 模型落地）

- [ ] 本地 MySQL 可用（Docker/Homebrew/云都行），并已创建 `blog_db`
- [ ] `configs/config.yaml` 的 DSN 可用，服务启动能成功连接数据库（无连接报错）
- [ ] 已定义至少 `User`、`Article` 两个模型，并完成 `AutoMigrate`
- [ ] 你能在数据库客户端里看到表已创建（`users`/`articles`/`comments` 等）
- [ ] （可选但推荐）已经写了最小种子数据：启动后能插入 1 个用户 + 2 篇文章，供后续联调

### 推荐练习

1. 给 `Comment` 模型补充一个“父评论 ID”字段，实现简单的楼中楼结构：
	- 字段名可以为 `ParentID *uint`；
	- 重新运行 `AutoMigrate`，观察表结构变化。
2. 在 `User` 模型中增加一个 `Bio`（个人简介）字段：
	- 类型可以是 `text`；
	- 尝试插入一条包含多行文本的用户记录，观察 GORM 和 MySQL 如何处理。
3. 用 GORM 写一个最简单的种子数据脚本：
	- 在程序启动时检查 `users` 表是否为空；
	- 如果为空，则插入一条测试用户和几篇文章；
	- 后面章节可以直接用这些数据做联调。

**下一章预告**：
有了数据库和模型，我们就可以开始写真正的业务逻辑了。下一章我们将进入 **分层架构** 的核心，实现 **用户注册** 功能。你会看到 Controller 如何调用 Service，Service 如何调用 Repository，以及在这个过程中如何进行依赖注入，使代码更易测试和维护。
