---
title: "数据：MySQL 建模与 GORM 最佳实践"
description: "从前端的 JSON 思维切换到关系型数据库思维。设计 User、Article 等核心表结构，掌握 GORM 的模型定义、自动迁移与逻辑外键策略。"
date: "2025-12-05"
seriesOrder: 3
---

# 3. 数据：MySQL 建模与 GORM 最佳实践

## 引言

前端开发者习惯了 MongoDB 或 JSON 这种非结构化数据，往往觉得"存进去是什么，取出来就是什么"。但在后端开发中，**关系型数据库 (RDBMS)** 依然是核心业务数据的首选。

本章我们将为博客系统设计数据库模型，并使用 Go 语言中最强大的 ORM 库 —— **GORM** 来操作 MySQL。

我们将重点讨论一个在互联网大厂中非常流行的设计原则：**逻辑外键**。

## 1. 数据库设计哲学

### 1.1 关系型 vs 非关系型

-   **MongoDB (NoSQL)**: 适合存储日志、非结构化配置、快速迭代的原型。
-   **MySQL (SQL)**: 适合存储用户、订单、资金等核心业务数据。它保证了数据的**一致性 (ACID)**。

### 1.2 物理外键 vs 逻辑外键

在传统的数据库教材中，我们通过 `FOREIGN KEY` 约束来保证数据完整性（例如：删除了用户，必须级联删除该用户的所有文章）。

但在高并发的互联网业务中，我们通常**禁止使用物理外键**。

**为什么？**
1.  **性能损耗**：每次插入/删除都需要数据库去检查外键约束，影响写入性能。
2.  **死锁风险**：高并发下，级联更新容易引发数据库死锁。
3.  **分库分表困难**：一旦数据量大到需要分库，物理外键就失效了。

**解决方案：逻辑外键**
我们在代码层面（Service 层）去保证数据的完整性，而不是依赖数据库约束。

## 2. GORM 初始化

首先安装 GORM 和 MySQL 驱动：

```bash
go get -u gorm.io/gorm
go get -u gorm.io/driver/mysql
```

创建 `pkg/db/db.go`：

```go
package db

import (
	"go-blog-api/pkg/config"
	"log"
	"time"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

var DB *gorm.DB

func InitDB() {
	dsn := config.AppConfig.Database.DSN
	
	var err error
	DB, err = gorm.Open(mysql.Open(dsn), &gorm.Config{
		Logger: logger.Default.LogMode(logger.Info), // 开启 SQL 日志
	})
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}

	// 设置连接池
	sqlDB, err := DB.DB()
	if err != nil {
		log.Fatalf("Failed to get sql.DB: %v", err)
	}

	sqlDB.SetMaxIdleConns(10)           // 最大空闲连接数
	sqlDB.SetMaxOpenConns(100)          // 最大打开连接数
	sqlDB.SetConnMaxLifetime(time.Hour) // 连接最大存活时间
}
```

别忘了在 `cmd/server/main.go` 中调用 `db.InitDB()`。

## 3. 定义模型 (Model)

我们将定义三个核心模型：`User` (用户), `Article` (文章), `Comment` (评论)。

创建 `internal/model/base.go`，定义公共字段：

```go
package model

import (
	"time"

	"gorm.io/gorm"
)

// BaseModel 替代 gorm.Model，使用更符合 JSON 风格的字段名
type BaseModel struct {
	ID        uint           `gorm:"primarykey" json:"id"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
	DeletedAt gorm.DeletedAt `gorm:"index" json:"-"` // 软删除，前端不可见
}
```

### 3.1 用户模型 (User)

创建 `internal/model/user.go`：

```go
package model

type User struct {
	BaseModel
	Username string `gorm:"type:varchar(100);uniqueIndex;not null" json:"username"`
	Password string `gorm:"type:varchar(255);not null" json:"-"` // 密码不返回给前端
	Email    string `gorm:"type:varchar(100);uniqueIndex" json:"email"`
	Avatar   string `gorm:"type:varchar(255)" json:"avatar"`
}
```

-   `uniqueIndex`: 唯一索引，防止用户名重复。
-   `json:"-"`: 极其重要！防止在序列化时把加密后的密码泄露给前端。

### 3.2 文章模型 (Article)

创建 `internal/model/article.go`：

```go
package model

type Article struct {
	BaseModel
	Title   string `gorm:"type:varchar(255);not null;index" json:"title"` // 标题加索引，方便搜索
	Content string `gorm:"type:longtext" json:"content"`
	UserID  uint   `gorm:"index;not null" json:"user_id"` // 逻辑外键
	User    User   `gorm:"foreignKey:UserID" json:"user,omitempty"` // 关联关系
}
```

-   `UserID`: 这是一个普通的整型字段，我们加上 `index` 索引以加快查询速度。
-   `User`: 这是 GORM 的关联字段，用于查询时 `Preload` 用户信息。

### 3.3 自动迁移 (Auto Migrate)

GORM 的一大神器是自动迁移，它能根据 Struct 自动创建或更新数据库表结构。

修改 `pkg/db/db.go`，添加迁移逻辑：

```go
// ... imports

// AutoMigrate 执行数据库迁移
func AutoMigrate(models ...interface{}) {
	if err := DB.AutoMigrate(models...); err != nil {
		log.Fatalf("Database migration failed: %v", err)
	}
}
```

在 `cmd/server/main.go` 中注册模型：

```go
// ...
import "go-blog-api/internal/model"

func main() {
    config.InitConfig()
    db.InitDB()
    
    // 自动迁移
    db.AutoMigrate(&model.User{}, &model.Article{})
    
    // ...
}
```

## 4. 验证

运行程序：
```bash
go run cmd/server/main.go
```

查看 MySQL 数据库（可以使用 DBeaver 或命令行），你会发现 `users` 和 `articles` 表已经自动创建好了，并且索引也建立完毕。

## 5. 总结

本章我们完成了：
1.  **数据库连接**：配置了 GORM 连接池。
2.  **模型定义**：设计了 `User` 和 `Article` 模型，使用了 `BaseModel` 统一管理 ID 和时间。
3.  **安全细节**：通过 `json:"-"` 隐藏了密码字段。
4.  **逻辑外键**：在 `Article` 中定义了 `UserID` 但没有使用物理外键约束。

**下一章预告**：
有了数据库，我们就可以开始写真正的业务逻辑了。下一章我们将进入 **分层架构** 的核心，实现 **用户注册** 功能。我们将看到 Controller 如何调用 Service，Service 如何调用 Repository，以及如何进行**依赖注入**。
