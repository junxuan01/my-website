---
title: "数据：MySQL 建模与 GORM 最佳实践"
description: "从前端的 JSON 思维切换到关系型数据库思维。设计 User、Article 等核心表结构，掌握 GORM 的模型定义、自动迁移与逻辑外键策略。"
date: "2025-12-05"
seriesOrder: 3
---

# 3. 数据：MySQL 建模与 GORM 最佳实践

## 引言

前端开发者习惯了 MongoDB 或 JSON 这种非结构化数据，往往觉得“存进去是什么，取出来就是什么”。

在前端项目里，你可能会直接把一整棵对象树塞进 localStorage、IndexedDB 或某个状态管理库里，结构怎么舒服怎么来。但在后端开发中，**关系型数据库 (RDBMS)** 依然是核心业务数据的首选。

这一章，我们要完成从“JSON 思维”到“关系型建模思维”的切换：

- 设计博客系统中最核心的几张表（User / Article / Comment）；
- 明白为什么互联网公司里普遍**不建议用物理外键**，而是采用“逻辑外键”；
- 使用 Go 生态中最常用的 ORM 库 **GORM** 连接 MySQL，并完成自动建表；
- 体会“模型（Model）”这一层在整个架构中的角色。

> 本章目标：
>
> - 在本地启动一个 MySQL（或连接你已有的实例）；
> - 使用 GORM 成功连上数据库，并完成简单的自动迁移；
> - 定义 `User` / `Article` / `Comment` 三个基础模型；
> - 初步理解“逻辑外键”的理念，以及它和物理外键的区别。

## 1. 数据库设计哲学

### 1.1 关系型 vs 非关系型

先用你熟悉的前端场景来对比一下：

- **MongoDB / NoSQL**：
	- 很像“把整个组件树的 state 直接存成一坨 JSON”；
	- 结构灵活，字段随便加减，前期开发很爽；
	- 非常适合日志、配置、原型快速迭代等场景。
- **MySQL / 关系型数据库**：
	- 更像是“把数据拆成多个表单，每个表单有固定字段和类型”；
	- 需要一开始就认真设计表结构和字段约束；
	- 非常适合用户、订单、资金等**必须保证强一致性**的核心业务数据。

关系型数据库最大的特点是：

- 有严格的 Schema（表结构）；
- 支持事务（Transaction），保证数据的 **ACID 特性**：
	- **A 原子性**：要么都成功，要么都失败；
	- **C 一致性**：前后状态必须从一个合法状态变成另一个合法状态；
	- **I 隔离性**：多个事务之间互不影响；
	- **D 持久性**：提交后的数据不会因为宕机而丢失。

### 1.2 物理外键 vs 逻辑外键

在传统的数据库教材中，我们会通过 `FOREIGN KEY` 约束来保证数据完整性：

- 比如 `articles.user_id` 是 `users.id` 的外键；
- 如果删除了某个用户，要么禁止删除，要么级联删除这个用户的所有文章；
- 这些规则都由数据库来帮你检查。

这类我们称之为 **物理外键**。

但在高并发的互联网业务中，尤其是做大规模拆分和性能优化时，**我们通常会禁用物理外键**，原因主要有三：

1. **性能损耗**：
	- 每次插入/删除都要校验外键约束，数据库要多做一次检查；
	- 在写入非常频繁的场景（例如下单、写日志）会成为瓶颈。
2. **死锁风险**：
	- 多个事务在高并发下做级联更新/删除时，极容易互相等待锁，导致死锁；
	- 死锁一多，业务就会出现大量超时或失败请求。
3. **分库分表困难**：
	- 当数据量大到需要“按用户分库”、“按时间分表”时，跨库/跨表的物理外键基本失效；
	- 这时候多数团队会选择完全禁用物理外键，转而依赖应用层保证约束。

于是就有了 **逻辑外键** 这个概念：

> **我们仍然在表结构里保留类似 `user_id` 这样的字段，但不在数据库层面加 `FOREIGN KEY` 约束，而是在业务代码（Service 层）里主动校验和维护这些关系。**

比如：

- 创建文章前，先检查 `User` 是否存在；
- 删除用户前，先检查是否还有文章/评论，如果有就禁止删除或标记删除；
- 定期用任务脚本做“脏数据清理”，保证逻辑外键引用的目标存在。

这就是大部分互联网公司在 MySQL 建模时真实采用的策略。接下来我们会按这种思路来设计我们的模型。

## 2. 本地 MySQL 与 GORM 初始化

在写代码之前，需要先准备一个可以访问的 MySQL 实例。这里假设你使用的是本地开发环境（macOS）：

### 2.1 启动一个 MySQL 实例（示例）

如果你本地还没有 MySQL，可以用 Docker 快速拉一个（也可以用自己习惯的方式安装）：

```bash
docker run -d \
	--name go-blog-mysql \
	-e MYSQL_ROOT_PASSWORD=root \
	-e MYSQL_DATABASE=blog_db \
	-p 3306:3306 \
	mysql:8.0
```

然后你可以用任何一个 GUI 工具（如 TablePlus、DBeaver）连上 `127.0.0.1:3306`，验证数据库可用。

我们的 `configs/config.yaml` 里已经有类似这样的 DSN 配置：

```yaml
database:
	dsn: "root:password@tcp(127.0.0.1:3306)/blog_db?charset=utf8mb4&parseTime=True&loc=Local"
```

根据你实际的密码/端口调整即可。

### 2.2 安装 GORM 和 MySQL 驱动

接下来安装 GORM 和 MySQL 驱动：

```bash
go get -u gorm.io/gorm
go get -u gorm.io/driver/mysql
```

### 2.3 创建数据库初始化模块

创建 `pkg/db/db.go`：

```go
package db

import (
	"go-blog-api/pkg/config"
	"log"
	"time"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
)

var DB *gorm.DB

func InitDB() {
	dsn := config.AppConfig.Database.DSN

	var err error
	DB, err = gorm.Open(mysql.Open(dsn), &gorm.Config{
		Logger: logger.Default.LogMode(logger.Info), // 开启 SQL 日志
	})
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}

	// 设置连接池
	sqlDB, err := DB.DB()
	if err != nil {
		log.Fatalf("Failed to get sql.DB: %v", err)
	}

	sqlDB.SetMaxIdleConns(10)           // 最大空闲连接数
	sqlDB.SetMaxOpenConns(100)          // 最大打开连接数
	sqlDB.SetConnMaxLifetime(time.Hour) // 连接最大存活时间
}
```

这里做了几件事：

- 使用 `gorm.Open` 建立和 MySQL 的连接；
- 开启了 SQL 日志，方便在开发阶段观察 ORM 生成的 SQL 语句；
- 配置了连接池（最大空闲连接数、最大连接数、连接最大存活时间）。

> 和前端类比：
> - 可以把 `DB *gorm.DB` 理解成一个“全局的数据库客户端实例”；
> - 就像你在前端封装一个 `axiosInstance` 一样，后续所有仓储（Repository）层都会复用它。

别忘了在 `cmd/server/main.go` 中调用 `db.InitDB()`，确保程序启动时先初始化数据库连接。

## 3. 定义模型 (Model)

我们将定义三个核心模型：`User` (用户), `Article` (文章), `Comment` (评论)。可以把它们理解成：

- `User`：登录用户，后面会和 JWT、权限等关联；
- `Article`：博客文章主体；
- `Comment`：文章下的评论。

你可以先在纸上或白板上简单画出它们之间的关系：

- 一个用户可以有多篇文章；
- 一篇文章可以有多条评论；
- 评论属于某篇文章，也属于某个用户。

接下来先创建一个公共基础模型，统一管理 ID 和时间字段。

创建 `internal/model/base.go`，定义公共字段：

```go
package model

import (
	"time"

	"gorm.io/gorm"
)

// BaseModel 替代 gorm.Model，使用更符合 JSON 风格的字段名
type BaseModel struct {
	ID        uint           `gorm:"primarykey" json:"id"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
	DeletedAt gorm.DeletedAt `gorm:"index" json:"-"` // 软删除，前端不可见
}
```

这相当于在所有表上都自动加上了：

- 自增主键 `id`；
- 创建时间 `created_at`；
- 更新时间 `updated_at`；
- 软删除标记 `deleted_at`（对应 GORM 的软删除机制）。

后续所有业务模型都可以“组合”这个 `BaseModel`，避免重复代码。

### 3.1 用户模型 (User)

创建 `internal/model/user.go`：

```go
package model

type User struct {
	BaseModel
	Username string `gorm:"type:varchar(100);uniqueIndex;not null" json:"username"`
	Password string `gorm:"type:varchar(255);not null" json:"-"` // 密码不返回给前端
	Email    string `gorm:"type:varchar(100);uniqueIndex" json:"email"`
	Avatar   string `gorm:"type:varchar(255)" json:"avatar"`
}
```

-   `uniqueIndex`: 唯一索引，防止用户名重复。
-   `json:"-"`: 极其重要！防止在序列化时把加密后的密码泄露给前端。

你可以在脑海里想象一条 `users` 表中的记录长这样：

| id | username | email                | avatar                          | created_at           |
|----|----------|----------------------|---------------------------------|----------------------|
| 1  | junxuan  | junxuan@example.com | https://example.com/avatar.png | 2025-12-05 12:00:00 |

`Password` 字段会以哈希形式存在数据库中，但不会通过接口返回给前端。

### 3.2 文章模型 (Article)

创建 `internal/model/article.go`：

```go
package model

type Article struct {
	BaseModel
	Title   string `gorm:"type:varchar(255);not null;index" json:"title"` // 标题加索引，方便搜索
	Content string `gorm:"type:longtext" json:"content"`
	UserID  uint   `gorm:"index;not null" json:"user_id"` // 逻辑外键
	User    User   `gorm:"foreignKey:UserID" json:"user,omitempty"` // 关联关系
}
```

这里有两个关键字段：

- `UserID`：
	- 这是一个普通的无符号整型字段，在数据库里会对应 `user_id` 列；
	- 我们加上 `index` 索引字段，方便根据用户查询文章；
	- 它承载的就是“逻辑外键”的角色 —— 代码层面保证这个 ID 对应的用户存在。
- `User`：
	- 这是 GORM 的“关联字段”；
	- 不会单独建一列，而是帮助 GORM 在查询时用 `JOIN` 或 `IN` 查询把用户信息一并查出；
	- 后续会通过 `Preload("User")` 的方式加载它。

### 3.3 评论模型 (Comment)（可选）

为了让博客系统更贴近真实场景，我们再简单定义一个 `Comment` 模型：

创建 `internal/model/comment.go`：

```go
package model

type Comment struct {
	BaseModel
	Content   string `gorm:"type:text;not null" json:"content"`
	ArticleID uint   `gorm:"index;not null" json:"article_id"`
	UserID    uint   `gorm:"index;not null" json:"user_id"`
}
```

这里我们暂时不加太多花活，先让它简单一点：只记录内容和所属的文章、用户。

### 3.4 自动迁移 (Auto Migrate)

GORM 的一大神器是自动迁移，它能根据 Struct 自动创建或更新数据库表结构。注意：

- 自动迁移适合开发/测试环境；
- 在线上环境通常会结合数据库迁移工具（例如 Flyway、Liquibase、golang-migrate 等），不会直接在业务代码里 `AutoMigrate`。

在这里，我们先用最简单的方式，让 GORM 自动帮我们创建几张基础表。

修改 `pkg/db/db.go`，添加迁移逻辑：

```go
// ... imports

// AutoMigrate 执行数据库迁移
func AutoMigrate(models ...interface{}) {
	if err := DB.AutoMigrate(models...); err != nil {
		log.Fatalf("Database migration failed: %v", err)
	}
}
```

在 `cmd/server/main.go` 中注册模型：

```go
// ...
import "go-blog-api/internal/model"

func main() {
    config.InitConfig()
    db.InitDB()
    
    // 自动迁移
	db.AutoMigrate(&model.User{}, &model.Article{}, &model.Comment{})
    
    // ...
}
```

## 4. 验证

运行程序：
```bash
go run cmd/server/main.go
```

查看 MySQL 数据库（可以使用 DBeaver、TablePlus 或命令行），你会发现 `users`、`articles`、`comments` 三张表已经自动创建好了，并且索引也建立完毕。

## 5. 本章小结与练习

本章我们完成了从“抽象的数据概念”到“落地到 MySQL 表结构”的第一步：

1. **数据库设计哲学**：
	- 对比了关系型数据库和非关系型数据库的适用场景；
	- 理解了为什么在互联网业务中往往不使用物理外键，而采用逻辑外键策略。
2. **GORM 初始化**：
	- 使用 `gorm.Open` 建立了和 MySQL 的连接；
	- 配置了基础的连接池和 SQL 日志输出。
3. **模型定义**：
	- 通过 `BaseModel` 统一了 ID 和时间字段；
	- 定义了 `User`、`Article`、`Comment` 三个核心模型；
	- 在 `Article` 中通过 `UserID` 和 `User` 字段体现了逻辑外键和关联查询的设计。
4. **自动迁移**：
	- 使用 `db.AutoMigrate` 自动创建/更新表结构，快速完成了开发环境的建表工作。

### 推荐练习

1. 给 `Comment` 模型补充一个“父评论 ID”字段，实现简单的楼中楼结构：
	- 字段名可以为 `ParentID *uint`；
	- 重新运行 `AutoMigrate`，观察表结构变化。
2. 在 `User` 模型中增加一个 `Bio`（个人简介）字段：
	- 类型可以是 `text`；
	- 尝试插入一条包含多行文本的用户记录，观察 GORM 和 MySQL 如何处理。
3. 用 GORM 写一个最简单的种子数据脚本：
	- 在程序启动时检查 `users` 表是否为空；
	- 如果为空，则插入一条测试用户和几篇文章；
	- 后面章节可以直接用这些数据做联调。

**下一章预告**：
有了数据库和模型，我们就可以开始写真正的业务逻辑了。下一章我们将进入 **分层架构** 的核心，实现 **用户注册** 功能。你会看到 Controller 如何调用 Service，Service 如何调用 Repository，以及在这个过程中如何进行依赖注入，使代码更易测试和维护。
