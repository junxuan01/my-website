---
title: "启程：从前端思维到后端架构"
description: "打破前端思维定势，理解 Go 语言的并发模型与后端架构设计。初始化 Go-Blog-API 项目，掌握标准目录结构与配置管理。"
date: "2025-12-03"
seriesOrder: 1
---

# 1. 启程：从前端思维到后端架构

## 引言：为什么你需要“系统化”的学习？

很多前端开发者在学习后端时，往往陷入“API 搬运工”的陷阱：学会了怎么写路由，学会了怎么查数据库，然后就开始堆砌代码。

但后端开发的精髓不在于语法，而在于**架构设计**、**数据一致性**、**并发安全**以及**系统稳定性**。

本系列文章将带你走出“玩具代码”，按照**企业级标准**构建一个完整的博客系统后端 —— **Go-Blog-API**。我们将从零开始，一步步搭建起分层架构，处理真实的业务场景。

## 1. 思维转变：前端 vs 后端

在开始写代码之前，我们需要先调整一下思维模式。

### 1.1 运行环境与并发模型

-   **前端 (Browser/Node.js)**: 单线程 + 事件循环 (Event Loop)。你几乎不需要担心两个函数同时修改同一个变量会导致数据错乱（Race Condition）。
-   **后端 (Go)**: 多线程 + 协程 (Goroutine)。
    -   **每个请求都在独立的 Goroutine 中运行**。
    -   如果有 1000 个用户同时访问，就有 1000 个 Goroutine 在并行执行。
    -   **关键点**：**永远不要在全局变量中存储请求相关的状态**。

### 1.2 状态管理

-   **前端**: 状态 (State) 保存在内存中 (Redux, Vuex)，用户刷新页面状态重置。
-   **后端**: 服务应该是**无状态 (Stateless)** 的。
    -   任何数据都必须持久化到数据库 (MySQL) 或缓存 (Redis) 中。
    -   服务器重启不应该丢失任何业务数据。
    -   这使得我们可以随时横向扩展（加机器）。

## 2. 项目初始化：Go-Blog-API

我们将构建一个 RESTful API 服务。首先，创建项目目录。

```bash
mkdir go-blog-api
cd go-blog-api
go mod init go-blog-api
```

### 2.1 标准目录结构 (Standard Go Project Layout)

Go 社区虽然没有强制规定目录结构，但有一套广泛认可的**标准布局**。为了让我们的项目具备可维护性，我们将采用以下结构：

```text
go-blog-api/
├── cmd/
│   └── server/
│       └── main.go        # 程序入口，只负责启动
├── internal/              # 私有应用代码，外部无法导入
│   ├── api/               # API 接口层 (Controller)
│   ├── service/           # 业务逻辑层 (Service)
│   ├── repository/        # 数据访问层 (Repository/DAO)
│   ├── model/             # 数据库模型 (GORM Model)
│   └── router/            # 路由配置
├── pkg/                   # 公共库代码，可以被外部项目引用 (如工具类)
│   └── util/
├── configs/               # 配置文件
│   └── config.yaml
├── go.mod
└── go.sum
```

**为什么这么分？**
-   **`cmd`**: 保持入口整洁。
-   **`internal`**: 强制封装。Go 编译器会阻止其他项目导入 `internal` 目录下的代码，确保你的业务逻辑不被滥用。
-   **分层 (API/Service/Repo)**: 这是后端架构的核心，我们将在后续章节详细展开。

### 2.2 编写配置文件

在后端开发中，硬编码（Hard Code）是万恶之源。数据库密码、端口号等都应该放在配置文件中。

创建 `configs/config.yaml`:

```yaml
server:
  port: "8080"
  mode: "debug" # debug, release

database:
  dsn: "root:password@tcp(127.0.0.1:3306)/blog_db?charset=utf8mb4&parseTime=True&loc=Local"
```

### 2.3 引入配置管理工具：Viper

Go 生态中最强大的配置管理库是 `viper`。

```bash
go get github.com/spf13/viper
```

创建 `pkg/config/config.go` 来读取配置：

```go
package config

import (
	"log"

	"github.com/spf13/viper"
)

type Config struct {
	Server   ServerConfig
	Database DatabaseConfig
}

type ServerConfig struct {
	Port string
	Mode string
}

type DatabaseConfig struct {
	DSN string
}

var AppConfig *Config

func InitConfig() {
	viper.SetConfigName("config") // 配置文件名 (不带扩展名)
	viper.SetConfigType("yaml")   // 配置文件类型
	viper.AddConfigPath("configs") // 查找路径

	if err := viper.ReadInConfig(); err != nil {
		log.Fatalf("Error reading config file, %s", err)
	}

	if err := viper.Unmarshal(&AppConfig); err != nil {
		log.Fatalf("Unable to decode into struct, %v", err)
	}
}
```

## 3. 编写第一个入口

现在我们来编写 `cmd/server/main.go`。虽然我们还没引入 Gin，但我们可以先搭建起基本的启动流程。

```go
package main

import (
	"fmt"
	"go-blog-api/pkg/config"
	"net/http"
)

func main() {
	// 1. 初始化配置
	config.InitConfig()
	fmt.Println("Configuration loaded successfully")

	// 2. 启动 Web 服务 (暂时用 net/http 演示)
	http.HandleFunc("/ping", func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte("pong"))
	})

	addr := ":" + config.AppConfig.Server.Port
	fmt.Printf("Server is running on http://localhost%s\n", addr)
	
	if err := http.ListenAndServe(addr, nil); err != nil {
		panic(err)
	}
}
```

## 4. 运行与验证

```bash
go run cmd/server/main.go
```

你应该能看到：
```text
Configuration loaded successfully
Server is running on http://localhost:8080
```

访问 `http://localhost:8080/ping`，返回 `pong`。

## 5. 总结与预告

这一章我们没有急着写业务代码，而是先**立规矩**：
1.  **理解并发**：后端开发必须时刻警惕并发安全问题。
2.  **规范目录**：使用了 Go 标准项目布局，为后续扩展打下基础。
3.  **配置分离**：使用 Viper 管理配置，避免硬编码。

**下一章预告**：
我们将引入 **Gin 框架**，并设计一套符合 **RESTful 规范** 的 API 接口。我们将不再是简单地写路由，而是学习如何设计资源、使用正确的 HTTP 动词和状态码，并封装统一的响应结构（Response Structure）。

---
*作业：请在本地按照上述结构初始化你的 `go-blog-api` 项目，并尝试修改 `config.yaml` 中的端口号，验证服务是否能正确读取。*
