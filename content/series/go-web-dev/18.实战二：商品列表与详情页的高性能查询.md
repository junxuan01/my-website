---
title: "实战二：商品列表与详情页的高性能查询"
description: "在已有商品建模基础上，构建支持多条件筛选的商品列表与高性能详情页，结合 Gin + GORM 动态查询与 Redis Cache-Aside 缓存策略，为 Next.js SSR 提供高效稳定的 API。"
date: "2025-12-13"
seriesOrder: 18
---

# 18. 实战二：商品列表与详情页的高性能查询

> 这一篇，我们在上一章的 SPU/SKU 建模之上，真正把“商品列表页”和“详情页”跑起来，并把性能问题一并考虑进去。

你在前端世界里，写一个电商页面大概会这样思考：

- 列表页：支持**分页、搜索、分类筛选、排序**；
- 详情页：打开要快，不能每次都白屏等半天；
- 技术上：Next.js 16 里要考虑 **SSR/SSG**、数据获取与缓存策略。

在后端世界里，我们要考虑的就是：

1. 如何用 **Gin + GORM** 优雅地构建动态查询条件；
2. 如何通过 **Redis 缓存** 商品详情，减少数据库压力；
3. 如何为 Next.js 提供适合 SSR 的 API 接口（例如稳定的响应结构和缓存策略）。

本篇依旧从前端心智模型出发，对照 Go 代码来讲。

---

## 1. 列表查询的需求拆解

先把需求拆成一个你再熟悉不过的 TypeScript 接口：

```ts
// 查询参数
interface ProductListQuery {
  categoryId?: number;
  keyword?: string;
  minPrice?: number;
  maxPrice?: number;
  sortBy?: 'price_asc' | 'price_desc' | 'sold_desc' | 'created_desc';
  page?: number;
  pageSize?: number;
}

// 返回结果
interface ProductListItem {
  id: number;
  title: string;
  coverImage: string;
  priceMin: number;
  priceMax: number;
  soldCount: number;
}

interface ProductListResult {
  list: ProductListItem[];
  total: number;
}
```

在 Next.js 中，你可能会写一个 hook：

```ts
function useProductList(query: ProductListQuery) {
  // 拼 query string，然后用 fetch / axios 调后端
}
```

在 Go + Gin + GORM 里，对应的是：

- 用 `ShouldBindQuery` 从 URL query 中解析参数；
- 用 GORM 的链式 API（`Where`、`Order`、`Offset`、`Limit`）构建 SQL；
- 封装一个 `scope` 或者 builder 来管理复杂度。

接下来我们一步一步落地。

---

## 2. Gin 中解析查询参数

先定义一个请求结构体：

```go
// internal/handler/product.go

type ProductListRequest struct {
    CategoryID uint64  `form:"category_id"`
    Keyword    string  `form:"keyword"`
    MinPrice   float64 `form:"min_price"`
    MaxPrice   float64 `form:"max_price"`
    SortBy     string  `form:"sort_by"` // price_asc / price_desc / sold_desc / created_desc
    Page       int     `form:"page"`
    PageSize   int     `form:"page_size"`
}
```

在 Handler 中解析：

```go
func ProductList(db *gorm.DB) gin.HandlerFunc {
    return func(c *gin.Context) {
        var req ProductListRequest
        if err := c.ShouldBindQuery(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        if req.Page <= 0 {
            req.Page = 1
        }
        if req.PageSize <= 0 || req.PageSize > 100 {
            req.PageSize = 20
        }

        // ...后面会补充查询逻辑
    }
}
```

对比前端：

```ts
const url = `/api/products?category_id=${categoryId}&keyword=${keyword}&page=${page}`;
```

在 Gin 里 `ShouldBindQuery` 做的就是：帮你从 `?category_id=1&keyword=xxx` 里自动解析到 struct。

---

## 3. 用 GORM 构建动态查询：类似前端拼 if/else

在 TS 里，你可能这么写：

```ts
const params: Record<string, string | number> = {};
if (query.categoryId) params.category_id = query.categoryId;
if (query.keyword) params.keyword = query.keyword;
if (query.minPrice) params.min_price = query.minPrice;
// ...
```

GORM 里的等价物就是不断往 `query` 这个变量上挂条件：

```go
query := db.Model(&model.Product{}).Where("status = ?", model.ProductStatusOn)

if req.CategoryID > 0 {
    query = query.Where("category_id = ?", req.CategoryID)
}

if req.Keyword != "" {
    like := "%" + req.Keyword + "%"
    query = query.Where("title LIKE ? OR sub_title LIKE ?", like, like)
}

if req.MinPrice > 0 {
    query = query.Where("price_min >= ?", req.MinPrice)
}
if req.MaxPrice > 0 {
    query = query.Where("price_max <= ?", req.MaxPrice)
}

switch req.SortBy {
case "price_asc":
    query = query.Order("price_min ASC")
case "price_desc":
    query = query.Order("price_min DESC")
case "sold_desc":
    query = query.Order("sold_count DESC")
case "created_desc":
    fallthrough
default:
    query = query.Order("id DESC")
}
```

最后做分页：

```go
var (
    products []model.Product
    total    int64
)

if err := query.Count(&total).Error; err != nil {
    c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
    return
}

if err := query.
    Offset((req.Page - 1) * req.PageSize).
    Limit(req.PageSize).
    Find(&products).Error; err != nil {
    c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
    return
}
```

你可以把 `query := db.Model(...); query = query.Where(...)` 理解成在 JS 里不断往一个数组里 `push` 条件，最后统一执行。

---

## 4. 用 GORM Scope 抽离查询逻辑

当筛选条件越来越多时，Handler 很快会变得又长又丑。GORM 提供了 `Scopes` 来做“查询构建器”。

在 TS 里你可能会这样抽：

```ts
function buildProductQuery(base: SqlBuilder, query: ProductListQuery) {
  if (query.categoryId) base.where('category_id = ?', query.categoryId);
  if (query.keyword) base.where('title LIKE ?', `%${query.keyword}%`);
  // ...
  return base;
}
```

在 Go + GORM 中：

```go
// internal/repository/product_query.go

package repository

import (
    "gorm.io/gorm"
    "yourapp/internal/model"
)

type ProductListFilter struct {
    CategoryID uint64
    Keyword    string
    MinPrice   float64
    MaxPrice   float64
    SortBy     string
}

func ScopeProductFilter(filter ProductListFilter) func(*gorm.DB) *gorm.DB {
    return func(db *gorm.DB) *gorm.DB {
        query := db.Where("status = ?", model.ProductStatusOn)

        if filter.CategoryID > 0 {
            query = query.Where("category_id = ?", filter.CategoryID)
        }

        if filter.Keyword != "" {
            like := "%" + filter.Keyword + "%"
            query = query.Where("title LIKE ? OR sub_title LIKE ?", like, like)
        }

        if filter.MinPrice > 0 {
            query = query.Where("price_min >= ?", filter.MinPrice)
        }
        if filter.MaxPrice > 0 {
            query = query.Where("price_max <= ?", filter.MaxPrice)
        }

        switch filter.SortBy {
        case "price_asc":
            query = query.Order("price_min ASC")
        case "price_desc":
            query = query.Order("price_min DESC")
        case "sold_desc":
            query = query.Order("sold_count DESC")
        case "created_desc":
            fallthrough
        default:
            query = query.Order("id DESC")
        }

        return query
    }
}
```

Handler 中就可以这样使用：

```go
import "yourapp/internal/repository"

func ProductList(db *gorm.DB) gin.HandlerFunc {
    return func(c *gin.Context) {
        var req ProductListRequest
        if err := c.ShouldBindQuery(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        if req.Page <= 0 {
            req.Page = 1
        }
        if req.PageSize <= 0 || req.PageSize > 100 {
            req.PageSize = 20
        }

        filter := repository.ProductListFilter{
            CategoryID: req.CategoryID,
            Keyword:    req.Keyword,
            MinPrice:   req.MinPrice,
            MaxPrice:   req.MaxPrice,
            SortBy:     req.SortBy,
        }

        var (
            products []model.Product
            total    int64
        )

        base := db.Model(&model.Product{}).Scopes(repository.ScopeProductFilter(filter))

        if err := base.Count(&total).Error; err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }

        if err := base.
            Offset((req.Page - 1) * req.PageSize).
            Limit(req.PageSize).
            Find(&products).Error; err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }

        c.JSON(http.StatusOK, gin.H{
            "list":  products,
            "total": total,
        })
    }
}
```

这就相当于在 JS 里把“拼 SQL 条件”的逻辑抽成了一个独立函数/模块，便于复用和单元测试。

---

## 5. 详情页：为什么必须上 Redis 缓存？

在真实电商中：

- 列表页：查询条件各种组合，但每条数据字段不多，命中率分散；
- 详情页：热点商品会被频繁刷新和分享，同一个 `product_id` 请求量巨大；
- 单纯依赖 MySQL：在高峰时极易成为瓶颈。

因此常见做法是：

- 列表页：主要依赖数据库 + 合理索引；
- 详情页：**强依赖 Redis 缓存**，采用 **Cache-Aside（旁路缓存）模式**。

### 5.1 Cache-Aside 模式回顾

流程非常经典：

1. 先查 Redis：
   - 命中：直接返回；
   - 未命中：查数据库，写回 Redis，再返回。
2. 更新数据时：
   - 先更新数据库；
   - 再删除或更新 Redis 中的缓存键。

从前端类比：

- 你在 Zustand 或 SWR 里维护一个本地缓存 `cache[productId]`；
- 先读缓存，没有再 `fetch`，然后把结果写回缓存，供后续组件复用。

---

## 6. 商品详情的数据结构设计

我们可以为详情页定义一个专门的 DTO（数据传输对象），避免直接暴露数据库全部字段：

```go
// internal/dto/product_detail.go

package dto

import "yourapp/internal/model"

type ProductDetail struct {
    ID         uint64                `json:"id"`
    Title      string                `json:"title"`
    SubTitle   string                `json:"sub_title"`
    CoverImage string                `json:"cover_image"`
    PriceMin   float64               `json:"price_min"`
    PriceMax   float64               `json:"price_max"`
    StockTotal int                   `json:"stock_total"`
    SoldCount  int                   `json:"sold_count"`
    DetailHTML string                `json:"detail_html"`
    Category   *ProductCategoryBrief `json:"category,omitempty"`
    Skus       []SkuItem             `json:"skus"`
    Attrs      []AttrItem            `json:"attrs"`
}

type ProductCategoryBrief struct {
    ID   uint64 `json:"id"`
    Name string `json:"name"`
}

type SkuItem struct {
    ID        uint64        `json:"id"`
    Price     float64       `json:"price"`
    Stock     int           `json:"stock"`
    Image     string        `json:"image"`
    Attrs     model.SkuAttrs `json:"attrs"`
}

type AttrItem struct {
    Name  string `json:"name"`
    Value string `json:"value"`
}
```

类似于在 TS 里你会写一个 `ProductDetail` 专用类型，而不是直接拿数据库原始字段直接用。

---

## 7. 使用 Redis 做详情缓存

### 7.1 Redis Key 设计

简单实用即可：

```text
product:detail:{id}
```

- Value：JSON 字符串，内容为 `ProductDetail`。
- TTL：可以设置一个较长时间（比如 30 分钟），配合更新时主动删除缓存。

### 7.2 Go 代码实现

这里以 `go-redis v9` 为例（当前主流版本）：

```go
// internal/service/product_detail.go

package service

import (
    "context"
    "encoding/json"
    "fmt"
    "time"

    "github.com/redis/go-redis/v9"
    "gorm.io/gorm"

    "yourapp/internal/dto"
    "yourapp/internal/model"
)

type ProductService struct {
    db  *gorm.DB
    rdb *redis.Client
}

func NewProductService(db *gorm.DB, rdb *redis.Client) *ProductService {
    return &ProductService{db: db, rdb: rdb}
}

func (s *ProductService) getDetailCacheKey(id uint64) string {
    return fmt.Sprintf("product:detail:%d", id)
}

func (s *ProductService) GetProductDetail(ctx context.Context, id uint64) (*dto.ProductDetail, error) {
    // 1. 先查 Redis
    key := s.getDetailCacheKey(id)
    if val, err := s.rdb.Get(ctx, key).Result(); err == nil && val != "" {
        var detail dto.ProductDetail
        if err := json.Unmarshal([]byte(val), &detail); err == nil {
            return &detail, nil
        }
        // 反序列化失败则忽略缓存，走数据库
    }

    // 2. 查数据库
    var product model.Product
    if err := s.db.Where("id = ? AND status = ?", id, model.ProductStatusOn).
        First(&product).Error; err != nil {
        if err == gorm.ErrRecordNotFound {
            return nil, nil
        }
        return nil, err
    }

    // 预加载 SKU
    var skus []model.ProductSku
    if err := s.db.Where("product_id = ?", product.ID).Find(&skus).Error; err != nil {
        return nil, err
    }

    // 预加载属性
    var attrs []model.ProductAttr
    if err := s.db.Where("product_id = ?", product.ID).Order("sort DESC").Find(&attrs).Error; err != nil {
        return nil, err
    }

    // 分类简要信息
    var cat model.Category
    if err := s.db.Select("id", "name").Where("id = ?", product.CategoryID).First(&cat).Error; err != nil {
        // 分类失败不算致命，可以忽略
    }

    // 3. 组装 DTO
    detail := dto.ProductDetail{
        ID:         product.ID,
        Title:      product.Title,
        SubTitle:   product.SubTitle,
        CoverImage: product.CoverImage,
        PriceMin:   product.PriceMin,
        PriceMax:   product.PriceMax,
        StockTotal: product.StockTotal,
        SoldCount:  product.SoldCount,
        DetailHTML: product.DetailHTML,
    }

    if cat.ID > 0 {
        detail.Category = &dto.ProductCategoryBrief{ID: cat.ID, Name: cat.Name}
    }

    detail.Skus = make([]dto.SkuItem, 0, len(skus))
    for _, sku := range skus {
        detail.Skus = append(detail.Skus, dto.SkuItem{
            ID:    sku.ID,
            Price: sku.Price,
            Stock: sku.Stock,
            Image: sku.Image,
            Attrs: sku.Attrs,
        })
    }

    detail.Attrs = make([]dto.AttrItem, 0, len(attrs))
    for _, a := range attrs {
        detail.Attrs = append(detail.Attrs, dto.AttrItem{
            Name:  a.Name,
            Value: a.Value,
        })
    }

    // 4. 写入 Redis 缓存
    if b, err := json.Marshal(detail); err == nil {
        _ = s.rdb.Set(ctx, key, string(b), 30*time.Minute).Err()
    }

    return &detail, nil
}
```

### 7.3 Gin Handler 封装

```go
// internal/handler/product_detail.go

package handler

import (
    "net/http"
    "strconv"

    "github.com/gin-gonic/gin"

    "yourapp/internal/service"
)

func ProductDetail(svc *service.ProductService) gin.HandlerFunc {
    return func(c *gin.Context) {
        idStr := c.Param("id")
        id, err := strconv.ParseUint(idStr, 10, 64)
        if err != nil || id == 0 {
            c.JSON(http.StatusBadRequest, gin.H{"error": "invalid id"})
            return
        }

        detail, err := svc.GetProductDetail(c.Request.Context(), id)
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }
        if detail == nil {
            c.JSON(http.StatusNotFound, gin.H{"error": "product not found"})
            return
        }

        c.JSON(http.StatusOK, detail)
    }
}
```

至此，我们已经有了：

- `GET /api/products`：商品列表 + 筛选 + 分页；
- `GET /api/products/:id`：详情页 + Redis 缓存。

---

## 8. 缓存穿透、缓存击穿与缓存雪崩

这些是 Redis 使用中绕不过去的三个概念，这里做一个简明版解释：

### 8.1 缓存穿透

**现象**：

- 请求的 Key 在缓存和数据库里都不存在；
- 黑客或爬虫不断请求随机的商品 ID，导致每次都查询数据库；
- 数据库压力被“穿透”到后面。

**解决方案**：

- 对于不存在的商品，也可以在 Redis 中缓存一个短期的“空值标记”，比如：

```text
product:detail:99999999 -> "{}" (TTL = 60s)
```

修改 `GetProductDetail` 中的逻辑：

```go
if val, err := s.rdb.Get(ctx, key).Result(); err == nil {
    if val == "{}" {
        // 标记为不存在
        return nil, nil
    }
    // 正常反序列化...
}

// 如果数据库里也查不到
if err == gorm.ErrRecordNotFound {
    // 写入一个空对象，设置较短TTL
    _ = s.rdb.Set(ctx, key, "{}", time.Minute).Err()
    return nil, nil
}
```

### 8.2 缓存击穿

**现象**：

- 某个热点商品 Key 在某一刻 TTL 到期；
- 大量请求同时过来，发现都没命中缓存，于是同时打到数据库；
- 数据库瞬时压力暴涨。

**常见解决方案**：

- 使用 **互斥锁**（如 Redis 分布式锁）在重建缓存时只允许一个请求去查数据库；
- 或者采用 **逻辑过期**：
  - Value 中带上 `expireAt` 字段，过期后由后台任务异步刷新，但对前端可以短时间内继续返回旧值。

在本教程中，我们先采用简单方案：

- 缓存时间设得稍长（例如 30 分钟~1 小时）；
- 对于真正的强一致场景（例如库存、价格），会在后续章节用 Redis + MQ 专门处理。

### 8.3 缓存雪崩

**现象**：

- 大量 Key 在同一时间集中过期；
- 造成集体缓存失效，大量请求回源数据库，导致雪崩。

**解决方案**：

- 设置随机过期时间：

```go
// 比如 30 ~ 40 分钟随机
expire := 30*time.Minute + time.Duration(rand.Intn(10))*time.Minute
_ = s.rdb.Set(ctx, key, string(b), expire).Err()
```

---

## 9. Next.js 16：SSR/SSG 对接 API 的最佳实践

你在 Next.js 16（App Router）里，大概率会这样设计商品详情页：

- 路由：`/products/[id]`；
- 数据获取：在 `page.tsx` 的 `generateMetadata` + `fetch` 中调用后端 API。

示意代码：

```ts
// app/products/[id]/page.tsx

import { notFound } from 'next/navigation';

interface ProductDetailPageProps {
  params: { id: string };
}

interface ProductDetail {
  id: number;
  title: string;
  sub_title: string;
  cover_image: string;
  price_min: number;
  price_max: number;
  // ... 省略
}

async function fetchProductDetail(id: string): Promise<ProductDetail | null> {
  const res = await fetch(`${process.env.NEXT_PUBLIC_API_BASE}/api/products/${id}`, {
    // 可以结合 next 的缓存配置
    next: { revalidate: 60 },
  });

  if (res.status === 404) return null;
  if (!res.ok) throw new Error('Failed to fetch product detail');

  return res.json();
}

export default async function ProductDetailPage({ params }: ProductDetailPageProps) {
  const detail = await fetchProductDetail(params.id);

  if (!detail) {
    notFound();
  }

  return (
    <main className="container mx-auto py-8">
      <h1 className="text-2xl font-bold mb-4">{detail.title}</h1>
      {/* 这里可以渲染 SKU 选择器、价格、库存、属性等 */}
    </main>
  );
}
```

注意：

- 即使 Next.js 自己有缓存机制，后端依然要用 Redis 做缓存，
- 这样即便有其他客户端（小程序、App、第三方服务）访问，也能享受到缓存带来的性能收益。

---

## 10. 性能小结：这一篇我们做了什么？

回顾一下本篇关键点：

1. **商品列表**：
   - 使用 Gin + GORM 构建了可组合的动态查询；
   - 用 `Scopes` 抽离查询构建逻辑，类似 TS 里的 Query Builder；
2. **商品详情**：
   - 设计了专用的 DTO，避免直接暴露数据库结构；
   - 使用 Redis + Cache-Aside 模式缓存详情，解决高并发读问题；
   - 简单讨论了缓存穿透、缓存击穿、缓存雪崩及应对策略；
3. **与 Next.js 16 的衔接**：
   - 在 SSR 场景下，通过 `fetch` 后端 API 获取数据，
   - 结合 Next.js 的 `revalidate` 与后端 Redis 缓存，共同保障性能与 SEO。

---

## 11. 下一篇预告：购物车与 Redis 高级应用

在下一篇《实战二：购物车系统与 Redis 高级应用》中，我们会进一步深入 Redis：

- 为什么购物车非常适合放在 Redis 里而不是 MySQL？
- 如何用 Redis 的 Hash 结构优雅地表示购物车？
- 如何处理“未登录购物车”和“登录后购物车”的合并？
- 前端（Next.js + Zustand）如何与后端 Redis 状态进行同步？

这一部分会从你最熟悉的“购物车组件状态”出发，把它翻译成 Redis 数据结构与 Go API，非常适合前端同学深入理解 Redis 的真实使用场景。