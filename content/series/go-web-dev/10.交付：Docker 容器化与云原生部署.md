---
title: "交付：Docker 容器化与云原生部署"
description: "后端开发的最后一公里。编写 Dockerfile 构建最小化镜像。使用 Docker Compose 编排 Go 应用、MySQL、Redis 和 RabbitMQ，实现一键部署。"
date: "2025-12-12"
seriesOrder: 10
---

# 10. 交付：Docker 容器化与云原生部署

## 引言

"在我的机器上是好的，为什么在服务器上跑不起来？"
这是开发和运维之间最经典的争吵。

> **前端类比**：这就像你本地 `npm run dev` 跑得好好的，一部署到 Vercel 就报错——因为环境不一致。

**Docker** 的出现彻底终结了这个问题。它将代码、运行时、系统库、配置文件全部打包到一个**镜像 (Image)** 中，保证了环境的一致性。

作为本系列的终章，我们将把 Go-Blog-API 以及它依赖的 MySQL、Redis、RabbitMQ 全部容器化，实现**一键启动**。

### 本章目标

- 理解 Docker 的核心概念（镜像、容器、仓库）；
- 编写 Dockerfile，使用多阶段构建优化镜像大小；
- 使用 Docker Compose 编排多个服务；
- 实现开发环境的一键部署。

## 0. Docker 快速入门

> **这一节是为没接触过 Docker 的同学准备的，有基础的可以跳过。**

### 0.1 Docker 是什么？

想象一下快递：

- **没有 Docker**：每次寄东西都要现场组装包装盒、找泡沫、贴标签...
- **有 Docker**：直接用标准化的集装箱，无论里面装什么，运输、装卸方式都一样。

Docker 就是软件界的"集装箱"——它把应用及其所有依赖打包成一个标准化单元。

### 0.2 核心概念

| 概念 | 解释 | 类比 |
|------|------|------|
| **镜像 (Image)** | 一个只读的模板，包含运行应用所需的一切 | 像一个 `.iso` 安装盘，或者 npm 包 |
| **容器 (Container)** | 镜像的运行实例 | 像从安装盘装好的系统，可以运行 |
| **Dockerfile** | 构建镜像的"食谱" | 像 `package.json` + 构建脚本 |
| **Docker Hub** | 镜像仓库 | 像 npm registry |

**它们之间的关系：**

```
Dockerfile --(build)--> Image --(run)--> Container
                          |
                          v
                    Docker Hub (push/pull)
```

### 0.3 安装 Docker

**macOS / Windows**：下载 [Docker Desktop](https://www.docker.com/products/docker-desktop)

**Linux**：
```bash
# Ubuntu
sudo apt-get update
sudo apt-get install docker.io docker-compose
```

验证安装：
```bash
docker --version
docker-compose --version
```

### 0.4 常用命令速查

```bash
# 镜像相关
docker images                  # 列出本地镜像
docker pull nginx              # 从 Docker Hub 拉取镜像
docker rmi <image_id>          # 删除镜像

# 容器相关
docker ps                      # 查看运行中的容器
docker ps -a                   # 查看所有容器（包括已停止的）
docker run -d -p 80:80 nginx   # 运行容器（-d 后台，-p 端口映射）
docker stop <container_id>     # 停止容器
docker rm <container_id>       # 删除容器
docker logs <container_id>     # 查看容器日志

# 构建相关
docker build -t myapp .        # 从 Dockerfile 构建镜像
```

## 1. 编写 Dockerfile

### 1.1 什么是 Dockerfile？

Dockerfile 就是构建镜像的"食谱"，告诉 Docker：

1. 从哪个基础镜像开始；
2. 复制哪些文件进去；
3. 执行哪些命令；
4. 最终运行什么。

> **前端类比**：类似于 Vercel 或 Netlify 的构建配置，定义了如何把源码变成可部署的产物。

### 1.2 多阶段构建

Go 语言的一大优势是编译产物只是**一个二进制文件**（不像 Node.js 需要 node_modules）。

我们可以利用 **多阶段构建 (Multi-stage Build)** 来制作极小的镜像：

- **构建阶段**：安装 Go 编译器，下载依赖，编译代码；
- **运行阶段**：只需要一个精简的 Linux 系统 + 编译好的二进制文件。

在项目根目录创建 `Dockerfile`：

```dockerfile
# ========================
# 阶段一：构建阶段
# ========================
FROM golang:1.25-alpine AS builder

# alpine 是一个超精简的 Linux 发行版，只有 5MB
# AS builder 给这个阶段起个名字，后面要引用

# 设置环境变量
ENV GO111MODULE=on \
    GOPROXY=https://goproxy.cn,direct

WORKDIR /app

# 先复制依赖文件（利用 Docker 层缓存）
# 如果 go.mod/go.sum 没变，这一层就不会重新构建
COPY go.mod go.sum ./
RUN go mod download

# 复制源码并编译
COPY . .
RUN go build -o server cmd/server/main.go

# ========================
# 阶段二：运行阶段
# ========================
FROM alpine:latest

# 这个阶段不需要 Go 编译器，只需要一个最小的 Linux
WORKDIR /app

# 从构建阶段复制编译好的二进制文件
COPY --from=builder /app/server .

# 复制配置文件
COPY --from=builder /app/configs ./configs

# 暴露端口（文档作用，提醒使用者这个容器监听 8080）
EXPOSE 8080

# 启动命令
CMD ["./server"]
```

**构建并查看镜像大小：**

```bash
docker build -t go-blog-api .
docker images | grep go-blog-api
```

你会发现镜像只有 **20-30MB**！对比之下，一个 Node.js 应用的镜像通常有 200-500MB。

## 2. 编写 Docker Compose

### 2.1 为什么需要 Docker Compose？

我们的应用依赖 4 个服务：Go App、MySQL、Redis、RabbitMQ。

没有 Docker Compose，你需要：
```bash
docker run -d mysql...
docker run -d redis...
docker run -d rabbitmq...
docker run -d --link mysql --link redis --link rabbitmq myapp...
```

**Docker Compose** 让你用一个 YAML 文件描述所有服务，然后**一条命令全部启动**。

> **前端类比**：类似于 `package.json` 的 `scripts`，或者 monorepo 工具的工作区配置。

### 2.2 编写 docker-compose.yml

创建 `docker-compose.yml`：

```yaml
version: '3.8'

services:
  # ========================
  # Go 应用
  # ========================
  app:
    build: .                      # 使用当前目录的 Dockerfile 构建
    container_name: go-blog-api
    ports:
      - "8080:8080"               # 主机端口:容器端口
    depends_on:                   # 依赖的服务（会先启动它们）
      - mysql
      - redis
      - rabbitmq
    environment:                  # 环境变量
      - CONFIG_PATH=configs/config.docker.yaml
    networks:
      - blog-net
    restart: unless-stopped       # 自动重启策略

  # ========================
  # MySQL 数据库
  # ========================
  mysql:
    image: mysql:8.0              # 使用官方镜像
    container_name: blog-mysql
    environment:
      MYSQL_ROOT_PASSWORD: root   # root 密码
      MYSQL_DATABASE: blog_db     # 自动创建的数据库
    volumes:
      - mysql_data:/var/lib/mysql # 数据持久化
    networks:
      - blog-net
    healthcheck:                  # 健康检查
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 10s
      timeout: 5s
      retries: 5

  # ========================
  # Redis 缓存
  # ========================
  redis:
    image: redis:7.0
    container_name: blog-redis
    networks:
      - blog-net
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  # ========================
  # RabbitMQ 消息队列
  # ========================
  rabbitmq:
    image: rabbitmq:3-management  # 带管理界面的版本
    container_name: blog-rabbitmq
    ports:
      - "15672:15672"             # 管理界面端口
      - "5672:5672"               # AMQP 协议端口
    environment:
      RABBITMQ_DEFAULT_USER: guest
      RABBITMQ_DEFAULT_PASS: guest
    networks:
      - blog-net

# ========================
# 网络配置
# ========================
networks:
  blog-net:
    driver: bridge                # 桥接网络，容器间可以互相访问

# ========================
# 数据卷配置
# ========================
volumes:
  mysql_data:                     # MySQL 数据持久化
```

### 2.3 关键概念解释

**networks（网络）**：

同一网络内的容器可以通过**服务名**互相访问。比如 `app` 容器可以通过 `mysql:3306` 访问数据库，而不是 `localhost:3306`。

**volumes（数据卷）**：

容器是临时的——停止容器，里面的数据就没了。数据卷可以把数据保存到主机上，即使容器删除，数据依然在。

**depends_on（依赖）**：

确保依赖的服务先启动。但注意：它只保证**容器启动顺序**，不保证服务**完全就绪**。所以我们加了 healthcheck。

### 2.4 从“前端联调”视角理解 Compose

对前端来说，Docker Compose 的价值往往不是“上云”，而是：

- 后端同学给你一个仓库，你执行一条命令
- 你就能拿到稳定的：API + MySQL + Redis + RabbitMQ

你不需要在本机装 MySQL/Redis，也不需要到处改端口。

> **前端类比**：
>
> 这就像 `pnpm install && pnpm dev` 能把前端依赖装好并跑起来。
> Compose 是把“后端依赖”也脚本化了。

## 3. 修改配置

### 3.1 Docker 网络中的服务发现

在 Docker 网络中，服务之间通过**服务名**（也就是 docker-compose.yml 中的 service 名称）互相访问，而不是 `localhost`。

```
开发环境：  app → localhost:3306 → MySQL
Docker环境: app → mysql:3306    → MySQL 容器
```

### 3.2 创建 Docker 专用配置

创建 `configs/config.docker.yaml`：

```yaml
server:
  port: "8080"
  mode: "release"

database:
  # 注意：host 从 localhost 变成了 mysql（服务名）
  dsn: "root:root@tcp(mysql:3306)/blog_db?charset=utf8mb4&parseTime=True&loc=Local"

redis:
  # 注意：host 从 localhost 变成了 redis（服务名）
  addr: "redis:6379"
  password: ""
  db: 0

rabbitmq:
  # 注意：host 从 localhost 变成了 rabbitmq（服务名）
  url: "amqp://guest:guest@rabbitmq:5672/"

jwt:
  secret: "your-secret-key-change-in-production"
  access_ttl: 15     # 分钟
  refresh_ttl: 10080 # 7 天
```

### 3.3 支持环境变量覆盖配置路径

修改 `pkg/config/config.go`，支持通过环境变量指定配置文件：

```go
func LoadConfig() *Config {
    configPath := os.Getenv("CONFIG_PATH")
    if configPath == "" {
        configPath = "configs/config.yaml" // 默认路径
    }
    
    viper.SetConfigFile(configPath)
    // ...
}

### 3.4 容器里不要用 localhost：这是最常见的联调坑

一定要记住：

- `localhost` 在容器里指的是“**容器自己**”
- 容器访问另一个容器，要用 **service 名称**（`mysql` / `redis` / `rabbitmq`）

所以你看到我们在 `config.docker.yaml` 里把 host 全部改成了服务名。
```

## 4. 一键部署与运维

### 4.1 启动所有服务

在项目根目录执行：

```bash
# 构建并启动所有服务（-d 表示后台运行）
docker-compose up -d --build
```

如果你用的是新版 Docker（Compose v2），命令也可能是：

```bash
docker compose up -d --build
```

Docker 会自动：
1. 拉取 MySQL、Redis、RabbitMQ 镜像（首次运行）；
2. 根据 Dockerfile 构建我们的 App 镜像；
3. 创建虚拟网络 `blog-net`；
4. 按依赖顺序启动所有容器。

### 4.2 常用运维命令

```bash
# 查看运行状态
docker-compose ps

# 查看所有服务的日志
docker-compose logs

# 查看特定服务的日志（实时跟踪）
docker-compose logs -f app

# 停止所有服务
docker-compose down

# 停止并删除数据卷（清空数据）
docker-compose down -v

# 重新构建并启动
docker-compose up -d --build

# 进入容器内部（调试用）
docker exec -it go-blog-api sh

# 查看 MySQL 数据
docker exec -it blog-mysql mysql -uroot -proot blog_db
```

### 4.2.1 常见问题排查（强烈建议收藏）

1. **接口访问不了**：
  - 先看 `docker-compose ps`（容器是否都 Up）
  - 再看 `docker-compose logs -f app`（应用是否启动报错）

2. **MySQL 连不上**：
  - 你的 DSN 里是不是还写着 `localhost:3306`？容器里应该是 `mysql:3306`
  - MySQL 首次启动需要初始化，等几十秒是正常的

3. **改了代码但没生效**：
  - 你可能忘了 `--build`
  - 或者 Docker 仍在用旧镜像：重新 `docker-compose up -d --build`

4. **端口被占用**：
  - 例如本机已经有 MySQL 占用了 3306（虽然 compose 里没暴露 3306，但其它服务可能冲突）
  - 用 `lsof -i :8080` / `lsof -i :15672` 检查占用

### 4.3 访问服务

启动成功后，你可以访问：

| 服务 | 地址 | 说明 |
|------|------|------|
| Go API | http://localhost:8080 | 主应用 |
| Swagger 文档 | http://localhost:8080/swagger/index.html | API 文档 |
| RabbitMQ 管理界面 | http://localhost:15672 | 用户名/密码: guest/guest |

## 5. 小结与练习

### 本章回顾

| 概念 | 说明 | 用途 |
|------|------|------|
| Docker | 容器化技术，打包应用和依赖 | 环境一致性 |
| Dockerfile | 构建镜像的"食谱" | 定义如何打包应用 |
| 多阶段构建 | 分离构建环境和运行环境 | 减小镜像体积 |
| Docker Compose | 多容器编排工具 | 一键启动多个服务 |
| 数据卷 (Volume) | 持久化容器数据 | 防止数据丢失 |
| 网络 (Network) | 容器间通信 | 服务发现 |

### 关键命令

```bash
# 构建镜像
docker build -t myapp .

# 启动所有服务
docker-compose up -d --build

# 查看日志
docker-compose logs -f

# 停止服务
docker-compose down
```

### 贯穿任务线（本章验收：一键联调环境）

- [ ] 你可以用一条命令启动全家桶：`docker-compose up -d --build`（或 `docker compose up -d --build`）
- [ ] 容器网络可用：App 能通过 `mysql`/`redis`/`rabbitmq` 服务名访问依赖
- [ ] API 可访问：`curl http://localhost:8080/ping`（以及至少 1 个业务接口）
- [ ] Swagger 可访问：`http://localhost:8080/swagger/index.html`
- [ ] RabbitMQ 管理界面可访问：`http://localhost:15672`，并能观察队列变化

### 动手练习

1. **添加 Nginx 反向代理**：
   - 在 docker-compose.yml 中添加 nginx 服务；
   - 配置 nginx 代理到 app 服务。

2. **添加数据库初始化脚本**：
   - 创建 `init.sql` 文件；
   - 通过 volume 挂载到 MySQL 的初始化目录。

3. **环境变量管理**：
   - 创建 `.env` 文件管理敏感配置；
   - 在 docker-compose.yml 中使用 `${VAR}` 语法。

### 思考题

1. 为什么使用多阶段构建可以减小镜像体积？
2. `depends_on` 能保证依赖的服务完全就绪吗？如果不能，怎么解决？
3. 生产环境中，数据库密码应该如何管理？

## 6. 结语：从入门到架构师

恭喜你！你已经完成了《Go Web 后端架构实战》基础篇的全部内容。

### 回顾我们的旅程

| 章节 | 主题 | 核心收获 |
|------|------|----------|
| 01 | 启程 | Go 语言思维，项目结构 |
| 02 | 核心 | Gin 框架，RESTful 设计 |
| 03 | 数据 | GORM ORM，数据库操作 |
| 04 | 架构 | CSR 分层，依赖注入 |
| 05 | 安全 | JWT 认证，中间件 |
| 06 | 事务 | 复杂查询，事务，分页 |
| 07 | 性能 | Redis 缓存，分布式锁 |
| 08 | 异步 | RabbitMQ 消息队列 |
| 09 | 稳健 | 单元测试，Swagger 文档 |
| 10 | 交付 | Docker 容器化部署 |

### 这套知识的价值

这不仅仅是一个博客系统，更是一套**可复用的企业级后端架构模板**：

- **分层清晰**：Controller → Service → Repository，职责分明；
- **依赖可测**：通过接口和依赖注入，代码可测试；
- **基础设施完备**：数据库、缓存、消息队列、容器化一应俱全；
- **文档自动化**：Swagger 保证 API 文档永远最新。

### 下一步

基础篇完结后，我们将进入**实战篇**——构建一个完整的 **RBAC 权限管理系统**：

- 用户、角色、权限三角关系
- JWT 双令牌刷新机制
- Casbin 权限中间件
- 动态菜单与前端对接
- 生产环境部署与 CI/CD

**Keep Coding, Keep Learning!**
