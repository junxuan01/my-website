---
title: "实战二：电商核心业务建模与 SPU/SKU 设计"
description: "实战电商项目的第一篇，从前端组件心智出发，系统讲解 SPU/SKU 区分、分类树与商品属性建模，并用 MySQL + GORM 落地完整的数据结构。"
date: "2025-12-13"
seriesOrder: 17
---

# 17. 实战二：电商核心业务建模与 SPU/SKU 设计

> 面向前端工程师的 Go Web 电商项目实战：从“商品卡片组件”到后端商品模型的完整落地。

本篇是“实战项目二：企业级 B2C 电商平台”的第一篇，我们会专注在**电商最核心也是最难的部分：商品建模**——尤其是 SPU/SKU、分类树、属性规格这些概念。

你可以把这篇文章理解成：

- 把你在前端里写的 `ProductCard`、`SkuSelector` 组件，
- 一点点翻译成 **MySQL 表结构 + GORM 模型 + Go 代码**。

同时，全篇会大量对比 **JavaScript/TypeScript vs Go** 的写法，帮助你快速建立心智模型。

---

## 1. 电商领域核心概念：从组件到模型

先从你熟悉的前端世界聊起。

在一个典型的电商 Web 页面中，你大概会这样设计数据结构（TypeScript）：

```ts
// 商品基础信息
interface Product {
  id: string;
  title: string;
  cover: string;
  price: number; // 可能是最低价
  tags: string[];
}

// SKU 信息（颜色、尺码组合）
interface Sku {
  id: string;
  productId: string;
  price: number;
  stock: number;
  attrs: Array<{ name: string; value: string }>; // 颜色=红, 尺码=L
}
```

在后端与数据库的世界里，我们通常会把它抽象成几个关键概念：

- **SPU (Standard Product Unit)**：标准产品单元
  - 一般对应商品详情页的“一个商品”，比如“耐克 Air Max 2025 跑鞋”。
  - 不包含具体的颜色/尺码，而是“一个款式”。
- **SKU (Stock Keeping Unit)**：库存量单位
  - 对应您在前端里渲染的“颜色 + 尺码”的具体组合。
  - 比如：`{ 颜色: 红色, 尺码: 42 }`。
- **Category (分类)**：
  - 对应前端里的面包屑导航、左侧分类树。
  - 一般是 **多级树形结构**：服装 → 男装 → 运动 → 跑鞋。
- **Attribute / Spec (属性/规格)**：
  - 属性名：颜色、尺码、材质、容量等。
  - 属性值：红色、蓝色、L、XL、32G、64G。

在本篇中，我们要做的事情有三个：

1. 用 MySQL 把这些概念“落地”为表结构。
2. 用 Go + GORM 把这些表结构映射成模型。
3. 顺手为后续的商品列表、购物车、订单、库存打好基础。

---

## 2. 表结构总览：要建哪些表？

我们先从全局设计出发，画一张简单的“脑内 ER 图”。

核心表：

- `categories`：商品分类表（树形结构）。
- `products`：SPU 表（商品基础信息）。
- `product_skus`：SKU 表（具体库存、价格）。
- `product_attrs`：商品属性表（键值结构）。
- `product_attr_values`：某个 SPU 下可选的属性值（可选，可简化）。

一个常见的简化设计如下：

```text
categories (分类)
  └── products (SPU)
        ├── product_skus (SKU)
        └── product_attrs (属性键值)
```

为什么要拆这么多张表？

- **解耦可变信息和不变信息**：
  - 分类、SPU 基础信息变化较少；
  - SKU 的库存、价格、条形码等，经常变化，需要高频更新。
- **便于扩展**：
  - 属性不固定（不同类目属性不同），需要一个灵活的键值结构。

接下来我们按照“从简单到复杂”的顺序：分类 → SPU → SKU → 属性，逐个落地。

---

## 3. 分类 Category 设计：树形结构的落地

### 3.1 数据表设计

分类一般是**多级树形结构**，最常见的做法是：

- 使用一张 `categories` 表，
- 通过 `parent_id` 来表示父节点，
- 根节点的 `parent_id = 0` 或 `NULL`。

SQL 示例：

```sql
CREATE TABLE `categories` (
  `id`           BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '分类ID',
  `name`         VARCHAR(64)     NOT NULL COMMENT '分类名称',
  `parent_id`    BIGINT UNSIGNED NOT NULL DEFAULT 0 COMMENT '父级ID，0表示顶级',
  `level`        TINYINT         NOT NULL DEFAULT 1 COMMENT '层级：1/2/3/...',
  `sort`         INT             NOT NULL DEFAULT 0 COMMENT '排序值，越大越靠前',
  `created_at`   DATETIME        NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at`   DATETIME        NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_parent` (`parent_id`),
  KEY `idx_level` (`level`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商品分类表';
```

### 3.2 Go + GORM 模型

在 Go 中：

```go
package model

import "time"

type Category struct {
    ID        uint64    `gorm:"primaryKey;autoIncrement" json:"id"`
    Name      string    `gorm:"size:64;not null" json:"name"`
    ParentID  uint64    `gorm:"not null;default:0" json:"parent_id"`
    Level     int8      `gorm:"not null;default:1" json:"level"`
    Sort      int       `gorm:"not null;default:0" json:"sort"`
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`

    // 下面两个字段不直接映射数据库，用于构造树
    Children []*Category `gorm:"-" json:"children,omitempty"`
}
```

对比 TypeScript：

```ts
interface Category {
  id: number;
  name: string;
  parentId: number;
  level: number;
  sort: number;
  children?: Category[];
}
```

差异点：

- Go 里需要用 `gorm:"-"` 显式声明“不映射数据库字段”。
- Go 没有 `?` 这种“可选属性”语法，但可以用 `omitempty` 在 JSON 输出时省略空值。

---

## 4. SPU 设计：`products` 表

SPU 是商品的“抽象款式”。

### 4.1 表结构设计

```sql
CREATE TABLE `products` (
  `id`             BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'SPU ID',
  `title`          VARCHAR(255)    NOT NULL COMMENT '商品标题',
  `sub_title`      VARCHAR(255)    NOT NULL DEFAULT '' COMMENT '副标题',
  `category_id`    BIGINT UNSIGNED NOT NULL COMMENT '所属分类ID',
  `cover_image`    VARCHAR(512)    NOT NULL DEFAULT '' COMMENT '主图',
  `price_min`      DECIMAL(10,2)   NOT NULL DEFAULT 0 COMMENT '最小价格',
  `price_max`      DECIMAL(10,2)   NOT NULL DEFAULT 0 COMMENT '最大价格',
  `status`         TINYINT         NOT NULL DEFAULT 1 COMMENT '状态：1上架 0下架',
  `stock_total`    INT             NOT NULL DEFAULT 0 COMMENT '总库存（冗余）',
  `sold_count`     INT             NOT NULL DEFAULT 0 COMMENT '销量（冗余）',
  `detail_html`    MEDIUMTEXT      NULL COMMENT '商品详情（富文本HTML）',
  `created_at`     DATETIME        NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at`     DATETIME        NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_category` (`category_id`),
  KEY `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商品SPU表';
```

说明：

- `price_min` / `price_max`：根据所有 SKU 的价格冗余出来，便于排序/筛选。
- `stock_total` / `sold_count`：从各个 SKU 汇总冗余，列表页就不用 join SKU 了。

### 4.2 Go + GORM 模型

```go
package model

import "time"

type ProductStatus int8

const (
    ProductStatusOff ProductStatus = 0
    ProductStatusOn  ProductStatus = 1
)

type Product struct {
    ID          uint64        `gorm:"primaryKey;autoIncrement" json:"id"`
    Title       string        `gorm:"size:255;not null" json:"title"`
    SubTitle    string        `gorm:"size:255;not null;default:''" json:"sub_title"`
    CategoryID  uint64        `gorm:"not null" json:"category_id"`
    CoverImage  string        `gorm:"size:512;not null;default:''" json:"cover_image"`
    PriceMin    float64       `gorm:"type:decimal(10,2);not null;default:0" json:"price_min"`
    PriceMax    float64       `gorm:"type:decimal(10,2);not null;default:0" json:"price_max"`
    Status      ProductStatus `gorm:"not null;default:1" json:"status"`
    StockTotal  int           `gorm:"not null;default:0" json:"stock_total"`
    SoldCount   int           `gorm:"not null;default:0" json:"sold_count"`
    DetailHTML  string        `gorm:"type:mediumtext" json:"detail_html"`
    CreatedAt   time.Time     `json:"created_at"`
    UpdatedAt   time.Time     `json:"updated_at"`

    // 关联字段
    Category *Category     `gorm:"foreignKey:CategoryID" json:"category,omitempty"`
    Skus     []*ProductSku `gorm:"foreignKey:ProductID" json:"skus,omitempty"`
}
```

对比 TypeScript：

```ts
interface Product {
  id: number;
  title: string;
  subTitle: string;
  categoryId: number;
  coverImage: string;
  priceMin: number;
  priceMax: number;
  status: 0 | 1;
  stockTotal: number;
  soldCount: number;
  detailHtml: string;
  category?: Category;
  skus?: Sku[];
}
```

差异点：

- Go 里用 `struct` + tag 描述数据库字段、JSON 字段；
- 枚举推荐用自定义类型 `ProductStatus`，更类型安全；
- 关联关系需要通过 `gorm:"foreignKey:CategoryID"` 显式声明。

---

## 5. SKU 设计：`product_skus` 表

SKU 是库存的最小单位，也是订单、购物车等模块操作的对象。

### 5.1 表结构设计

```sql
CREATE TABLE `product_skus` (
  `id`            BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'SKU ID',
  `product_id`    BIGINT UNSIGNED NOT NULL COMMENT '所属SPU ID',
  `title`         VARCHAR(255)    NOT NULL DEFAULT '' COMMENT 'SKU 标题，可选',
  `price`         DECIMAL(10,2)   NOT NULL DEFAULT 0 COMMENT '售价',
  `origin_price`  DECIMAL(10,2)   NOT NULL DEFAULT 0 COMMENT '原价',
  `stock`         INT             NOT NULL DEFAULT 0 COMMENT '库存',
  `sku_code`      VARCHAR(64)     NOT NULL DEFAULT '' COMMENT '商家编码/条码',
  `image`         VARCHAR(512)    NOT NULL DEFAULT '' COMMENT 'SKU 图片',
  `attrs`         JSON            NULL COMMENT '规格属性JSON, 如 [{"name":"颜色","value":"红"}]',
  `created_at`    DATETIME        NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at`    DATETIME        NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`),
  KEY `idx_product` (`product_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商品SKU表';
```

这里有一个设计取舍：

- 为了灵活，又不想复杂到建一堆中间表，
- 直接在 `product_skus.attrs` 里存 JSON 即可，
- 后端用 `[]SkuAttr` 解析，前端可以直接渲染。

### 5.2 Go + GORM 模型

```go
package model

import (
    "database/sql/driver"
    "encoding/json"
    "fmt"
    "time"
)

// SkuAttr 对应 attrs 中的每一项
// 例如: {"name":"颜色", "value":"红"}
type SkuAttr struct {
    Name  string `json:"name"`
    Value string `json:"value"`
}

// SkuAttrs 自定义类型，用于映射 JSON 列
type SkuAttrs []SkuAttr

// Value 实现 driver.Valuer 接口，将 Go 值转成 DB 值
func (a SkuAttrs) Value() (driver.Value, error) {
    if len(a) == 0 {
        return "[]", nil
    }
    b, err := json.Marshal(a)
    if err != nil {
        return nil, err
    }
    return string(b), nil
}

// Scan 实现 sql.Scanner 接口，将 DB 值转成 Go 值
func (a *SkuAttrs) Scan(src any) error {
    if src == nil {
        *a = SkuAttrs{}
        return nil
    }

    var data []byte
    switch v := src.(type) {
    case string:
        data = []byte(v)
    case []byte:
        data = v
    default:
        return fmt.Errorf("unsupported Scan type for SkuAttrs: %T", src)
    }

    if len(data) == 0 {
        *a = SkuAttrs{}
        return nil
    }

    return json.Unmarshal(data, a)
}

// ProductSku SKU 模型
type ProductSku struct {
    ID         uint64    `gorm:"primaryKey;autoIncrement" json:"id"`
    ProductID  uint64    `gorm:"not null" json:"product_id"`
    Title      string    `gorm:"size:255;not null;default:''" json:"title"`
    Price      float64   `gorm:"type:decimal(10,2);not null;default:0" json:"price"`
    OriginPrice float64  `gorm:"type:decimal(10,2);not null;default:0" json:"origin_price"`
    Stock      int       `gorm:"not null;default:0" json:"stock"`
    SkuCode    string    `gorm:"size:64;not null;default:''" json:"sku_code"`
    Image      string    `gorm:"size:512;not null;default:''" json:"image"`
    Attrs      SkuAttrs  `gorm:"type:json" json:"attrs"`
    CreatedAt  time.Time `json:"created_at"`
    UpdatedAt  time.Time `json:"updated_at"`

    Product *Product `gorm:"foreignKey:ProductID" json:"product,omitempty"`
}
```

对比 TypeScript：

```ts
interface SkuAttr {
  name: string;
  value: string;
}

interface ProductSku {
  id: number;
  productId: number;
  title: string;
  price: number;
  originPrice: number;
  stock: number;
  skuCode: string;
  image: string;
  attrs: SkuAttr[];
}
```

你可以把 `SkuAttrs` 理解成 Go 里手动实现了一个“自定义序列化的类型”，类似于在 TS 里写一个自定义 `toJSON` 的类。

---

## 6. 属性设计：`product_attrs` 表

很多电商平台会把属性拆成“平台属性”和“销售属性”，我们在实战里先做一个简化版本：

- 针对每个 SPU，存一张属性键值表。

### 6.1 表结构

```sql
CREATE TABLE `product_attrs` (
  `id`          BIGINT UNSIGNED NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `product_id`  BIGINT UNSIGNED NOT NULL COMMENT 'SPU ID',
  `name`        VARCHAR(64)     NOT NULL COMMENT '属性名，如 材质/产地',
  `value`       VARCHAR(255)    NOT NULL COMMENT '属性值，如 纯棉/中国',
  `sort`        INT             NOT NULL DEFAULT 0 COMMENT '排序',
  PRIMARY KEY (`id`),
  KEY `idx_product` (`product_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='商品属性表';
```

### 6.2 Go 模型

```go
package model

type ProductAttr struct {
    ID        uint64 `gorm:"primaryKey;autoIncrement" json:"id"`
    ProductID uint64 `gorm:"not null" json:"product_id"`
    Name      string `gorm:"size:64;not null" json:"name"`
    Value     string `gorm:"size:255;not null" json:"value"`
    Sort      int    `gorm:"not null;default:0" json:"sort"`
}
```

前端视角下，它大概就是：

```ts
interface ProductAttr {
  id: number;
  productId: number;
  name: string; // 材质
  value: string; // 纯棉
  sort: number;
}
```

在商品详情页时，可以直接映射成一个参数表：

```ts
const attrs: ProductAttr[] = await fetch(...);
```

---

## 7. 分类树 + 商品 + SKU 的组合查询示例

我们先写一段简单的“按分类分页查询商品列表，并预加载部分 SKU 信息”的代码，让你有个整体感知。

### 7.1 Gin + GORM Handler 示例

假设我们有一个路由：`GET /api/products`，支持按分类、关键字、分页查询：

```go
// handler/product.go

package handler

import (
    "net/http"
    "strconv"

    "github.com/gin-gonic/gin"
    "gorm.io/gorm"

    "yourapp/internal/model"
)

type ProductListRequest struct {
    CategoryID uint64 `form:"category_id"`
    Keyword    string `form:"keyword"`
    Page       int    `form:"page"`
    PageSize   int    `form:"page_size"`
}

type ProductListResponse struct {
    List  []model.Product `json:"list"`
    Total int64           `json:"total"`
}

func ProductList(db *gorm.DB) gin.HandlerFunc {
    return func(c *gin.Context) {
        var req ProductListRequest
        if err := c.ShouldBindQuery(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        if req.Page <= 0 {
            req.Page = 1
        }
        if req.PageSize <= 0 || req.PageSize > 100 {
            req.PageSize = 10
        }

        var (
            products []model.Product
            total    int64
        )

        query := db.Model(&model.Product{})

        if req.CategoryID > 0 {
            query = query.Where("category_id = ?", req.CategoryID)
        }
        if req.Keyword != "" {
            like := "%" + req.Keyword + "%"
            query = query.Where("title LIKE ? OR sub_title LIKE ?", like, like)
        }

        if err := query.Count(&total).Error; err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }

        if err := query.
            Preload("Skus", func(db *gorm.DB) *gorm.DB {
                return db.Select("id", "product_id", "price", "stock", "image", "attrs").
                    Limit(3) // 每个商品预加载最多3个SKU即可
            }).
            Order("id DESC").
            Offset((req.Page - 1) * req.PageSize).
            Limit(req.PageSize).
            Find(&products).Error; err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
            return
        }

        c.JSON(http.StatusOK, ProductListResponse{
            List:  products,
            Total: total,
        })
    }
}
```

对比前端的 Next.js/React：

```ts
// pages/products.tsx (仅示意)

export async function getServerSideProps(ctx: GetServerSidePropsContext) {
  const { category_id, keyword, page = '1' } = ctx.query;

  const res = await fetch(
    `${process.env.API_BASE}/api/products?category_id=${category_id}&keyword=${keyword}&page=${page}`,
  );

  const data: { list: Product[]; total: number } = await res.json();

  return { props: { data } };
}
```

你可以看到：

- Go 里的 Handler 更接近 Node.js 的 Koa/Express 中间件；
- 但由于有静态类型 + GORM 的 Model，写起来更有“约束感”，容易维护。

---

## 8. 初始化一些示例数据（Seeder 思路）

为了方便你本地跟着做，可以准备一个简单的“数据初始化脚本”。

### 8.1 创建分类 + 商品 + SKU

```go
// cmd/seed/main.go

package main

import (
    "log"

    "gorm.io/driver/mysql"
    "gorm.io/gorm"

    "yourapp/internal/model"
)

func main() {
    dsn := "root:password@tcp(127.0.0.1:3306)/shop?charset=utf8mb4&parseTime=True&loc=Local"
    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
    if err != nil {
        log.Fatal("failed to connect database:", err)
    }

    if err := db.AutoMigrate(&model.Category{}, &model.Product{}, &model.ProductSku{}, &model.ProductAttr{}); err != nil {
        log.Fatal("auto migrate error:", err)
    }

    cat := model.Category{
        Name:     "男士运动鞋",
        ParentID: 0,
        Level:    1,
        Sort:     10,
    }
    if err := db.Create(&cat).Error; err != nil {
        log.Fatal("create category error:", err)
    }

    product := model.Product{
        Title:      "耐克 Air Max 2025 跑鞋",
        SubTitle:   "轻量缓震，马拉松训练推荐",
        CategoryID: cat.ID,
        CoverImage: "https://example.com/images/airmax2025.jpg",
        Status:     model.ProductStatusOn,
    }
    if err := db.Create(&product).Error; err != nil {
        log.Fatal("create product error:", err)
    }

    skus := []model.ProductSku{
        {
            ProductID: product.ID,
            Title:     "红色 42码",
            Price:     799.00,
            OriginPrice: 999.00,
            Stock:     50,
            SkuCode:   "AIRMAX2025-RED-42",
            Image:     "https://example.com/images/airmax2025-red-42.jpg",
            Attrs: model.SkuAttrs{
                {Name: "颜色", Value: "红色"},
                {Name: "尺码", Value: "42"},
            },
        },
        {
            ProductID: product.ID,
            Title:     "蓝色 41码",
            Price:     789.00,
            OriginPrice: 999.00,
            Stock:     30,
            SkuCode:   "AIRMAX2025-BLUE-41",
            Image:     "https://example.com/images/airmax2025-blue-41.jpg",
            Attrs: model.SkuAttrs{
                {Name: "颜色", Value: "蓝色"},
                {Name: "尺码", Value: "41"},
            },
        },
    }

    if err := db.Create(&skus).Error; err != nil {
        log.Fatal("create skus error:", err)
    }

    attrs := []model.ProductAttr{
        {ProductID: product.ID, Name: "适用场景", Value: "路跑", Sort: 10},
        {ProductID: product.ID, Name: "鞋面材质", Value: "织物", Sort: 9},
        {ProductID: product.ID, Name: "产地", Value: "中国", Sort: 8},
    }
    if err := db.Create(&attrs).Error; err != nil {
        log.Fatal("create attrs error:", err)
    }
}
```

有了这些数据，你就可以：

1. 打开 MySQL 看看真实表结构；
2. 用 Postman / Thunder Client 调一下 `GET /api/products`；
3. 在 Next.js 里写一个简单的商品列表页消费这些数据。

---

## 9. 和前端心智模型做一个总结

从前端视角看，上面的设计大致对应：

- `categories` → 分类菜单 / 面包屑导航的数据源；
- `products` → 列表页的 `ProductCard`、详情页的基础信息；
- `product_skus` → 规格选择组件 `SkuSelector` 的数据源，也是购物车/订单的核心；
- `product_attrs` → 商品详情页“参数信息表格”的数据源。

对比 TypeScript：

- TS 接口更多是“前端展示需要的字段组合”；
- Go struct / MySQL table 更多是“数据存储和关联的真实形态”；
- 在实践中，你可以在后端额外定义一个 `DTO` struct 专门用于接口返回，跟数据库结构解耦。

---

## 10. 下一步：为高性能查询做准备

本篇我们完成了：

1. 明确电商领域的几个关键概念（SPU、SKU、分类、属性）；
2. 设计了 `categories`、`products`、`product_skus`、`product_attrs` 等核心表结构；
3. 用 Go + GORM 写出了对应的模型和部分初始化代码；
4. 写了一个基础的商品列表接口示例，方便前端 Next.js 对接。

在下一篇《实战二：商品列表与详情页的高性能查询》中，我们会在这些模型的基础上继续向前走：

- 如何优雅地构建**动态查询条件**（类似前端写一堆 `if (xxx) {}` 拼 URL 参数）；
- 如何用 **Redis 做商品详情缓存**，解决高并发读问题；
- 如何在 Next.js 16 中通过 **SSR/SSG** 获取这些数据，兼顾 SEO 与性能。

你可以先在本地把这些表和模型跑起来，有任何地方不理解的，可以在对应章节旁边直接做标记，我可以再帮你针对性扩写。