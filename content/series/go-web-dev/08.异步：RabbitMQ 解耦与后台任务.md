---
title: "异步：RabbitMQ 解耦与后台任务"
description: "构建高可用系统的关键组件。引入 RabbitMQ 消息队列，实现用户注册后的异步邮件发送。理解生产者-消费者模型，掌握削峰填谷的原理。"
date: "2025-12-10"
seriesOrder: 8
---

# 8. 异步：RabbitMQ 解耦与后台任务

## 引言

在用户注册成功后，我们通常需要发送一封欢迎邮件。
如果直接在 API 接口中同步发送邮件，可能会因为邮件服务器响应慢（比如 2 秒），导致用户感觉注册接口很卡。

**消息队列 (Message Queue)** 就是为了解决这个问题。我们将耗时的任务封装成消息，扔进队列，然后立即返回成功给用户。后台有一个 Worker 慢慢消费这些消息。

本章我们将使用 **RabbitMQ** 来实现这一机制。

## 1. RabbitMQ 基础概念

-   **Producer (生产者)**: 发送消息的程序（我们的 API Server）。
-   **Queue (队列)**: 存储消息的缓冲区。
-   **Consumer (消费者)**: 接收并处理消息的程序（后台 Worker）。
-   **Exchange (交换机)**: 接收生产者的消息，并根据规则路由到队列。

## 2. 初始化 RabbitMQ

安装 Go 客户端：

```bash
go get github.com/rabbitmq/amqp091-go
```

创建 `pkg/mq/rabbitmq.go`：

```go
package mq

import (
	"log"

	amqp "github.com/rabbitmq/amqp091-go"
)

var Conn *amqp.Connection
var Channel *amqp.Channel

func InitRabbitMQ() {
	var err error
	// 实际应从 config 读取
	url := "amqp://guest:guest@localhost:5672/"
	
	Conn, err = amqp.Dial(url)
	if err != nil {
		log.Fatalf("Failed to connect to RabbitMQ: %v", err)
	}

	Channel, err = Conn.Channel()
	if err != nil {
		log.Fatalf("Failed to open a channel: %v", err)
	}

	// 声明队列 (幂等操作，不存在则创建)
	_, err = Channel.QueueDeclare(
		"email_queue", // name
		true,          // durable (持久化)
		false,         // delete when unused
		false,         // exclusive
		false,         // no-wait
		nil,           // arguments
	)
	if err != nil {
		log.Fatalf("Failed to declare a queue: %v", err)
	}
}
```

## 3. 生产者：发送消息

修改 `internal/service/user_service.go`，在注册成功后发送消息。

```go
import (
	"context"
	"encoding/json"
	"go-blog-api/pkg/mq"
	amqp "github.com/rabbitmq/amqp091-go"
)

type EmailTask struct {
	Email    string `json:"email"`
	Username string `json:"username"`
}

func (s *UserService) Register(req *RegisterRequest) error {
	// ... 原有的注册逻辑 ...
	// if err := s.userRepo.Create(user); err != nil { return err }

	// 异步发送邮件
	task := EmailTask{
		Email:    req.Email,
		Username: req.Username,
	}
	body, _ := json.Marshal(task)

	err := mq.Channel.PublishWithContext(context.Background(),
		"",            // exchange
		"email_queue", // routing key (queue name)
		false,         // mandatory
		false,         // immediate
		amqp.Publishing{
			ContentType: "application/json",
			Body:        body,
		})
	
	if err != nil {
		// 记录日志，但不影响注册流程
		log.Printf("Failed to publish message: %v", err)
	}

	return nil
}
```

## 4. 消费者：处理消息

我们需要一个独立的 Goroutine 来消费消息。通常可以在 `main.go` 启动时开启，或者单独写一个 Worker 程序。

创建 `internal/worker/email_worker.go`：

```go
package worker

import (
	"encoding/json"
	"go-blog-api/pkg/mq"
	"log"
	"time"
)

type EmailTask struct {
	Email    string `json:"email"`
	Username string `json:"username"`
}

func StartEmailWorker() {
	msgs, err := mq.Channel.Consume(
		"email_queue", // queue
		"",            // consumer
		true,          // auto-ack (自动确认)
		false,         // exclusive
		false,         // no-local
		false,         // no-wait
		nil,           // args
	)
	if err != nil {
		log.Fatalf("Failed to register a consumer: %v", err)
	}

	go func() {
		for d := range msgs {
			var task EmailTask
			json.Unmarshal(d.Body, &task)

			log.Printf("Sending email to %s...", task.Email)
			// 模拟耗时操作
			time.Sleep(2 * time.Second)
			log.Printf("Email sent to %s successfully!", task.Email)
		}
	}()
	
	log.Println("Email Worker started")
}
```

在 `cmd/server/main.go` 中启动 Worker：

```go
func main() {
    config.InitConfig()
    mq.InitRabbitMQ()
    
    // 启动后台 Worker
    worker.StartEmailWorker()
    
    // ... 启动 HTTP Server
}
```

## 5. 削峰填谷

除了异步解耦，MQ 的另一个重要作用是**削峰**。

假设双十一期间，每秒有 10000 个下单请求。如果直接打到数据库，数据库必死无疑。
我们可以把请求先写入 MQ。后台 Worker 按照数据库能承受的速度（比如每秒处理 2000 个）慢慢消费。

这就好比大坝（MQ）拦截了洪水，下游（数据库）依然风平浪静。

## 6. 总结

本章我们完成了：
1.  **RabbitMQ 集成**：实现了消息的生产与消费。
2.  **异步解耦**：将邮件发送逻辑从注册接口中剥离，提升了接口响应速度。
3.  **Worker 模式**：使用 Goroutine 在后台持续处理任务。

**下一章预告**：
代码写完了，怎么保证质量？下一章我们将学习如何编写 **单元测试 (Unit Test)**，并使用 **Swagger** 自动生成漂亮的接口文档，让前端开发者爱上对接你的 API。
