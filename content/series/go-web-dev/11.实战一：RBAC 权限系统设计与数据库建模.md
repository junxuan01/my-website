---
title: "实战一：RBAC 权限系统设计与数据库建模"
description: "开启第一个实战项目：企业级 RBAC 权限管理系统。深入理解 RBAC 模型，设计 User-Role-Permission 数据库表结构，并使用 GORM 定义多对多关联模型。"
date: "2025-12-13"
seriesOrder: 11
---

# 11. 实战一：RBAC 权限系统设计与数据库建模

## 引言

在前面的 10 篇文章中，我们已经掌握了 Go Web 开发的核心技能：Gin 框架、GORM 数据库操作、Redis 缓存、RabbitMQ 异步消息以及 Docker 部署。

从本章开始，我们将进入**实战项目阶段**。我们将综合运用之前学到的所有知识，构建一个**企业级 RBAC (Role-Based Access Control) 权限管理系统**。

这不仅仅是一个 Demo，我们将按照**生产环境标准**来开发，考虑到前端（Next.js 16 + Ant Design 6）的对接需求，以及系统的扩展性。

## 1. 项目概览

### 1.1 什么是 RBAC？

在简单的系统中，我们可能只需要一个 `is_admin` 字段来区分管理员和普通用户。但在复杂的企业应用中，权限需求往往非常灵活：
-   财务只能看报表，不能改代码。
-   HR 只能看员工信息，不能看财务报表。
-   运维只能重启服务器，不能修改业务数据。

**RBAC (基于角色的访问控制)** 是解决这个问题的标准模型。它的核心思想是：**用户不直接关联权限，而是关联角色；角色再关联权限。**

```mermaid
graph LR
    User(用户) -->|拥有| Role(角色)
    Role -->|拥有| Permission(权限/菜单)
```

### 1.2 技术栈选型

为了配合前端同学的最新技术栈，我们的后端也将采用最新的 Go 生态：

-   **语言**: Go 1.25
-   **Web 框架**: Gin
-   **数据库**: MySQL 8.0
-   **ORM**: GORM
-   **缓存**: Redis 7.0
-   **权限引擎**: Casbin (后续章节引入)
-   **前端对接**: Next.js 16 + TypeScript + Ant Design 6

## 2. 数据库设计 (Database Design)

RBAC 模型最核心的是 **5 张表**：
1.  **Users**: 用户表
2.  **Roles**: 角色表
3.  **Permissions**: 权限/菜单表
4.  **User_Roles**: 用户-角色关联表 (多对多)
5.  **Role_Permissions**: 角色-权限关联表 (多对多)

### 2.1 用户表 (sys_users)

除了基本的用户名密码，我们需要记录用户的状态（正常/禁用）。

| 字段名 | 类型 | 说明 |
|---|---|---|
| id | bigint | 主键 |
| username | varchar | 用户名 |
| password | varchar | 加密后的密码 |
| nickname | varchar | 昵称 |
| avatar | varchar | 头像 |
| status | tinyint | 1:正常, 2:禁用 |

### 2.2 角色表 (sys_roles)

角色表定义了系统中有哪些身份，如 "超级管理员", "财务经理"。

| 字段名 | 类型 | 说明 |
|---|---|---|
| id | bigint | 主键 |
| name | varchar | 角色名称 (如: admin) |
| name_zh | varchar | 中文名称 (如: 超级管理员) |
| desc | varchar | 描述 |

### 2.3 权限/菜单表 (sys_menus)

在前后端分离的系统中，权限通常对应两个概念：
1.  **前端菜单/按钮**：用户能看到哪些页面。
2.  **后端 API**：用户能调用哪些接口。

为了简化设计，我们将这两者统一管理，称为“菜单权限”。

| 字段名 | 类型 | 说明 |
|---|---|---|
| id | bigint | 主键 |
| parent_id | bigint | 父菜单 ID (实现树形结构) |
| path | varchar | 前端路由路径 (如 /sys/users) |
| component | varchar | 前端组件路径 |
| title | varchar | 菜单标题 |
| icon | varchar | 菜单图标 |
| sort | int | 排序 |
| type | tinyint | 1:目录, 2:菜单, 3:按钮 |
| permission | varchar | 权限标识 (如 user:list, user:add) |

**前端对比 (TypeScript Interface):**
这非常像我们在 Ant Design Pro 中定义的路由配置：
```typescript
interface MenuItem {
  path: string;
  name: string;
  icon?: string;
  routes?: MenuItem[]; // 子菜单
}
```

## 3. GORM 模型定义

让我们在 `internal/model` 下定义这些结构体。

### 3.1 基础模型 (BaseModel)

复用之前的 `BaseModel`，但为了支持软删除和更精确的时间控制，我们稍作调整。

```go
package model

import (
	"time"
	"gorm.io/gorm"
)

type BaseModel struct {
	ID        uint           `gorm:"primarykey" json:"id"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
	DeletedAt gorm.DeletedAt `gorm:"index" json:"-"`
}
```

### 3.2 角色模型 (Role)

```go
package model

type Role struct {
	BaseModel
	Name   string `gorm:"type:varchar(50);uniqueIndex;not null" json:"name"`    // 唯一标识，如 admin
	NameZh string `gorm:"type:varchar(50);not null" json:"name_zh"`             // 中文名
	Desc   string `gorm:"type:varchar(255)" json:"desc"`
	Status int    `gorm:"type:tinyint;default:1" json:"status"`                 // 1:启用 0:禁用

	// 多对多关联：一个角色有多个菜单
	Menus []*Menu `gorm:"many2many:sys_role_menus;" json:"menus,omitempty"`
}

func (Role) TableName() string {
	return "sys_roles"
}
```

### 3.3 菜单模型 (Menu)

```go
package model

type Menu struct {
	BaseModel
	ParentID   uint   `gorm:"index" json:"parent_id"`
	Path       string `gorm:"type:varchar(100)" json:"path"`
	Component  string `gorm:"type:varchar(255)" json:"component"`
	Title      string `gorm:"type:varchar(50);not null" json:"title"`
	Icon       string `gorm:"type:varchar(50)" json:"icon"`
	Sort       int    `gorm:"default:0" json:"sort"`
	Type       int    `gorm:"type:tinyint;comment:1:目录 2:菜单 3:按钮" json:"type"`
	Permission string `gorm:"type:varchar(50)" json:"permission"` // 权限标识，如 user:add

	// 自引用关联：子菜单
	Children []*Menu `gorm:"-" json:"children,omitempty"` // gorm:"-" 表示不映射到数据库字段，仅用于 JSON 输出
}

func (Menu) TableName() string {
	return "sys_menus"
}
```

### 3.4 用户模型 (User) - 更新版

我们需要更新之前的 `User` 模型，加入与 `Role` 的多对多关联。

```go
package model

type User struct {
	BaseModel
	Username string `gorm:"type:varchar(100);uniqueIndex;not null" json:"username"`
	Password string `gorm:"type:varchar(255);not null" json:"-"`
	Nickname string `gorm:"type:varchar(50)" json:"nickname"`
	Email    string `gorm:"type:varchar(100)" json:"email"`
	Avatar   string `gorm:"type:varchar(255)" json:"avatar"`
	Status   int    `gorm:"type:tinyint;default:1" json:"status"` // 1:正常 2:禁用

	// 多对多关联：一个用户有多个角色
	Roles []*Role `gorm:"many2many:sys_user_roles;" json:"roles,omitempty"`
}

func (User) TableName() string {
	return "sys_users"
}
```

## 4. 关联关系解析

在 GORM 中，`many2many` 标签会自动创建中间表。

1.  **User <-> Role**: GORM 会自动创建 `sys_user_roles` 表，包含 `user_id` 和 `role_id`。
2.  **Role <-> Menu**: GORM 会自动创建 `sys_role_menus` 表，包含 `role_id` 和 `menu_id`。

这完全符合我们设计的 5 张表结构，而且不需要手动定义中间表的 Struct（除非中间表有额外字段）。

## 5. 初始化与迁移

修改 `cmd/server/main.go` 或 `pkg/db/db.go` 中的迁移逻辑，确保新模型被注册。

```go
func InitDB() {
    // ... 连接数据库代码 ...

    // 自动迁移
    err := DB.AutoMigrate(
        &model.User{},
        &model.Role{},
        &model.Menu{},
    )
    if err != nil {
        log.Fatalf("AutoMigrate failed: %v", err)
    }
}
```

## 6. 预置数据 (Seeding)

为了方便开发，我们需要在系统启动时预置一些基础数据（如超级管理员账号、基础菜单）。

创建一个 `internal/service/init_service.go`：

```go
package service

import (
	"errors"
	"go-blog-api/internal/model"
	"go-blog-api/pkg/db"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
	"log"
)

func InitData() {
	// 1. 检查是否已初始化
	var count int64
	db.DB.Model(&model.User{}).Count(&count)
	if count > 0 {
		return
	}

	// 2. 创建超级管理员角色
	adminRole := model.Role{
		Name:   "admin",
		NameZh: "超级管理员",
		Desc:   "拥有所有权限",
		Status: 1,
	}
	db.DB.Create(&adminRole)

	// 3. 创建超级管理员用户
	hashedPwd, _ := bcrypt.GenerateFromPassword([]byte("123456"), bcrypt.DefaultCost)
	adminUser := model.User{
		Username: "admin",
		Password: string(hashedPwd),
		Nickname: "Super Admin",
		Status:   1,
		Roles:    []*model.Role{&adminRole}, // 关联角色
	}
	db.DB.Create(&adminUser)

	log.Println("Default data initialized: admin / 123456")
}
```

别忘了在 `main.go` 启动时调用 `service.InitData()`。

## 7. 总结

本章我们完成了 RBAC 系统的基石建设：
1.  **理论基础**：理解了 User-Role-Permission 的三角关系。
2.  **数据库设计**：设计了 5 张核心表，涵盖了用户、角色、菜单及其关联。
3.  **GORM 实战**：使用 `many2many` 标签优雅地处理了多对多关系，并实现了数据初始化。

**前端同学请注意**：
数据库中的 `sys_menus` 表结构是扁平的，但前端 Ant Design 的 `Menu` 组件需要树形结构（Tree）。在后续章节中，我们将在后端实现**递归算法**，将扁平的数据库记录转换为前端需要的 Tree JSON。

**下一章预告**：
有了数据库，下一步就是**登录认证**。我们将升级之前的 JWT 认证机制，加入 **Refresh Token** 以实现无感续期，并实现**强制下线**功能（结合 Redis 黑名单）。
