---
title: "实战一：RBAC 权限系统设计与数据库建模"
description: "开启第一个实战项目：企业级 RBAC 权限管理系统。深入理解 RBAC 模型，设计 User-Role-Permission 数据库表结构，并使用 GORM 定义多对多关联模型。"
date: "2025-12-13"
seriesOrder: 11
---

# 11. 实战一：RBAC 权限系统设计与数据库建模

## 引言

在前面的 10 篇文章中，我们已经掌握了 Go Web 开发的核心技能：Gin 框架、GORM 数据库操作、Redis 缓存、RabbitMQ 异步消息以及 Docker 部署。

从本章开始，我们将进入**实战项目阶段**。我们将综合运用之前学到的所有知识，构建一个**企业级 RBAC (Role-Based Access Control) 权限管理系统**。

这不仅仅是一个 Demo，我们将按照**生产环境标准**来开发，考虑到前端（Next.js 16 + Ant Design 6）的对接需求，以及系统的扩展性。

> **前端同学特别说明**：
> 
> 你在前端项目中可能用过 **路由守卫**（如 Next.js 的 middleware 或 React Router 的权限 HOC）、**菜单配置**（侧边栏根据用户角色动态显示）、**按钮权限**（某些按钮只有管理员能看到）。
> 
> 这些前端层面的"权限控制"本质上依赖后端返回的数据：**你是什么角色？你能访问哪些菜单？你能操作哪些按钮？**
> 
> 本章我们要做的，就是在后端设计一套数据结构，把"谁能做什么"这件事存到数据库里，然后通过接口告诉前端。

### 本章目标

学完这一章，你将能够：

1. 理解 RBAC 模型的核心思想：用户 → 角色 → 权限的三角关系；
2. 设计出 5 张核心数据库表，并理解"多对多关联"在 MySQL 中如何实现；
3. 使用 GORM 的 `many2many` 标签定义模型，让框架自动管理中间表；
4. 编写种子数据脚本，初始化超级管理员账号。

## 1. 项目概览

### 1.1 什么是 RBAC？—— 从前端权限控制说起

在简单的系统中，我们可能只需要一个 `is_admin` 字段来区分管理员和普通用户。但在复杂的企业应用中，权限需求往往非常灵活：

-   财务只能看报表，不能改代码。
-   HR 只能看员工信息，不能看财务报表。
-   运维只能重启服务器，不能修改业务数据。

如果你写过前端权限，可能会这样处理：

```tsx
// 前端伪代码：根据用户角色决定显示什么
if (user.role === 'admin') {
  showAllMenus();
} else if (user.role === 'editor') {
  showEditorMenus();
}
```

但这种硬编码的方式有两个问题：

1. **不灵活**：新增角色要改代码；
2. **不安全**：前端只是"不显示"，用户依然可以直接调 API。

**RBAC (基于角色的访问控制)** 是解决这个问题的标准模型。它的核心思想是：

> **用户不直接关联权限，而是关联角色；角色再关联权限。**

用一张图来理解：

```
用户 (User)
   │
   │ 拥有（多对多）
   ▼
角色 (Role)
   │
   │ 拥有（多对多）
   ▼
权限/菜单 (Permission/Menu)
```

这样做的好处：

- **灵活配置**：新员工入职，只需要给他分配一个"角色"，他就自动拥有该角色的所有权限；
- **统一管理**：修改某个角色的权限，所有拥有该角色的用户都会生效；
- **前后端协同**：后端负责"判断"，前端负责"展示"，各司其职。

### 1.2 技术栈选型

为了配合前端同学的最新技术栈，我们的后端也将采用最新的 Go 生态：

-   **语言**: Go 1.25
-   **Web 框架**: Gin
-   **数据库**: MySQL 8.0
-   **ORM**: GORM
-   **缓存**: Redis 7.0
-   **权限引擎**: Casbin (后续章节引入)
-   **前端对接**: Next.js 16 + TypeScript + Ant Design 6

## 2. 数据库设计 (Database Design)

### 2.0 前端同学的 MySQL 快速入门

如果你之前没接触过 MySQL，可以把它想象成一个**超大的 Excel 工作簿**：

| 概念 | Excel 类比 | 说明 |
|---|---|---|
| 数据库 (Database) | 工作簿文件 | 一个项目通常对应一个数据库 |
| 表 (Table) | 工作表 (Sheet) | 如"用户表"、"订单表" |
| 行 (Row) | 一行数据 | 一条记录，如一个用户 |
| 列 (Column) | 列标题 | 字段，如"用户名"、"密码" |
| 主键 (Primary Key) | 行号 | 每行的唯一标识，通常是自增的 `id` |
| 外键 (Foreign Key) | 跨表引用 | 一张表的某个字段，引用另一张表的主键 |

在 RBAC 系统中，我们会用到一种特殊的关系——**多对多 (Many-to-Many)**：

- 一个用户可以有多个角色（比如张三既是"编辑"又是"审核员"）；
- 一个角色可以被多个用户拥有（比如"编辑"角色被 10 个人使用）。

在 MySQL 中，多对多关系需要借助**中间表**（也叫关联表）来实现。中间表只存两列：两张主表的 ID。

RBAC 模型最核心的是 **5 张表**：

1.  **sys_users**: 用户表
2.  **sys_roles**: 角色表
3.  **sys_menus**: 权限/菜单表
4.  **sys_user_roles**: 用户-角色关联表（中间表，多对多）
5.  **sys_role_menus**: 角色-权限关联表（中间表，多对多）

### 2.1 用户表 (sys_users)

除了基本的用户名密码，我们需要记录用户的状态（正常/禁用）。

| 字段名 | 类型 | 说明 |
|---|---|---|
| id | bigint | 主键 |
| username | varchar | 用户名 |
| password | varchar | 加密后的密码 |
| nickname | varchar | 昵称 |
| avatar | varchar | 头像 |
| status | tinyint | 1:正常, 2:禁用 |

### 2.2 角色表 (sys_roles)

角色表定义了系统中有哪些身份，如 "超级管理员", "财务经理"。

| 字段名 | 类型 | 说明 |
|---|---|---|
| id | bigint | 主键 |
| name | varchar | 角色名称 (如: admin) |
| name_zh | varchar | 中文名称 (如: 超级管理员) |
| desc | varchar | 描述 |

### 2.3 权限/菜单表 (sys_menus)

在前后端分离的系统中，权限通常对应两个概念：

1.  **前端菜单/按钮**：用户能看到哪些页面、哪些按钮。
2.  **后端 API**：用户能调用哪些接口。

为了简化设计，我们将这两者统一管理，称为"菜单权限"。

| 字段名 | 类型 | 说明 |
|---|---|---|
| id | bigint | 主键 |
| parent_id | bigint | 父菜单 ID (实现树形结构) |
| path | varchar | 前端路由路径 (如 /sys/users) |
| component | varchar | 前端组件路径 |
| title | varchar | 菜单标题 |
| icon | varchar | 菜单图标 |
| sort | int | 排序 |
| type | tinyint | 1:目录, 2:菜单, 3:按钮 |
| permission | varchar | 权限标识 (如 user:list, user:add) |

**前端对比 (TypeScript Interface)**:

这非常像我们在 Ant Design Pro 或 Next.js 项目中定义的路由配置：

```typescript
// 前端路由配置示例
interface MenuItem {
  path: string;
  name: string;
  icon?: string;
  children?: MenuItem[]; // 子菜单，形成树形结构
}
```

数据库里存的是**扁平结构**（通过 `parent_id` 指向父级），前端需要的是**树形结构**（嵌套的 `children`）。后面章节我们会写一个递归算法，把扁平数据转成树。

## 3. GORM 模型定义

让我们在 `internal/model` 下定义这些结构体。

### 3.1 基础模型 (BaseModel)

复用之前的 `BaseModel`，但为了支持软删除和更精确的时间控制，我们稍作调整。

```go
package model

import (
	"time"
	"gorm.io/gorm"
)

type BaseModel struct {
	ID        uint           `gorm:"primarykey" json:"id"`
	CreatedAt time.Time      `json:"created_at"`
	UpdatedAt time.Time      `json:"updated_at"`
	DeletedAt gorm.DeletedAt `gorm:"index" json:"-"`
}
```

### 3.2 角色模型 (Role)

```go
package model

type Role struct {
	BaseModel
	Name   string `gorm:"type:varchar(50);uniqueIndex;not null" json:"name"`    // 唯一标识，如 admin
	NameZh string `gorm:"type:varchar(50);not null" json:"name_zh"`             // 中文名
	Desc   string `gorm:"type:varchar(255)" json:"desc"`
	Status int    `gorm:"type:tinyint;default:1" json:"status"`                 // 1:启用 0:禁用

	// 多对多关联：一个角色有多个菜单
	Menus []*Menu `gorm:"many2many:sys_role_menus;" json:"menus,omitempty"`
}

func (Role) TableName() string {
	return "sys_roles"
}
```

### 3.3 菜单模型 (Menu)

```go
package model

type Menu struct {
	BaseModel
	ParentID   uint   `gorm:"index" json:"parent_id"`
	Path       string `gorm:"type:varchar(100)" json:"path"`
	Component  string `gorm:"type:varchar(255)" json:"component"`
	Title      string `gorm:"type:varchar(50);not null" json:"title"`
	Icon       string `gorm:"type:varchar(50)" json:"icon"`
	Sort       int    `gorm:"default:0" json:"sort"`
	Type       int    `gorm:"type:tinyint;comment:1:目录 2:菜单 3:按钮" json:"type"`
	Permission string `gorm:"type:varchar(50)" json:"permission"` // 权限标识，如 user:add

	// 自引用关联：子菜单
	Children []*Menu `gorm:"-" json:"children,omitempty"` // gorm:"-" 表示不映射到数据库字段，仅用于 JSON 输出
}

func (Menu) TableName() string {
	return "sys_menus"
}
```

### 3.4 用户模型 (User) - 更新版

我们需要更新之前的 `User` 模型，加入与 `Role` 的多对多关联。

```go
package model

type User struct {
	BaseModel
	Username string `gorm:"type:varchar(100);uniqueIndex;not null" json:"username"`
	Password string `gorm:"type:varchar(255);not null" json:"-"`
	Nickname string `gorm:"type:varchar(50)" json:"nickname"`
	Email    string `gorm:"type:varchar(100)" json:"email"`
	Avatar   string `gorm:"type:varchar(255)" json:"avatar"`
	Status   int    `gorm:"type:tinyint;default:1" json:"status"` // 1:正常 2:禁用

	// 多对多关联：一个用户有多个角色
	Roles []*Role `gorm:"many2many:sys_user_roles;" json:"roles,omitempty"`
}

func (User) TableName() string {
	return "sys_users"
}
```

## 4. 关联关系解析

在 GORM 中，`many2many` 标签会自动创建中间表。

1.  **User <-> Role**: GORM 会自动创建 `sys_user_roles` 表，包含 `user_id` 和 `role_id`。
2.  **Role <-> Menu**: GORM 会自动创建 `sys_role_menus` 表，包含 `role_id` 和 `menu_id`。

这完全符合我们设计的 5 张表结构，而且不需要手动定义中间表的 Struct（除非中间表有额外字段）。

## 5. 初始化与迁移

修改 `cmd/server/main.go` 或 `pkg/db/db.go` 中的迁移逻辑，确保新模型被注册。

```go
func InitDB() {
    // ... 连接数据库代码 ...

    // 自动迁移
    err := DB.AutoMigrate(
        &model.User{},
        &model.Role{},
        &model.Menu{},
    )
    if err != nil {
        log.Fatalf("AutoMigrate failed: %v", err)
    }
}
```

## 6. 预置数据 (Seeding)

为了方便开发，我们需要在系统启动时预置一些基础数据（如超级管理员账号、基础菜单）。

创建一个 `internal/service/init_service.go`：

```go
package service

import (
	"errors"
	"go-blog-api/internal/model"
	"go-blog-api/pkg/db"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
	"log"
)

func InitData() {
	// 1. 检查是否已初始化
	var count int64
	db.DB.Model(&model.User{}).Count(&count)
	if count > 0 {
		return
	}

	// 2. 创建超级管理员角色
	adminRole := model.Role{
		Name:   "admin",
		NameZh: "超级管理员",
		Desc:   "拥有所有权限",
		Status: 1,
	}
	db.DB.Create(&adminRole)

	// 3. 创建超级管理员用户
	hashedPwd, _ := bcrypt.GenerateFromPassword([]byte("123456"), bcrypt.DefaultCost)
	adminUser := model.User{
		Username: "admin",
		Password: string(hashedPwd),
		Nickname: "Super Admin",
		Status:   1,
		Roles:    []*model.Role{&adminRole}, // 关联角色
	}
	db.DB.Create(&adminUser)

	log.Println("Default data initialized: admin / 123456")
}
```

别忘了在 `main.go` 启动时调用 `service.InitData()`。

## 7. 本章小结与练习

这一章，我们从"前端权限控制"的实际需求出发，完成了 RBAC 系统的基石建设：

1. **RBAC 模型**：理解了"用户 → 角色 → 权限"的三角关系，明白了为什么不直接给用户分配权限；
2. **数据库设计**：设计了 5 张核心表（用户、角色、菜单 + 两张中间表），理解了 MySQL 中多对多关系的实现方式；
3. **GORM 多对多**：使用 `many2many` 标签让 GORM 自动管理中间表，不需要手动定义关联表的 Struct；
4. **种子数据**：编写了初始化脚本，确保系统启动时有可用的管理员账号。

> **前端同学请注意**：
> 
> 数据库中的 `sys_menus` 表是**扁平结构**（每行一个菜单，通过 `parent_id` 关联），但前端 Ant Design 的 `Menu` 组件需要**树形结构**（嵌套的 `children` 数组）。
> 
> 在后续章节中，我们将在后端实现**递归算法**，将扁平的数据库记录转换为前端需要的 Tree JSON。这个算法和你在前端用 JS 写 `arrayToTree` 的思路是一样的，只不过换成了 Go 语法。

### 思考题 / 练习

1. **理解中间表**：
   - 打开数据库客户端（如 Navicat、DBeaver 或命令行 `mysql`），查看 `sys_user_roles` 和 `sys_role_menus` 两张中间表的结构；
   - 给 `admin` 用户再分配一个新角色，观察 `sys_user_roles` 表的变化。

2. **扩展用户模型**：
   - 为 `sys_users` 表增加 `phone`（手机号）和 `last_login_at`（最后登录时间）字段；
   - 修改 GORM 的 `User` 结构体，重新运行 `AutoMigrate`，观察数据库表结构的变化。

3. **思考权限粒度**：
   - 目前我们把"菜单"和"按钮"都放在 `sys_menus` 表，用 `type` 字段区分；
   - 如果后续需要支持"数据权限"（比如"只能看自己部门的数据"），应该如何扩展数据库设计？

> 建议你在本地把这一章的代码跑起来，用 `docker exec -it mysql mysql -uroot -p` 进入 MySQL 命令行，执行 `SELECT * FROM sys_users;` 等语句，亲眼看看数据是怎么存的。
