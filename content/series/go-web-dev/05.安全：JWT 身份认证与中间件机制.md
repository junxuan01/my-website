---
title: "安全：JWT 身份认证与中间件机制"
description: "构建安全的 API 服务。深入理解 JWT 原理，实现用户登录与 Token 签发。编写 Gin 中间件实现统一鉴权与上下文传递。"
date: "2025-12-07"
seriesOrder: 5
---

# 5. 安全：JWT 身份认证与中间件机制

## 引言

HTTP 是无状态协议。为了识别用户身份，我们通常有两种方案：
1.  **Session + Cookie**: 传统的服务端 Session 模式，依赖 Cookie，不适合移动端和分布式场景。
2.  **Token (JWT)**: 现代 Web 应用的主流方案。服务端不保存状态，Token 自带用户信息和签名。

本章我们将实现基于 **JWT (JSON Web Token)** 的登录认证，并利用 Gin 的 **中间件 (Middleware)** 机制来保护我们的 API。

## 1. JWT 基础

JWT 本质上是一段被签名的 JSON 数据，由三部分组成：`Header.Payload.Signature`。

我们需要安装 `golang-jwt/jwt` 包：

```bash
go get -u github.com/golang-jwt/jwt/v5
```

### 1.1 封装 JWT 工具类

创建 `pkg/util/jwt.go`：

```go
package util

import (
	"time"

	"github.com/golang-jwt/jwt/v5"
)

var jwtSecret = []byte("your_super_secret_key") // 生产环境请从配置读取

type Claims struct {
	UserID   uint   `json:"user_id"`
	Username string `json:"username"`
	jwt.RegisteredClaims
}

// GenerateToken 生成 Token
func GenerateToken(userID uint, username string) (string, error) {
	nowTime := time.Now()
	expireTime := nowTime.Add(24 * time.Hour) // 24小时过期

	claims := Claims{
		UserID:   userID,
		Username: username,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expireTime),
			Issuer:    "go-blog-api",
		},
	}

	tokenClaims := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	token, err := tokenClaims.SignedString(jwtSecret)
	return token, err
}

// ParseToken 解析 Token
func ParseToken(token string) (*Claims, error) {
	tokenClaims, err := jwt.ParseWithClaims(token, &Claims{}, func(token *jwt.Token) (interface{}, error) {
		return jwtSecret, nil
	})

	if tokenClaims != nil {
		if claims, ok := tokenClaims.Claims.(*Claims); ok && tokenClaims.Valid {
			return claims, nil
		}
	}

	return nil, err
}
```

## 2. 实现登录功能

### 2.1 Service 层

在 `internal/service/user_service.go` 中添加登录逻辑：

```go
type LoginRequest struct {
	Username string `json:"username" binding:"required"`
	Password string `json:"password" binding:"required"`
}

type LoginResponse struct {
	Token string `json:"token"`
	User  model.User `json:"user"`
}

func (s *UserService) Login(req *LoginRequest) (*LoginResponse, error) {
	// 1. 查询用户
	user, err := s.userRepo.GetByUsername(req.Username)
	if err != nil {
		return nil, errors.New("invalid username or password")
	}

	// 2. 校验密码
	err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password))
	if err != nil {
		return nil, errors.New("invalid username or password")
	}

	// 3. 生成 Token
	token, err := util.GenerateToken(user.ID, user.Username)
	if err != nil {
		return nil, err
	}

	return &LoginResponse{
		Token: token,
		User:  *user,
	}, nil
}
```

### 2.2 Controller 层

在 `internal/api/v1/user.go` 中添加登录接口：

```go
func (ctrl *UserController) Login(c *gin.Context) {
	var req service.LoginRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		util.Error(c, http.StatusBadRequest, 40001, err.Error())
		return
	}

	resp, err := ctrl.userService.Login(&req)
	if err != nil {
		util.Error(c, http.StatusUnauthorized, 40101, err.Error())
		return
	}

	util.Success(c, resp)
}
```

别忘了在 `router.go` 中注册 `/auth/login` 路由。

## 3. 编写鉴权中间件

中间件是 Gin 的核心特性，它采用了洋葱模型。我们需要编写一个中间件，拦截请求，检查 Header 中的 Token。

创建 `internal/middleware/auth.go`：

```go
package middleware

import (
	"go-blog-api/pkg/util"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
)

func JWT() gin.HandlerFunc {
	return func(c *gin.Context) {
		var code int
		var data interface{}

		code = 0
		token := c.GetHeader("Authorization")

		if token == "" {
			code = 401
		} else {
			// 通常 Token 格式为 "Bearer <token>"
			parts := strings.SplitN(token, " ", 2)
			if !(len(parts) == 2 && parts[0] == "Bearer") {
				code = 401
			} else {
				claims, err := util.ParseToken(parts[1])
				if err != nil {
					code = 401
				} else {
					// 将当前用户信息存在 Context 中，后续 Handler 可以直接获取
					c.Set("userID", claims.UserID)
					c.Set("username", claims.Username)
				}
			}
		}

		if code != 0 {
			util.Error(c, http.StatusUnauthorized, 401, "Unauthorized")
			c.Abort() // 阻止后续 Handler 执行
			return
		}

		c.Next() // 继续执行后续 Handler
	}
}
```

## 4. 保护 API

现在我们有了中间件，可以用来保护需要登录才能访问的接口（例如：发布文章）。

修改 `internal/router/router.go`：

```go
// ...
	apiV1 := r.Group("/api/v1")
	{
		// 公开接口
		auth := apiV1.Group("/auth")
		{
			auth.POST("/register", userCtrl.Register)
			auth.POST("/login", userCtrl.Login)
		}

		// 需要鉴权的接口
		articles := apiV1.Group("/articles")
		articles.Use(middleware.JWT()) // 挂载中间件
		{
			articles.POST("", articleCtrl.CreateArticle) // 只有登录用户能创建
			articles.GET("/:id", articleCtrl.GetArticle) // 假设查看文章不需要登录，可以移出去
		}
	}
// ...
```

## 5. 获取当前用户

在 Controller 中，我们可以从 Context 中取出中间件设置的用户信息。

修改 `internal/api/v1/article.go`：

```go
func (ctrl *ArticleController) CreateArticle(c *gin.Context) {
	// 从 Context 获取当前用户 ID
	userID, exists := c.Get("userID")
	if !exists {
		util.Error(c, http.StatusUnauthorized, 401, "Unauthorized")
		return
	}

	// ... 业务逻辑，使用 userID 创建文章
	util.Success(c, map[string]interface{}{
		"user_id": userID,
		"status":  "created",
	})
}
```

## 6. 验证

1.  **登录**：调用 `/api/v1/auth/login`，获取 Token。
2.  **未授权访问**：直接调用 `/api/v1/articles` (POST)，返回 401。
3.  **授权访问**：在 Header 中添加 `Authorization: Bearer <your_token>`，再次调用，成功。

## 7. 总结

本章我们完成了：
1.  **JWT 封装**：实现了 Token 的生成与解析。
2.  **登录流程**：密码比对 + Token 签发。
3.  **中间件机制**：利用 Gin 中间件实现了统一的身份拦截，并利用 `c.Set` 和 `c.Get` 在请求链路中传递上下文信息。

**下一章预告**：
现在我们已经解决了“谁在操作”的问题，下一章我们将解决“操作什么”的问题。我们将深入 GORM，实现**文章的发布与列表查询**，并探讨如何处理**N+1 查询问题**以及**数据库事务**。
