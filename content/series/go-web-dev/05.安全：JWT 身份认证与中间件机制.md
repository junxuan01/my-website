---
title: "安全：JWT 身份认证与中间件机制"
description: "构建安全的 API 服务。深入理解 JWT 原理，实现用户登录与 Token 签发。编写 Gin 中间件实现统一鉴权与上下文传递。"
date: "2025-12-07"
seriesOrder: 5
---

# 5. 安全：JWT 身份认证与中间件机制

## 引言

在前端开发中，你可能已经习惯了这样的流程：

- 登录页面提交账号密码；
- 成功后前端拿到一个 `token` 或 `sessionId`；
- 后续每次请求带上这个凭证，请求就“变成登录态”了。

但这个 `token` 到底是什么？为什么有的项目用 Cookie + Session，有的用 JWT？后端到底是怎么在每个请求里“认出你这个用户”的？

要回答这些问题，需要先意识到一个事实：

> **HTTP 本身是无状态的。服务器不会自动记住你是谁。**

为了在“无状态”的协议上实现“有状态”的登录，我们通常有两大类方案：

1. **Session + Cookie**：
	- 服务端维护一个 Session 存储（内存/Redis 等），里面保存用户登录信息；
	- 登录成功后生成一个随机的 `sessionId`，通过 Cookie 发给浏览器；
	- 后续请求浏览器自动携带 Cookie，服务端根据 `sessionId` 查 Session；
	- 更适合传统 Web + 单机应用，对多端、跨域、微服务支持相对繁琐。
2. **Token (JWT)**：
	- 登录成功后生成一段“自包含”的 Token 字符串，其中包含用户信息和签名；
	- 后续请求前端手动把 Token 放到 `Authorization` 头里；
	- 服务端通过解析和验签 Token，就能知道“你是谁、什么时候过期”；
	- 更适合前后端分离、移动端、小程序、多服务之间传递身份信息。

本章我们将实现基于 **JWT (JSON Web Token)** 的登录认证，并利用 Gin 的 **中间件 (Middleware)** 机制来保护我们的 API。

> 本章目标：
>
> - 从前端视角理解 JWT 是什么、和 Session 有什么不同；
> - 完成登录接口：验证密码 → 签发 Token → 前端存储；
> - 编写 Gin 中间件，在每个受保护接口前校验 Token，并注入当前用户信息。

## 1. JWT 基础

JWT（JSON Web Token）本质上是一段被签名的 JSON 数据，由三部分组成：`Header.Payload.Signature`，中间用点号 `.` 分隔：

```text
xxxxx.yyyyy.zzzzz
```

- **Header（头部）**：声明这是一个什么类型的 Token、用了什么签名算法；
- **Payload（载荷）**：真正有用的数据，比如 `user_id`、`username`、过期时间等；
- **Signature（签名）**：对前两部分做签名，防止被篡改。

一个典型的 Payload 可能长这样：

```json
{
	"user_id": 1,
	"username": "junxuan",
	"exp": 1733606400,
	"iss": "go-blog-api"
}
```

这段 JSON 会被编码成 Base64 字符串，和 Header 一起参与签名，最终变成一个不可读但可验证的 Token 字符串。

> 直观类比：
> - 可以把 JWT 想象成一张“防伪门票”：上面写了你的信息和有效期（Payload），还盖了一个官方印章（Signature）；
> - 检票员只需要验证印章是否正确、门票是否过期，就能确认你是谁，而不需要每次都去问办票处。

### 1.1 前端最关心的 3 个问题

#### 1) Token 放哪？（localStorage 还是 Cookie？）

这不是“唯一答案”的问题，而是取舍：

- 放 **localStorage**：实现简单，跨域也方便；缺点是如果站点存在 XSS 风险，Token 更容易被读走。
- 放 **Cookie（HttpOnly）**：JS 读不到，更抗 XSS；但会带来 CSRF 等额外问题，需要 SameSite/CSRF Token 等配套。

本系列先用更常见的“前后端分离 JWT”路线：

- 前端保存 Token（一般是 localStorage/内存）
- 每次请求通过 Header 手动携带

后面在实战篇我们会进一步讲更安全的“双 Token（Access + Refresh）”和更稳妥的落地方式。

#### 2) 请求怎么带 Token？

约定使用 `Authorization: Bearer <token>`：

```http
GET /api/v1/users/me HTTP/1.1
Authorization: Bearer xxxxx.yyyyy.zzzzz
```

> **前端类比**：Axios request interceptor 统一加 header。

#### 3) 401 和 403 有什么区别？

- **401 Unauthorized**：没有登录态 / Token 过期 / Token 无效 → 前端通常要跳登录；
- **403 Forbidden**：已登录但没权限 → 前端不要跳登录，而是提示“无权限”。

### 1.2 JWT 的优缺点（你需要知道的边界）

**优点**：

- 服务端不需要存 Session（更容易横向扩展）；
- Token 自包含，微服务/多端传递方便。

**缺点**：

- Token 一旦签发，在过期前理论上都有效（除非做黑名单/版本号）；
- 如果 Token 泄露，攻击者可以冒用登录态；
- 所以生产实践通常会引入 Refresh Token、黑名单、强制下线等机制。

我们需要安装 `golang-jwt/jwt` 包：

```bash
go get -u github.com/golang-jwt/jwt/v5
```

### 1.1 封装 JWT 工具类

创建 `pkg/util/jwt.go`：

```go
package util

import (
	"time"

	"github.com/golang-jwt/jwt/v5"
)

// 实际项目中应从配置或环境变量读取，而不是写死在代码里
var jwtSecret = []byte("your_super_secret_key")

type Claims struct {
	UserID   uint   `json:"user_id"`
	Username string `json:"username"`
	jwt.RegisteredClaims
}

// GenerateToken 生成 Token
func GenerateToken(userID uint, username string) (string, error) {
	nowTime := time.Now()
	expireTime := nowTime.Add(24 * time.Hour) // 24小时过期

	claims := Claims{
		UserID:   userID,
		Username: username,
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(expireTime),
			Issuer:    "go-blog-api",
		},
	}

	tokenClaims := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	token, err := tokenClaims.SignedString(jwtSecret)
	return token, err
}

// ParseToken 解析 Token
func ParseToken(token string) (*Claims, error) {
	tokenClaims, err := jwt.ParseWithClaims(token, &Claims{}, func(token *jwt.Token) (interface{}, error) {
		return jwtSecret, nil
	})

	if tokenClaims != nil {
		if claims, ok := tokenClaims.Claims.(*Claims); ok && tokenClaims.Valid {
			return claims, nil
		}
	}

	return nil, err
}
```

## 2. 实现登录功能

### 2.1 Service 层：验证密码并签发 Token

登录的本质流程是：

1. 根据用户名查出用户记录；
2. 用安全的方式验证密码；
3. 生成一个包含用户信息的 JWT；
4. 返回给 Controller，由 Controller 再返回给前端。

在 `internal/service/user_service.go` 中添加登录逻辑：

```go
type LoginRequest struct {
	Username string `json:"username" binding:"required"`
	Password string `json:"password" binding:"required"`
}

type LoginResponse struct {
	Token string `json:"token"`
	User  model.User `json:"user"`
}

func (s *UserService) Login(req *LoginRequest) (*LoginResponse, error) {
	// 1. 查询用户
	user, err := s.userRepo.GetByUsername(req.Username)
	if err != nil {
		return nil, errors.New("invalid username or password")
	}

	// 2. 校验密码
	err = bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(req.Password))
	if err != nil {
		return nil, errors.New("invalid username or password")
	}

	// 3. 生成 Token
	token, err := util.GenerateToken(user.ID, user.Username)
	if err != nil {
		return nil, err
	}

	return &LoginResponse{
		Token: token,
		User:  *user,
	}, nil
}
```

### 2.2 Controller 层

在 `internal/api/v1/user.go` 中添加登录接口：

```go
func (ctrl *UserController) Login(c *gin.Context) {
	var req service.LoginRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		util.Error(c, http.StatusBadRequest, 40001, err.Error())
		return
	}

	resp, err := ctrl.userService.Login(&req)
	if err != nil {
		util.Error(c, http.StatusUnauthorized, 40101, err.Error())
		return
	}

	util.Success(c, resp)
}
```

别忘了在 `router.go` 中注册 `POST /api/v1/auth/login` 路由。

## 3. 编写鉴权中间件

中间件是 Gin 的核心特性，它采用了“洋葱模型”：

- 每个请求会按顺序经过多个中间件；
- 中间件可以在请求到达真正的 Handler 之前“提前拦截”或“注入信息”；
- 请求处理完之后，中间件还可以在“回程”阶段做一些收尾工作（例如记录耗时、统一处理错误）。

我们需要编写一个 JWT 中间件：

- 从 Header 中取出 Token；
- 解析并验证 Token；
- 把当前用户信息写入 Gin 的 `Context`，方便后续 Handler 使用；
- 如果 Token 非法或缺失，则直接返回 401，阻止后续 Handler 执行。

创建 `internal/middleware/auth.go`：

```go
package middleware

import (
	"go-blog-api/pkg/util"
	"net/http"
	"strings"

	"github.com/gin-gonic/gin"
)

func JWT() gin.HandlerFunc {
	return func(c *gin.Context) {
		var code int
		var data interface{}

		code = 0
		token := c.GetHeader("Authorization")

		if token == "" {
			code = 401
		} else {
			// 通常 Token 格式为 "Bearer <token>"
			parts := strings.SplitN(token, " ", 2)
			if !(len(parts) == 2 && parts[0] == "Bearer") {
				code = 401
			} else {
				claims, err := util.ParseToken(parts[1])
				if err != nil {
					code = 401
				} else {
					// 将当前用户信息存在 Context 中，后续 Handler 可以直接获取
					c.Set("userID", claims.UserID)
					c.Set("username", claims.Username)
				}
			}
		}

		if code != 0 {
			util.Error(c, http.StatusUnauthorized, 401, "Unauthorized")
			c.Abort() // 阻止后续 Handler 执行
			return
		}

		c.Next() // 继续执行后续 Handler
	}
}
```

## 4. 保护 API

现在我们有了中间件，可以用来保护需要登录才能访问的接口（例如：发布文章）。

修改 `internal/router/router.go`：

```go
// ...
	apiV1 := r.Group("/api/v1")
	{
		// 公开接口
		auth := apiV1.Group("/auth")
		{
			auth.POST("/register", userCtrl.Register)
			auth.POST("/login", userCtrl.Login)
		}

		// 需要鉴权的接口
		articles := apiV1.Group("/articles")
		articles.Use(middleware.JWT()) // 挂载中间件
		{
			articles.POST("", articleCtrl.CreateArticle) // 只有登录用户能创建
			articles.GET("/:id", articleCtrl.GetArticle) // 假设查看文章不需要登录，可以移出去
		}
	}
// ...
```

## 5. 获取当前用户

在 Controller 中，我们可以从 Context 中取出中间件设置的用户信息。

修改 `internal/api/v1/article.go`：

```go
func (ctrl *ArticleController) CreateArticle(c *gin.Context) {
	// 从 Context 获取当前用户 ID
	userID, exists := c.Get("userID")
	if !exists {
		util.Error(c, http.StatusUnauthorized, 401, "Unauthorized")
		return
	}

	// ... 业务逻辑，使用 userID 创建文章
	util.Success(c, map[string]interface{}{
		"user_id": userID,
		"status":  "created",
	})
}
```

## 6. 验证

1.  **登录**：调用 `/api/v1/auth/login`，获取 Token。
2.  **未授权访问**：直接调用 `/api/v1/articles` (POST)，返回 401。
3.  **授权访问**：在 Header 中添加 `Authorization: Bearer <your_token>`，再次调用，成功。

在前端，你通常会这样配合使用 JWT：

1. 登录成功后，后端返回形如 `{ token, user }` 的响应；
2. 将 `token` 保存到某个安全位置（如内存/`localStorage`/`cookie`，具体取舍根据安全要求）；
3. 使用 axios 拦截器在每个请求头上自动加上 `Authorization: Bearer <token>`；
4. 当收到 401 响应时，清理本地 Token，跳转到登录页或展示“登录已过期”的提示。

> 示例（前端 axios 拦截器伪代码）：
>
> ```ts
> axios.interceptors.request.use((config) => {
>   const token = getTokenFromStorage()
>   if (token) {
>     config.headers.Authorization = `Bearer ${token}`
>   }
>   return config
> })
> ```

## 7. 总结与练习

本章我们从“HTTP 无状态”的事实出发，搭建了一套完整的登录认证链路：

1. **JWT 封装**：
	- 理解了 Header / Payload / Signature 三部分的含义；
	- 使用 `golang-jwt/jwt` 实现了 Token 的生成与解析。
2. **登录流程**：
	- 在 Service 层完成了用户查询、密码比对和 Token 签发；
	- 在 Controller 层接收请求、调用 Service，并统一返回 `{ token, user }`。
3. **中间件机制**：
	- 编写了 JWT 鉴权中间件，从 Header 中解析 Token；
	- 在 `Context` 中注入了 `userID`、`username`，供后续 Handler 使用；
	- 使用路由分组将“需要登录”的接口统一保护起来。
4. **前后端配合**：
	- 前端需要负责 Token 的存储与自动携带；
	- 后端通过 401/业务码提示前端何时清理 Token、何时引导用户重新登录。

### 贯穿任务线（本章验收：登录 + 鉴权中间件跑通）

- [ ] 已跑通登录接口：`POST /api/v1/auth/login`，响应体里至少包含 `token` 字段
- [ ] 已实现鉴权中间件：从 `Authorization: Bearer <token>` 解析并验签
- [ ] 至少 1 个受保护接口被路由分组保护（没带 Token 返回 401）
- [ ] 带 Token 访问受保护接口成功（能在 handler 里读到 `userID`/`username` 等上下文）
- [ ] 前端侧有明确对接规则：401 清理登录态并引导登录；403 仅提示无权限

### 推荐练习

1. 为 JWT 增加“刷新 Token”逻辑：
	- 在 Payload 中增加一个更短的过期时间；
	- 当 Token 即将过期时，前端调用一个 `/api/v1/auth/refresh` 接口刷新 Token；
	- 思考：如何防止刷新接口被滥用？
2. 在中间件中区分不同类型的错误：
	- 例如：Token 缺失、格式错误、已过期、签名不合法等；
	- 为每种场景返回不同的业务码，方便前端做更细致的提示。
3. 思考不同存储方式的优缺点：
	- `localStorage` vs `cookie` vs 内存（例如 Zustand 中的全局状态）；
	- 从 XSS/CSRF 等角度考虑安全性，想一想在你的项目里会如何选择。

**下一章预告**：
现在我们已经解决了“谁在操作”的问题，下一章我们将解决“操作什么”的问题。我们将深入 GORM，实现**文章的发布与列表查询**，并探讨如何处理**N+1 查询问题**以及**数据库事务**，继续完善我们的博客业务链路。
