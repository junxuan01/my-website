---
title: "Go 语言基础之结构体"
description: "学习 Go 语言的结构体定义、方法绑定和组合复用，了解 Go 的面向对象编程方式。"
date: "2025-11-25"
seriesOrder: 15
---

# 15. Go 语言基础之结构体

## 引言

在 JavaScript (ES6+) 中，我们使用 `class` 来定义类，使用 `constructor` 初始化对象，使用 `extends` 实现继承。

Go 语言**没有 class**，也没有 **extends**。但是，Go 依然支持面向对象编程（OOP）。它是通过 **结构体 (Struct)** 来实现数据封装，通过 **方法 (Method)** 来实现行为，通过 **组合 (Composition)** 来实现代码复用。

## 1. 结构体的定义

结构体是一种聚合数据类型，它将不同的数据类型组合在一起。

```go
type Person struct {
    Name string
    Age  int
    City string
}
```

这看起来很像 TypeScript 中的 `interface` 或 C 语言中的 `struct`。

## 2. 实例化结构体

有多种方式可以创建一个结构体实例。

### 2.1 键值对初始化 (推荐)

```go
p1 := Person{
    Name: "Tom",
    Age:  18,
    City: "Beijing",
}
```

### 2.2 列表初始化 (不推荐)

必须按照字段定义的顺序赋值，一旦字段顺序改变或增加字段，代码就会报错。

```go
p2 := Person{"Jerry", 20, "Shanghai"}
```

### 2.3 获取结构体指针

在 Go 中，我们经常使用结构体的指针，以避免大对象的内存复制。

```go
// p3 是一个指针 (*Person)
p3 := &Person{
    Name: "Jack",
    Age:  30,
}
// Go 提供了语法糖，你可以直接用指针访问字段，不需要 (*p3).Name
fmt.Println(p3.Name) 
```

## 3. 方法 (Methods)

在 Go 中，方法是**作用在特定类型上的函数**。

### 3.1 定义方法

方法的定义与函数非常像，只是在 `func` 和方法名之间多了一个参数，这个参数称为**接收者 (Receiver)**。接收者类似于 JS 中的 `this`。

```go
// (p Person) 是接收者
func (p Person) Greet() {
    fmt.Printf("Hello, I am %s\n", p.Name)
}

func main() {
    p := Person{Name: "Tom"}
    p.Greet() // 调用方法
}
```

### 3.2 指针接收者 vs 值接收者 (重要！)

这是初学者最容易困惑的地方。接收者可以是值类型 `(p Person)`，也可以是指针类型 `(p *Person)`。

**区别**：
1.  **值接收者**: 会将结构体**复制**一份。在方法内修改字段**不会**影响原对象。
2.  **指针接收者**: 传递的是引用。在方法内修改字段**会**影响原对象。

```go
// 值接收者：修改无效
func (p Person) SetAgeValue(newAge int) {
    p.Age = newAge
    fmt.Println("内部修改:", p.Age)
}

// 指针接收者：修改生效
func (p *Person) SetAgePointer(newAge int) {
    p.Age = newAge
}

func main() {
    p := Person{Name: "Tom", Age: 18}
    
    p.SetAgeValue(20)
    fmt.Println(p.Age) // 输出 18 (没变)
    
    p.SetAgePointer(20)
    fmt.Println(p.Age) // 输出 20 (变了)
}
```

**最佳实践**：
-   如果方法需要修改结构体，**必须**使用指针接收者。
-   如果结构体很大，为了避免复制带来的性能开销，**建议**使用指针接收者。
-   为了保持一致性，通常一个结构体的所有方法都使用指针接收者。

## 4. 结构体嵌套 (组合) —— Go 的继承

Go 语言反对复杂的类继承层次，推崇**组合优于继承**。

我们可以通过在结构体中嵌入另一个结构体来实现复用。

```go
type Address struct {
    City  string
    State string
}

type User struct {
    Name    string
    Address // 匿名嵌入结构体
}

func main() {
    u := User{
        Name: "Tom",
        Address: Address{
            City:  "Beijing",
            State: "CN",
        },
    }
    
    // 字段提升 (Promoted Fields)
    // 我们可以直接访问 Address 中的字段，就像它们在 User 中一样
    fmt.Println(u.City) // 等同于 u.Address.City
}
```

这实现了类似继承的效果（User 拥有了 Address 的属性），但本质上是组合。

## 5. 结构体标签 (Tags)与 JSON 处理

在前端开发中，JSON 是最常用的数据格式。Go 语言通过结构体标签（Tag）来控制 JSON 的序列化和反序列化。

```go
import "encoding/json"

type Student struct {
    ID   int    `json:"id"`              // 序列化时 key 为 "id"
    Name string `json:"username"`        // 序列化时 key 为 "username"
    Age  int    `json:"age,omitempty"`   // 如果 Age 为 0，则忽略该字段
    Pwd  string `json:"-"`               // 永远忽略该字段（不输出）
}

func main() {
    s := Student{ID: 1, Name: "Tom", Pwd: "123"}
    
    // 序列化 (Struct -> JSON String)
    b, _ := json.Marshal(s)
    fmt.Println(string(b)) 
    // 输出: {"id":1,"username":"Tom"} (Age 被忽略了，Pwd 被忽略了)
}
```

这比 JS 中手动处理 JSON 对象要规范得多。

## 6. 总结

Go 的结构体是数据的载体，方法是行为的载体。

1.  **没有 class**，只有 struct。
2.  **没有 extends**，只有组合。
3.  **方法**通过接收者绑定到结构体上。
4.  **指针接收者**用于修改对象和提升性能。

掌握了结构体，你就掌握了 Go 语言面向对象编程的核心。但面向对象不仅仅是封装和继承，还有多态。Go 语言是如何实现多态的呢？答案是——接口（Interface）。下一篇文章，我们将深入探讨 Go 语言中最灵活的设计——接口。

---

