---
title: "Go 语言基础之结构体"
description: "深入学习 Go 1.25 的结构体定义、方法绑定和组合复用，详细对比 JavaScript/TypeScript 的 class，掌握 Go 的面向对象编程方式。"
date: "2025-12-01"
seriesOrder: 15
---

# 15. Go 语言基础之结构体

## 引言

在 JavaScript (ES6+) 中，我们使用 `class` 来定义类，使用 `constructor` 初始化对象，使用 `extends` 实现继承。

Go 语言**没有 class**，也没有 **extends**。但是，Go 依然支持面向对象编程（OOP）。它是通过 **结构体 (Struct)** 来实现数据封装，通过 **方法 (Method)** 来实现行为，通过 **组合 (Composition)** 来实现代码复用。

**Go 1.25 版本说明**：本文基于 Go 1.25 编写，Go 的结构体和方法机制保持稳定，但泛型（Generics，Go 1.18+）的引入让结构体更加灵活。

## 1. 结构体的定义

结构体是一种聚合数据类型，它将不同的数据类型组合在一起。

```go
type Person struct {
    Name string
    Age  int
    City string
}
```

这看起来很像 TypeScript 中的 `interface` 或 C 语言中的 `struct`。

### 1.1 与 JavaScript/TypeScript 的对比

**TypeScript Interface:**
```typescript
interface Person {
    name: string;
    age: number;
    city: string;
}

// 创建对象
const person: Person = {
    name: "Tom",
    age: 18,
    city: "Beijing"
};
```

**JavaScript Class (ES6+):**
```javascript
class Person {
    constructor(name, age, city) {
        this.name = name;
        this.age = age;
        this.city = city;
    }
}

const person = new Person("Tom", 18, "Beijing");
```

**Go Struct:**
```go
type Person struct {
    Name string
    Age  int
    City string
}

// 创建实例
person := Person{
    Name: "Tom",
    Age:  18,
    City: "Beijing",
}
```

**关键区别：**
1. Go 的字段名首字母大写表示 **导出**（公开），小写表示 **私有**
2. Go 没有 `constructor`，直接用字面量或 `new` 创建
3. Go 没有 `class` 关键字，但有方法（下文详细讲解）

### 1.2 字段的可见性

Go 使用首字母大小写来控制可见性（而不是 `public/private` 关键字）：

```go
type User struct {
    Name  string // 首字母大写：导出（public），包外可见
    age   int    // 首字母小写：未导出（private），仅包内可见
    email string // 私有字段
}
```

**TypeScript 对比：**
```typescript
class User {
    public name: string;      // 显式 public
    private age: number;      // 显式 private
    protected email: string;  // 显式 protected (子类可见)
    
    constructor(name: string, age: number, email: string) {
        this.name = name;
        this.age = age;
        this.email = email;
    }
}
```

## 2. 实例化结构体

有多种方式可以创建一个结构体实例。

### 2.1 键值对初始化（推荐）

```go
p1 := Person{
    Name: "Tom",
    Age:  18,
    City: "Beijing",
}
```

**优点：**
- 字段名明确，易读易维护
- 可以只初始化部分字段（其他字段取零值）
- 字段顺序可以任意调整

```go
// 只初始化部分字段
p2 := Person{
    Name: "Jerry", // Age 和 City 自动取零值 (0 和 "")
}
fmt.Printf("%+v\n", p2) // {Name:Jerry Age:0 City:}
```

### 2.2 列表初始化（不推荐）

必须按照字段定义的顺序赋值，一旦字段顺序改变或增加字段，代码就会报错。

```go
p2 := Person{"Jerry", 20, "Shanghai"}
```

**JavaScript 对比：**
```javascript
// JS 中创建对象很灵活
const p1 = {
    name: "Tom",
    age: 18,
    city: "Beijing"
};

// 使用 class
class Person {
    constructor(name, age, city) {
        this.name = name;
        this.age = age;
        this.city = city;
    }
}
const p2 = new Person("Jerry", 20, "Shanghai");

// ES6 解构赋值
const p3 = { name: "Alice", age: 25 }; // 部分字段
```

### 2.3 使用 new 关键字

`new` 返回结构体的指针：

```go
p3 := new(Person) // p3 是 *Person 类型
p3.Name = "Jack"
p3.Age = 30

// 等价于：
p4 := &Person{}
```

### 2.4 获取结构体指针

在 Go 中，我们经常使用结构体的指针，以避免大对象的内存复制。

```go
// p3 是一个指针 (*Person)
p3 := &Person{
    Name: "Jack",
    Age:  30,
}

// Go 提供了语法糖，你可以直接用指针访问字段，不需要 (*p3).Name
fmt.Println(p3.Name) // Jack

// JavaScript 对比：所有对象都是引用类型
const obj = { name: "Tom" }; // 本质上是指针/引用
const ref = obj;              // 共享同一个对象
ref.name = "Jerry";
console.log(obj.name);        // "Jerry"
```

### 2.5 匿名结构体

有时候我们只需要临时使用一个结构体，不想定义类型：

```go
// 匿名结构体
person := struct {
    Name string
    Age  int
}{
    Name: "Temp",
    Age:  99,
}

fmt.Println(person.Name) // Temp
```

**常用场景：**
- 测试代码
- JSON 临时解析
- 配置临时存储

**JavaScript 对比：**
```javascript
// JS 中直接用对象字面量，非常自然
const person = {
    name: "Temp",
    age: 99
};
```

### 2.6 零值结构体

未初始化的结构体字段会自动取零值：

```go
var p Person
fmt.Printf("%+v\n", p) // {Name: Age:0 City:}

// Name: 空字符串
// Age: 0
// City: 空字符串
```

**JavaScript 对比：**
```javascript
// JS 中未初始化的对象属性是 undefined
const obj = {};
console.log(obj.name);  // undefined
console.log(obj.age);   // undefined
```

## 3. 方法（Methods）

在 Go 中，方法是**作用在特定类型上的函数**。

### 3.1 定义方法

方法的定义与函数非常像，只是在 `func` 和方法名之间多了一个参数，这个参数称为**接收者（Receiver）**。接收者类似于 JS 中的 `this`。

```go
// (p Person) 是接收者
func (p Person) Greet() {
    fmt.Printf("Hello, I am %s\n", p.Name)
}

func main() {
    p := Person{Name: "Tom"}
    p.Greet() // 调用方法
}
```

**JavaScript Class 对比：**
```javascript
class Person {
    constructor(name) {
        this.name = name;
    }
    
    greet() {
        console.log(`Hello, I am ${this.name}`);
    }
}

const p = new Person("Tom");
p.greet(); // 调用方法
```

**TypeScript 完整对比：**
```typescript
class Person {
    name: string;
    age: number;
    
    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }
    
    // 实例方法
    greet(): void {
        console.log(`Hello, I am ${this.name}`);
    }
    
    // Getter
    get info(): string {
        return `${this.name}, ${this.age} years old`;
    }
    
    // Setter
    set age(value: number) {
        if (value < 0) throw new Error("Age cannot be negative");
        this.age = value;
    }
}
```

```go
// Go 对应实现
type Person struct {
    Name string
    age  int // 私有字段
}

// 实例方法
func (p Person) Greet() {
    fmt.Printf("Hello, I am %s\n", p.Name)
}

// Getter（Go 没有专门的 getter 语法）
func (p Person) Info() string {
    return fmt.Sprintf("%s, %d years old", p.Name, p.age)
}

// Setter（使用指针接收者）
func (p *Person) SetAge(age int) error {
    if age < 0 {
        return fmt.Errorf("age cannot be negative")
    }
    p.age = age
    return nil
}
```

### 3.2 指针接收者 vs 值接收者（重要！）

这是初学者最容易困惑的地方。接收者可以是值类型 `(p Person)`，也可以是指针类型 `(p *Person)`。

**区别：**
1. **值接收者**：会将结构体**复制**一份。在方法内修改字段**不会**影响原对象。
2. **指针接收者**：传递的是引用。在方法内修改字段**会**影响原对象。

```go
// 值接收者：修改无效
func (p Person) SetAgeValue(newAge int) {
    p.Age = newAge
    fmt.Println("内部修改:", p.Age)
}

// 指针接收者：修改生效
func (p *Person) SetAgePointer(newAge int) {
    p.Age = newAge
}

func main() {
    p := Person{Name: "Tom", Age: 18}
    
    p.SetAgeValue(20)
    fmt.Println(p.Age) // 输出 18 (没变)
    
    p.SetAgePointer(20)
    fmt.Println(p.Age) // 输出 20 (变了)
}
```

**JavaScript 对比：**
```javascript
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    // JS 的方法默认就是"引用"行为
    setAge(newAge) {
        this.age = newAge; // 总是会修改原对象
    }
}

const p = new Person("Tom", 18);
p.setAge(20);
console.log(p.age); // 20 (修改成功)

// 如果要避免修改，需要手动克隆
setAgeImmutable(person, newAge) {
    return { ...person, age: newAge }; // 返回新对象
}
```

### 3.3 何时使用指针接收者？

**必须使用指针接收者的情况：**
1. 方法需要修改接收者
2. 接收者是大型结构体（避免复制开销）
3. 接收者包含 `sync.Mutex` 等不可复制的字段

**可以使用值接收者的情况：**
1. 接收者是小型结构体（如只有 1-2 个基本类型字段）
2. 接收者是 `map`、`func`、`chan` 等引用类型
3. 方法不需要修改接收者

**最佳实践：**
为了保持一致性，**通常一个结构体的所有方法都使用指针接收者**。

```go
type Counter struct {
    count int
}

// 统一使用指针接收者
func (c *Counter) Increment() {
    c.count++
}

func (c *Counter) Decrement() {
    c.count--
}

func (c *Counter) Value() int {
    return c.count // 即使只读，也用指针接收者保持一致
}
```

### 3.4 方法集（Method Set）

这是一个容易被忽略但很重要的概念：

- **值类型** `T` 的方法集：包含所有 `(t T)` 和 `(t *T)` 的方法
- **指针类型** `*T` 的方法集：只包含 `(t *T)` 的方法

```go
type Dog struct {
    Name string
}

func (d Dog) Bark() {
    fmt.Println("汪汪汪")
}

func (d *Dog) Rename(name string) {
    d.Name = name
}

func main() {
    d := Dog{Name: "旺财"}
    d.Bark()         // ✅ 值可以调用值接收者方法
    d.Rename("来福") // ✅ Go 自动转换为 (&d).Rename()
    
    p := &Dog{Name: "小黑"}
    p.Bark()         // ✅ 指针可以调用值接收者方法
    p.Rename("小白") // ✅ 指针可以调用指针接收者方法
}
```

**重点：** Go 编译器会自动进行转换，所以你不需要担心大部分情况。但在接口实现中，这个区别很重要（下一章会详细讲）。

### 3.5 方法可以定义在任何类型上

Go 的方法不仅可以定义在结构体上，还可以定义在任何自定义类型上：

```go
type MyInt int

func (m MyInt) Double() MyInt {
    return m * 2
}

func main() {
    var n MyInt = 5
    fmt.Println(n.Double()) // 10
}
```

**但不能给内置类型或其他包的类型定义方法：**
```go
// ❌ 错误：不能给 int 定义方法
// func (i int) Double() int { ... }

// ❌ 错误：不能给其他包的类型定义方法
// func (t time.Time) MyFormat() string { ... }
```

**JavaScript 对比：**
```javascript
// JS 可以直接修改原型链（但不推荐）
Number.prototype.double = function() {
    return this * 2;
};

console.log((5).double()); // 10

// 或者使用 Symbol
```

## 4. 结构体嵌套与组合（Composition）

Go **没有继承**，但有更强大的**组合（Composition）**机制。这是 Go 面向对象设计的核心思想。

### 4.1 嵌套结构体（Nested Structs）

最基础的方式是直接嵌套：

```go
type Address struct {
    Province string
    City     string
}

type Person struct {
    Name    string
    Age     int
    Address Address // 嵌套结构体
}

func main() {
    p := Person{
        Name: "Tom",
        Age:  18,
        Address: Address{
            Province: "广东",
            City:     "深圳",
        },
    }
    fmt.Println(p.Address.City) // 深圳
}
```

**JavaScript 对比：**
```javascript
const person = {
    name: "Tom",
    age: 18,
    address: {
        province: "广东",
        city: "深圳"
    }
};

console.log(person.address.city); // 深圳
```

### 4.2 匿名字段（Anonymous Fields）

Go 支持**匿名字段**，也称为**嵌入字段（Embedded Fields）**。这是实现"类继承"效果的关键：

```go
type Animal struct {
    Name string
}

func (a Animal) Move() {
    fmt.Printf("%s 正在移动\n", a.Name)
}

type Dog struct {
    Animal // 匿名字段（嵌入）
    Breed  string
}

func main() {
    d := Dog{
        Animal: Animal{Name: "旺财"},
        Breed:  "金毛",
    }
    
    // 直接访问嵌入字段的字段
    fmt.Println(d.Name)  // 旺财 (等价于 d.Animal.Name)
    
    // 直接调用嵌入字段的方法
    d.Move() // 旺财 正在移动 (等价于 d.Animal.Move())
    
    // 也可以显式访问
    fmt.Println(d.Animal.Name)
}
```

**关键特性：**
1. **字段提升（Field Promotion）**：嵌入类型的字段和方法会"提升"到外层类型
2. **访问简化**：可以直接用 `d.Name` 代替 `d.Animal.Name`
3. **方法继承**：嵌入类型的方法自动可用

**JavaScript 继承对比：**
```javascript
class Animal {
    constructor(name) {
        this.name = name;
    }
    
    move() {
        console.log(`${this.name} 正在移动`);
    }
}

class Dog extends Animal {
    constructor(name, breed) {
        super(name); // 必须调用 super
        this.breed = breed;
    }
}

const d = new Dog("旺财", "金毛");
console.log(d.name);  // 旺财
d.move(); // 旺财 正在移动
```

**TypeScript 接口组合对比：**
```typescript
interface Animal {
    name: string;
    move(): void;
}

interface Dog extends Animal {
    breed: string;
}

// 实现
class Husky implements Dog {
    name: string;
    breed: string;
    
    constructor(name: string, breed: string) {
        this.name = name;
        this.breed = breed;
    }
    
    move() {
        console.log(`${this.name} 正在移动`);
    }
}
```

### 4.3 方法重写（Method Overriding）

嵌入类型的方法可以被外层类型重写：

```go
type Animal struct {
    Name string
}

func (a Animal) Speak() {
    fmt.Println("一些动物的声音")
}

type Dog struct {
    Animal
}

// 重写 Speak 方法
func (d Dog) Speak() {
    fmt.Println("汪汪汪！")
}

func main() {
    d := Dog{Animal: Animal{Name: "旺财"}}
    
    d.Speak()        // 汪汪汪！(调用 Dog 的方法)
    d.Animal.Speak() // 一些动物的声音 (显式调用 Animal 的方法)
}
```

**JavaScript 重写对比：**
```javascript
class Animal {
    speak() {
        console.log("一些动物的声音");
    }
}

class Dog extends Animal {
    speak() {
        console.log("汪汪汪！");
    }
    
    parentSpeak() {
        super.speak(); // 显式调用父类方法
    }
}

const d = new Dog();
d.speak(); // 汪汪汪！
d.parentSpeak(); // 一些动物的声音
```

### 4.4 多重嵌入（Multiple Embedding）

Go 支持嵌入多个类型（类似多重继承，但更安全）：

```go
type Walker struct{}
func (w Walker) Walk() {
    fmt.Println("正在走路")
}

type Swimmer struct{}
func (s Swimmer) Swim() {
    fmt.Println("正在游泳")
}

type Duck struct {
    Walker  // 嵌入多个类型
    Swimmer
    Name string
}

func main() {
    d := Duck{Name: "唐老鸭"}
    d.Walk() // 正在走路
    d.Swim() // 正在游泳
}
```

**TypeScript Mixin 对比：**
```typescript
type Constructor<T = {}> = new (...args: any[]) => T;

function Walkable<T extends Constructor>(Base: T) {
    return class extends Base {
        walk() {
            console.log("正在走路");
        }
    };
}

function Swimmable<T extends Constructor>(Base: T) {
    return class extends Base {
        swim() {
            console.log("正在游泳");
        }
    };
}

class Animal {}
class Duck extends Swimmable(Walkable(Animal)) {
    name: string;
    constructor(name: string) {
        super();
        this.name = name;
    }
}

const d = new Duck("唐老鸭");
d.walk(); // 正在走路
d.swim(); // 正在游泳
```

### 4.5 字段名冲突

如果嵌入的多个类型有同名字段或方法，必须显式指定：

```go
type A struct {
    Name string
}

type B struct {
    Name string
}

type C struct {
    A
    B
}

func main() {
    c := C{
        A: A{Name: "A的名字"},
        B: B{Name: "B的名字"},
    }
    
    // fmt.Println(c.Name) // ❌ 编译错误：ambiguous selector c.Name
    
    fmt.Println(c.A.Name) // ✅ A的名字
    fmt.Println(c.B.Name) // ✅ B的名字
}
```

### 4.6 组合 vs 继承的优势

**Go 的组合优势：**
1. **更灵活**：不受单一继承链限制
2. **更显式**：依赖关系一目了然
3. **更安全**：避免深层继承带来的复杂性
4. **接口导向**：鼓励基于行为（接口）而非类型（类）设计

**经典设计原则：**
> "Favor composition over inheritance" —— 《Design Patterns》

Go 从语言层面强制实践这一原则。

## 5. 结构体标签（Struct Tags）

结构体标签是附加在字段上的**元数据**，主要用于**序列化/反序列化**（JSON、XML、数据库映射等）。

### 5.1 基本语法

标签是用反引号包裹的字符串，紧跟在字段定义后面：

```go
type User struct {
    Name  string `json:"name"`        // JSON 序列化时使用 "name"
    Age   int    `json:"age"`
    Email string `json:"email,omitempty"` // 空值时省略
}
```

### 5.2 JSON 标签详解

这是最常用的标签类型：

```go
type Product struct {
    ID          int     `json:"id"`
    Name        string  `json:"name"`
    Price       float64 `json:"price"`
    Stock       int     `json:"-"`              // 忽略该字段
    Description string  `json:"desc,omitempty"` // 空值时省略
    Tags        []string `json:"tags,omitempty"`
}

func main() {
    p := Product{
        ID:    1,
        Name:  "MacBook Pro",
        Price: 19999.00,
        Stock: 10, // 会被忽略
        Tags:  []string{"电脑", "苹果"},
    }
    
    data, _ := json.Marshal(p)
    fmt.Println(string(data))
    // 输出: {"id":1,"name":"MacBook Pro","price":19999,"tags":["电脑","苹果"]}
}
```

**JavaScript/TypeScript 对比：**
```javascript
// JavaScript 没有内置的序列化控制，通常用：
class Product {
    constructor(id, name, price, stock, tags) {
        this.id = id;
        this.name = name;
        this.price = price;
        this.stock = stock; // 想忽略需要手动处理
        this.tags = tags;
    }
    
    toJSON() {
        // 自定义序列化逻辑
        return {
            id: this.id,
            name: this.name,
            price: this.price,
            tags: this.tags
        };
    }
}

JSON.stringify(new Product(1, "MacBook", 19999, 10, ["电脑"]));
```

**TypeScript 使用 class-transformer：**
```typescript
import { Expose, Exclude } from 'class-transformer';

class Product {
    @Expose() id: number;
    @Expose() name: string;
    @Expose() price: number;
    @Exclude() stock: number; // 排除该字段
    @Expose() tags: string[];
}
```

### 5.3 常用 JSON 标签选项

| 标签选项 | 说明 | 示例 |
|---------|------|------|
| `json:"fieldName"` | 指定 JSON 键名 | `json:"user_name"` |
| `json:"-"` | 忽略该字段 | `json:"-"` |
| `json:",omitempty"` | 空值时省略 | `json:"age,omitempty"` |
| `json:",string"` | 转为字符串 | `json:"id,string"` |

**omitempty 详解：**
```go
type Config struct {
    Host     string   `json:"host"`
    Port     int      `json:"port,omitempty"`     // 0 时省略
    EnableTLS bool    `json:"enable_tls,omitempty"` // false 时省略
    Timeout  *int     `json:"timeout,omitempty"`  // nil 时省略
    Tags     []string `json:"tags,omitempty"`     // 空切片时省略
}

func main() {
    c := Config{Host: "localhost"}
    data, _ := json.Marshal(c)
    fmt.Println(string(data))
    // 输出: {"host":"localhost"} (其他字段都省略了)
}
```

### 5.4 多标签组合

一个字段可以有多个标签：

```go
type User struct {
    ID       int    `json:"id" db:"id" validate:"required"`
    Username string `json:"username" db:"user_name" validate:"min=3,max=20"`
    Email    string `json:"email" db:"email" validate:"email"`
}
```

**使用场景：**
- `json`: JSON 序列化
- `xml`: XML 序列化
- `db`: 数据库字段映射（如 GORM）
- `validate`: 数据验证（如 validator 库）
- `form`: 表单绑定（如 Gin 框架）

### 5.5 反射读取标签

标签通过反射机制访问：

```go
import "reflect"

type Person struct {
    Name string `json:"name" required:"true"`
}

func main() {
    t := reflect.TypeOf(Person{})
    field, _ := t.FieldByName("Name")
    
    // 读取标签
    jsonTag := field.Tag.Get("json")
    requiredTag := field.Tag.Get("required")
    
    fmt.Println(jsonTag)     // name
    fmt.Println(requiredTag) // true
}
```

### 5.6 实战：完整的 API 响应结构

```go
type APIResponse struct {
    Code    int         `json:"code"`
    Message string      `json:"message,omitempty"`
    Data    interface{} `json:"data,omitempty"`
}

type User struct {
    ID        int       `json:"id"`
    Username  string    `json:"username"`
    Email     string    `json:"email"`
    Password  string    `json:"-"` // 永不返回密码
    CreatedAt time.Time `json:"created_at"`
}

func getUserAPI() string {
    user := User{
        ID:        1,
        Username:  "john",
        Email:     "john@example.com",
        Password:  "secret123", // 不会被序列化
        CreatedAt: time.Now(),
    }
    
    resp := APIResponse{
        Code: 200,
        Data: user,
    }
    
    data, _ := json.Marshal(resp)
    return string(data)
}
```

**TypeScript API 响应对比：**
```typescript
interface APIResponse<T> {
    code: number;
    message?: string;
    data?: T;
}

interface User {
    id: number;
    username: string;
    email: string;
    // password 字段直接不定义
    createdAt: Date;
}

function getUserAPI(): string {
    const user: User = {
        id: 1,
        username: "john",
        email: "john@example.com",
        createdAt: new Date()
    };
    
    const resp: APIResponse<User> = {
        code: 200,
        data: user
    };
    
    return JSON.stringify(resp);
}
```

### 5.7 标签的最佳实践

1. **命名约定**：JSON 字段名通常用 `snake_case`（Go 社区）或 `camelCase`（前端友好）
2. **敏感字段**：密码、token 等使用 `json:"-"` 忽略
3. **可选字段**：使用指针类型 + `omitempty` 区分"未设置"和"零值"
4. **数据库映射**：同时使用 `json` 和 `db` 标签

```go
// ✅ 推荐
type User struct {
    ID        int       `json:"id" db:"id"`
    Username  string    `json:"username" db:"username"`
    Email     *string   `json:"email,omitempty" db:"email"` // 指针类型
    Password  string    `json:"-" db:"password"`
    CreatedAt time.Time `json:"created_at" db:"created_at"`
}
```

## 6. 常见陷阱与最佳实践

### 6.1 陷阱1：值接收者方法无法修改状态

```go
type Counter struct {
    count int
}

// ❌ 错误：值接收者无法修改
func (c Counter) Increment() {
    c.count++ // 修改的是副本
}

// ✅ 正确：指针接收者可以修改
func (c *Counter) IncrementCorrect() {
    c.count++
}

func main() {
    c := Counter{}
    c.Increment()
    fmt.Println(c.count) // 0 (没变！)
    
    c.IncrementCorrect()
    fmt.Println(c.count) // 1 (成功)
}
```

**教训：** 需要修改状态时，必须使用指针接收者。

### 6.2 陷阱2：结构体比较的限制

```go
type Person struct {
    Name string
    Age  int
}

type User struct {
    Name    string
    Friends []string // 切片不可比较
}

func main() {
    p1 := Person{Name: "Tom", Age: 18}
    p2 := Person{Name: "Tom", Age: 18}
    fmt.Println(p1 == p2) // ✅ true (所有字段可比较)
    
    u1 := User{Name: "Tom", Friends: []string{"Jerry"}}
    u2 := User{Name: "Tom", Friends: []string{"Jerry"}}
    // fmt.Println(u1 == u2) // ❌ 编译错误！含有切片的结构体不可比较
}
```

**可比较的类型：** 所有字段都是可比较类型（int、string、bool、指针、数组等）  
**不可比较：** 包含切片、map、函数字段的结构体

**解决方案：** 使用 `reflect.DeepEqual` 或自定义比较函数

```go
import "reflect"

func main() {
    u1 := User{Name: "Tom", Friends: []string{"Jerry"}}
    u2 := User{Name: "Tom", Friends: []string{"Jerry"}}
    
    fmt.Println(reflect.DeepEqual(u1, u2)) // true
}
```

### 6.3 陷阱3：空结构体的零值陷阱

```go
type Person struct {
    Name string
    Age  int
}

func main() {
    var p Person // 零值初始化
    fmt.Println(p) // {  0} (Name 为空字符串，Age 为 0)
    
    // 如何区分"未设置"和"设置为0"？
    // 解决方案：使用指针
}
```

**使用指针区分 nil 和零值：**
```go
type Config struct {
    Host    string
    Port    *int   // 使用指针
    Timeout *int
}

func main() {
    c := Config{Host: "localhost"}
    
    if c.Port == nil {
        fmt.Println("Port 未设置")
    }
    
    port := 0
    c.Port = &port
    if c.Port != nil && *c.Port == 0 {
        fmt.Println("Port 设置为 0")
    }
}
```

### 6.4 陷阱4：匿名字段的命名冲突

```go
type A struct {
    Name string
}

type B struct {
    Name string
}

type C struct {
    A
    B
}

func main() {
    c := C{
        A: A{Name: "A"},
        B: B{Name: "B"},
    }
    
    // fmt.Println(c.Name) // ❌ 编译错误：ambiguous selector
    fmt.Println(c.A.Name) // ✅ 必须显式指定
}
```

**教训：** 避免嵌入多个有相同字段名的类型。

### 6.5 陷阱5：结构体的并发安全

```go
type Counter struct {
    count int
}

func (c *Counter) Increment() {
    c.count++ // ❌ 并发不安全！
}

func main() {
    c := &Counter{}
    
    // 多个 goroutine 同时调用
    for i := 0; i < 1000; i++ {
        go c.Increment()
    }
    
    time.Sleep(time.Second)
    fmt.Println(c.count) // 结果不确定 (race condition)
}
```

**解决方案1：使用 sync.Mutex**
```go
import "sync"

type SafeCounter struct {
    mu    sync.Mutex
    count int
}

func (c *SafeCounter) Increment() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.count++
}
```

**解决方案2：使用 channel**
```go
type Counter struct {
    ch chan int
}

func NewCounter() *Counter {
    c := &Counter{ch: make(chan int)}
    go func() {
        count := 0
        for range c.ch {
            count++
        }
    }()
    return c
}

func (c *Counter) Increment() {
    c.ch <- 1
}
```

### 6.6 最佳实践总结

| 场景 | 推荐做法 | 原因 |
|------|---------|------|
| 方法接收者选择 | 统一使用指针接收者 | 避免混淆，保证一致性 |
| 大型结构体 | 传递指针 | 避免复制开销 |
| 敏感字段 | 使用 `json:"-"` | 防止泄露 |
| 可选字段 | 使用指针类型 | 区分"未设置"和"零值" |
| 并发访问 | 使用 `sync.Mutex` 或 channel | 保证线程安全 |
| 字段命名 | 首字母大写导出 | 控制可见性 |
| 结构体初始化 | 使用构造函数 | 封装初始化逻辑 |

**构造函数模式：**
```go
type Database struct {
    conn *sql.DB
    mu   sync.Mutex
}

// ✅ 提供构造函数
func NewDatabase(dsn string) (*Database, error) {
    conn, err := sql.Open("mysql", dsn)
    if err != nil {
        return nil, err
    }
    
    return &Database{
        conn: conn,
    }, nil
}

// 使用
func main() {
    db, err := NewDatabase("user:pass@/dbname")
    if err != nil {
        panic(err)
    }
    // 使用 db...
}
```

### 6.7 性能优化技巧

**1. 避免不必要的结构体复制**
```go
// ❌ 糟糕：每次调用都复制整个结构体
func ProcessUser(u User) {
    // ...
}

// ✅ 好：传递指针
func ProcessUser(u *User) {
    // ...
}
```

**2. 字段对齐优化内存**
```go
// ❌ 糟糕：占用 24 字节
type Bad struct {
    a bool   // 1 字节 + 7 字节填充
    b int64  // 8 字节
    c bool   // 1 字节 + 7 字节填充
}

// ✅ 好：占用 16 字节
type Good struct {
    b int64  // 8 字节
    a bool   // 1 字节
    c bool   // 1 字节 + 6 字节填充
}
```

**查看结构体大小：**
```go
import "unsafe"

func main() {
    fmt.Println(unsafe.Sizeof(Bad{}))  // 24
    fmt.Println(unsafe.Sizeof(Good{})) // 16
}
```

**教训：** 将大字段放在前面，小字段放在一起。

## 7. 实战示例：构建一个简单的用户管理系统

让我们综合运用所学知识，构建一个完整的用户管理系统。

```go
package main

import (
    "encoding/json"
    "fmt"
    "sync"
    "time"
)

// User 用户结构体
type User struct {
    ID        int       `json:"id"`
    Username  string    `json:"username"`
    Email     string    `json:"email"`
    Password  string    `json:"-"` // 永不序列化密码
    CreatedAt time.Time `json:"created_at"`
}

// UserManager 用户管理器
type UserManager struct {
    users  map[int]*User
    nextID int
    mu     sync.RWMutex // 读写锁
}

// NewUserManager 构造函数
func NewUserManager() *UserManager {
    return &UserManager{
        users:  make(map[int]*User),
        nextID: 1,
    }
}

// Create 创建用户
func (m *UserManager) Create(username, email, password string) (*User, error) {
    m.mu.Lock()
    defer m.mu.Unlock()
    
    // 验证用户名是否已存在
    for _, u := range m.users {
        if u.Username == username {
            return nil, fmt.Errorf("username %s already exists", username)
        }
    }
    
    user := &User{
        ID:        m.nextID,
        Username:  username,
        Email:     email,
        Password:  password,
        CreatedAt: time.Now(),
    }
    
    m.users[m.nextID] = user
    m.nextID++
    
    return user, nil
}

// Get 获取用户（读操作使用读锁）
func (m *UserManager) Get(id int) (*User, bool) {
    m.mu.RLock()
    defer m.mu.RUnlock()
    
    user, ok := m.users[id]
    return user, ok
}

// Update 更新用户
func (m *UserManager) Update(id int, email string) error {
    m.mu.Lock()
    defer m.mu.Unlock()
    
    user, ok := m.users[id]
    if !ok {
        return fmt.Errorf("user %d not found", id)
    }
    
    user.Email = email
    return nil
}

// Delete 删除用户
func (m *UserManager) Delete(id int) error {
    m.mu.Lock()
    defer m.mu.Unlock()
    
    if _, ok := m.users[id]; !ok {
        return fmt.Errorf("user %d not found", id)
    }
    
    delete(m.users, id)
    return nil
}

// List 列出所有用户
func (m *UserManager) List() []*User {
    m.mu.RLock()
    defer m.mu.RUnlock()
    
    users := make([]*User, 0, len(m.users))
    for _, user := range m.users {
        users = append(users, user)
    }
    
    return users
}

// ToJSON 序列化为 JSON
func (m *UserManager) ToJSON() (string, error) {
    m.mu.RLock()
    defer m.mu.RUnlock()
    
    data, err := json.MarshalIndent(m.users, "", "  ")
    if err != nil {
        return "", err
    }
    
    return string(data), nil
}

func main() {
    manager := NewUserManager()
    
    // 创建用户
    user1, _ := manager.Create("alice", "alice@example.com", "secret123")
    user2, _ := manager.Create("bob", "bob@example.com", "secret456")
    
    fmt.Println("Created users:")
    fmt.Printf("User 1: %+v\n", user1)
    fmt.Printf("User 2: %+v\n", user2)
    
    // 获取用户
    if user, ok := manager.Get(1); ok {
        fmt.Printf("\nFound user: %s (%s)\n", user.Username, user.Email)
    }
    
    // 更新用户
    manager.Update(1, "alice.new@example.com")
    
    // 列出所有用户
    fmt.Println("\nAll users:")
    for _, u := range manager.List() {
        fmt.Printf("- %s: %s\n", u.Username, u.Email)
    }
    
    // 导出为 JSON
    jsonData, _ := manager.ToJSON()
    fmt.Println("\nJSON export:")
    fmt.Println(jsonData)
    
    // 删除用户
    manager.Delete(2)
    fmt.Println("\nAfter deleting user 2:")
    fmt.Printf("Remaining users: %d\n", len(manager.List()))
}
```

**输出示例：**
```
Created users:
User 1: &{ID:1 Username:alice Email:alice@example.com Password:secret123 CreatedAt:2025-12-01 10:30:00}
User 2: &{ID:2 Username:bob Email:bob@example.com Password:secret456 CreatedAt:2025-12-01 10:30:00}

Found user: alice (alice@example.com)

All users:
- alice: alice.new@example.com
- bob: bob@example.com

JSON export:
{
  "1": {
    "id": 1,
    "username": "alice",
    "email": "alice.new@example.com",
    "created_at": "2025-12-01T10:30:00Z"
  },
  "2": {
    "id": 2,
    "username": "bob",
    "email": "bob@example.com",
    "created_at": "2025-12-01T10:30:00Z"
  }
}

After deleting user 2:
Remaining users: 1
```

**关键设计点：**
1. ✅ **构造函数模式**：`NewUserManager()` 初始化内部状态
2. ✅ **指针接收者**：所有方法统一使用 `*UserManager`
3. ✅ **并发安全**：使用 `sync.RWMutex` 保护共享数据
4. ✅ **错误处理**：返回明确的错误信息
5. ✅ **JSON 安全**：密码字段标记为 `json:"-"`
6. ✅ **内存优化**：使用指针存储用户，避免复制

**TypeScript 对比实现：**
```typescript
class User {
    constructor(
        public id: number,
        public username: string,
        public email: string,
        private password: string, // private 不会被序列化
        public createdAt: Date
    ) {}
    
    toJSON() {
        return {
            id: this.id,
            username: this.username,
            email: this.email,
            created_at: this.createdAt
        };
    }
}

class UserManager {
    private users = new Map<number, User>();
    private nextID = 1;
    
    create(username: string, email: string, password: string): User {
        // 验证逻辑...
        const user = new User(this.nextID++, username, email, password, new Date());
        this.users.set(user.id, user);
        return user;
    }
    
    get(id: number): User | undefined {
        return this.users.get(id);
    }
    
    // 其他方法...
}
```

## 8. 总结

Go 的结构体是数据的载体，方法是行为的载体。通过本文，我们深入学习了：

### 核心概念回顾

1. **结构体定义**：自定义复合类型，字段可见性通过首字母大小写控制
2. **初始化方式**：键值对、列表、new、取地址、匿名、零值（6种方式）
3. **方法定义**：接收者语法 `(r Receiver)` 绑定方法到类型
4. **指针 vs 值接收者**：
   - 值接收者：复制，无法修改原对象
   - 指针接收者：引用，可以修改，性能更好
5. **组合优于继承**：通过匿名字段实现类似继承的效果
6. **结构体标签**：控制 JSON/XML 序列化，数据库映射
7. **并发安全**：使用 `sync.Mutex` 或 channel 保护共享状态

### Go vs JavaScript/TypeScript

| 特性 | Go | JavaScript/TypeScript |
|------|----|-----------------------|
| 类型系统 | 结构体 + 方法 | Class（语法糖） |
| 继承 | ❌ 无，使用组合 | ✅ 单继承 + 接口 |
| 可见性 | 首字母大小写 | public/private 关键字 |
| 方法绑定 | 接收者语法 | `this` 关键字 |
| 序列化控制 | 结构体标签 | `toJSON()` 方法 |
| 并发安全 | 需显式加锁 | 单线程（但有 Worker） |
| 内存管理 | 值 vs 指针显式控制 | 自动引用 |

### 最佳实践速查

✅ **推荐做法：**
- 统一使用指针接收者
- 提供构造函数（`NewXxx`）
- 敏感字段用 `json:"-"`
- 可选字段用指针类型 + `omitempty`
- 大结构体传递指针
- 并发访问加锁

❌ **避免的做法：**
- 混用值接收者和指针接收者
- 直接导出可变字段（破坏封装）
- 深层嵌套（超过3层）
- 忽略并发安全问题
- 在结构体中存储大量数据

### 进阶方向

掌握了结构体，你已经掌握了 Go 面向对象编程的基础。但面向对象不仅仅是封装和组合，还有**多态**。

**下一步学习：**
- **接口（Interface）**：Go 的多态实现，鸭子类型
- **类型断言**：动态类型检查
- **反射**：运行时类型信息
- **泛型**：Go 1.18+ 的类型参数

下一篇文章，我们将深入探讨 Go 语言中最灵活、最强大的设计——**接口（Interface）**。

---

