---
title: "Go 语言基础之接口"
description: "深入理解 Go 语言独特的接口设计，学习鸭子类型的静态实现和空接口的应用。"
date: "2025-12-01"
seriesOrder: 16
---

# 16. Go 语言基础之接口

## 引言

在上一篇文章中，我们学习了结构体的封装和组合。本文将学习 Go 面向对象编程的最后一块拼图——**接口（Interface）**。

### 接口在不同语言中的实现

**TypeScript 接口：**
```typescript
// TypeScript: 描述对象的形状
interface Speaker {
    speak(): string;
}

// 必须显式声明实现
class Dog implements Speaker {
    speak(): string {
        return "汪汪汪";
    }
}
```

**Java 接口：**
```java
// Java: 定义契约
interface Speaker {
    String speak();
}

// 必须显式实现
class Dog implements Speaker {
    public String speak() {
        return "汪汪汪";
    }
}
```

**Go 接口：**
```go
// Go: 定义行为
type Speaker interface {
    Speak() string
}

// 无需显式声明！只要实现了方法就自动满足接口
type Dog struct{}
func (d Dog) Speak() string { return "汪汪汪" }
```

**关键区别：**
- TypeScript/Java：**显式声明**（`implements` 关键字）
- Go：**隐式实现**（鸭子类型）

> **鸭子类型（Duck Typing）：** "如果它走起来像鸭子，叫起来像鸭子，那它就是鸭子。"

Go 的接口是**鸭子类型的静态实现**——既有静态类型检查的安全性，又有动态语言的灵活性。

### Go 接口的版本演进（Go 1.25 更新）

- **Go 1.0 - 1.17**：接口只能包含方法
- **Go 1.18+**：引入泛型，接口可以作为类型约束
- **Go 1.20+**：`comparable` 接口内置支持
- **Go 1.25**（当前）：接口性能进一步优化，类型断言更快

## 1. 接口的定义

接口是一个**方法签名的集合**。它定义了"能做什么"，而不关心"怎么做"或"是谁在做"。

```go
## 1. 接口的定义

接口是一个**方法签名的集合**。它定义了"能做什么"，而不关心"怎么做"或"是谁在做"。

### 1.1 基本语法

```go
// 定义一个"会说话"的接口
type Speaker interface {
    Speak() string  // 方法签名：方法名 + 参数 + 返回值
}

// 定义一个"会移动"的接口
type Mover interface {
    Move(x, y int)
}

// 定义多个方法的接口
type Animal interface {
    Speak() string
    Move(x, y int)
    GetName() string
}
```

**接口命名约定：**
- 单方法接口：通常以 `-er` 结尾（如 `Reader`, `Writer`, `Speaker`）
- 多方法接口：使用描述性名词（如 `Animal`, `Database`）

### 1.2 接口与 TypeScript 对比

**TypeScript：**
```typescript
// TypeScript 接口可以包含属性和方法
interface Animal {
    name: string;        // 属性
    age: number;
    speak(): string;     // 方法
    move(x: number, y: number): void;
}

// 实现接口
class Dog implements Animal {
    constructor(
        public name: string,
        public age: number
    ) {}
    
    speak(): string {
        return "Woof!";
    }
    
    move(x: number, y: number): void {
        console.log(`Moving to (${x}, ${y})`);
    }
}
```

**Go：**
```go
// Go 接口只能包含方法，不能包含属性
type Animal interface {
    Speak() string
    Move(x, y int)
    GetName() string  // 需要通过方法访问属性
}

// 实现接口（无需 implements 关键字）
type Dog struct {
    Name string
    Age  int
}

func (d Dog) Speak() string {
    return "Woof!"
}

func (d Dog) Move(x, y int) {
    fmt.Printf("Moving to (%d, %d)\n", x, y)
}

func (d Dog) GetName() string {
    return d.Name
}
```

**关键区别：**
1. Go 接口**不能包含属性**，只能包含方法
2. Go **无需** `implements` 关键字
3. TypeScript 接口是**结构化类型**，Go 接口是**行为定义**

## 2. 隐式实现（Implicit Implementation）

这是 Go 接口最神奇的地方——**无需显式声明，只要实现了接口的所有方法，就自动满足该接口**。

### 2.1 基本示例

```go
// 定义接口
type Speaker interface {
    Speak() string
}

// 定义类型
type Dog struct {
    Name string
}

type Cat struct {
    Name string
}

// Dog 实现了 Speak 方法 → 自动满足 Speaker 接口
func (d Dog) Speak() string {
    return "汪汪汪"
}

// Cat 也实现了 Speak 方法 → 自动满足 Speaker 接口
func (c Cat) Speak() string {
    return "喵喵喵"
}

// 接受 Speaker 接口类型的函数
func MakeSound(s Speaker) {
    fmt.Println(s.Speak())
}

func main() {
    dog := Dog{Name: "旺财"}
    cat := Cat{Name: "咪咪"}
    
    // 无需类型转换！编译器自动识别它们都实现了 Speaker
    MakeSound(dog) // 汪汪汪
    MakeSound(cat) // 喵喵喵
}
```

**TypeScript 对比：**
```typescript
interface Speaker {
    speak(): string;
}

class Dog implements Speaker {  // 必须显式声明
    speak(): string {
        return "汪汪汪";
    }
}

class Cat implements Speaker {  // 必须显式声明
    speak(): string {
        return "喵喵喵";
    }
}

function makeSound(s: Speaker) {
    console.log(s.speak());
}

makeSound(new Dog()); // 汪汪汪
makeSound(new Cat()); // 喵喵喵
```

### 2.2 隐式实现的优势

**1. 解耦（Decoupling）**

接口定义者和实现者完全独立，互不依赖：

```go
// package fmt 中定义
type Stringer interface {
    String() string
}

// 你的代码中（完全不知道 fmt.Stringer 的存在）
type Person struct {
    Name string
}

func (p Person) String() string {
    return p.Name
}

// 自动满足 fmt.Stringer，可以被 fmt.Println 优化打印
func main() {
    p := Person{Name: "Tom"}
    fmt.Println(p) // 自动调用 String() 方法
}
```

**2. 后向兼容**

可以为已有类型添加新接口，而无需修改原代码：

```go
// 已有的第三方库类型
type ThirdPartyDB struct { /* ... */ }
func (db *ThirdPartyDB) Query(sql string) { /* ... */ }

// 你定义的新接口
type Querier interface {
    Query(sql string)
}

// ThirdPartyDB 自动满足 Querier 接口！
func useQuerier(q Querier) {
    q.Query("SELECT * FROM users")
}

func main() {
    db := &ThirdPartyDB{}
    useQuerier(db) // ✅ 工作正常
}
```

**3. 接口定义在使用方**

这是 Go 的最佳实践：由接口的**使用者**定义接口，而不是**实现者**。

```go
// ❌ 不推荐：实现者定义接口
package database

type Database interface {
    Connect() error
    Query(sql string) ([]Row, error)
    Close() error
}

type MySQL struct { /* ... */ }
func (m *MySQL) Connect() error { /* ... */ }
func (m *MySQL) Query(sql string) ([]Row, error) { /* ... */ }
func (m *MySQL) Close() error { /* ... */ }
```

```go
// ✅ 推荐：使用者定义接口
package userservice

// 我只需要 Query 能力
type Querier interface {
    Query(sql string) ([]Row, error)
}

func GetUsers(db Querier) []User {
    rows, _ := db.Query("SELECT * FROM users")
    // ...
}

// MySQL 自动满足 Querier
```

**优势：**
- 接口更小，更专注
- 测试更容易（可以 mock 小接口）
- 实现者无需预知所有使用场景

### 2.3 隐式实现的检查

虽然是隐式实现，但可以在编译时检查类型是否实现了接口：

```go
type Speaker interface {
    Speak() string
}

type Dog struct{}
func (d Dog) Speak() string { return "Woof" }

// 编译时检查（如果 Dog 没实现 Speaker，会报错）
var _ Speaker = Dog{} // ✅ 编译通过

// 或者使用指针
var _ Speaker = (*Dog)(nil)
```

**常见于库代码中：**
```go
// 确保我们的实现符合标准库接口
var _ io.Reader = (*MyReader)(nil)
var _ io.Writer = (*MyWriter)(nil)
var _ http.Handler = (*MyHandler)(nil)
```
```

## 2. 隐式实现 (Implicit Implementation)

这是 Go 接口最神奇的地方。

在 Java/TypeScript 中，你需要这样写：
```typescript
// TypeScript
class Dog implements Speaker { ... }
```

在 Go 中，**不需要 `implements` 关键字**。只要一个类型实现了接口中定义的所有方法，它就**自动**实现了该接口。

```go
type Dog struct {
    Name string
}

// Dog 实现了 Speak 方法
func (d Dog) Speak() string {
    return "汪汪汪"
}

type Cat struct {
    Name string
}

// Cat 也实现了 Speak 方法
func (c Cat) Speak() string {
    return "喵喵喵"
}
```

因为 `Dog` 和 `Cat` 都实现了 `Speak()` 方法，所以它们都自动成为了 `Speaker` 类型。

## 3. 接口值的内部结构

理解接口值的内部结构，有助于深入理解接口的工作机制。

### 3.1 接口值的组成

接口值在内存中由两部分组成：

```
接口值 = (类型, 值)
       = (type, data)
```

```go
type Speaker interface {
    Speak() string
}

type Dog struct {
    Name string
}

func (d Dog) Speak() string {
    return "Woof"
}

func main() {
    var s Speaker
    fmt.Printf("s = %v, type = %T\n", s, s) // s = <nil>, type = <nil>
    
    s = Dog{Name: "旺财"}
    fmt.Printf("s = %v, type = %T\n", s, s) // s = {旺财}, type = main.Dog
}
```

**内存布局：**
```
┌──────────────┐
│ Speaker 接口  │
├──────────────┤
│ type: *Dog   │ ← 动态类型
│ data: 0x...  │ ← 动态值（指向实际数据）
└──────────────┘
```

### 3.2 nil 接口 vs 非 nil 接口

这是一个常见陷阱：

```go
func main() {
    var s Speaker
    fmt.Println(s == nil) // true (接口为 nil)
    
    var d *Dog  // d 是 nil 指针
    s = d       // 将 nil 指针赋值给接口
    
    fmt.Println(s == nil)   // false! (接口不是 nil)
    fmt.Println(d == nil)   // true  (指针是 nil)
}
```

**解释：**
- `s` 的类型变成了 `*Dog`，值是 `nil`
- 接口 `s` 现在是 `(type: *Dog, data: nil)`
- 只有 `type` 和 `data` **都为 nil** 时，接口才等于 `nil`

**JavaScript 对比：**
```javascript
// JavaScript 没有这个问题，null 就是 null
let obj = null;
console.log(obj === null); // true

let wrapper = { value: null };
console.log(wrapper === null); // false
```

**实际影响示例：**
```go
func GetDog() *Dog {
    return nil  // 返回 nil 指针
}

func main() {
    var s Speaker = GetDog()
    
    if s == nil {
        fmt.Println("s is nil")
    } else {
        fmt.Println("s is not nil") // 会执行这里！
        // s.Speak() // 运行时 panic: nil pointer dereference
    }
}
```

**正确的判断方法：**
```go
func main() {
    var s Speaker = GetDog()
    
    // 方法1：反射检查
    if s != nil && reflect.ValueOf(s).IsNil() {
        fmt.Println("s holds a nil value")
    }
    
    // 方法2：类型断言检查
    if dog, ok := s.(*Dog); ok && dog == nil {
        fmt.Println("s is a nil *Dog")
    }
}
```

## 4. 接口组合（Interface Composition）

Go 支持接口的**嵌入组合**，类似结构体的组合。

### 4.1 基本组合

```go
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

// 组合接口
type ReadWriter interface {
    Reader  // 嵌入 Reader
    Writer  // 嵌入 Writer
}

// 等价于
type ReadWriter interface {
    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
}
```

### 4.2 标准库中的接口组合

```go
// io 包中的经典例子
type ReadCloser interface {
    Reader
    Closer
}

type WriteCloser interface {
    Writer
    Closer
}

type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}
```

**实现示例：**
```go
type File struct {
    name string
}

func (f *File) Read(p []byte) (int, error) { /* ... */ }
func (f *File) Write(p []byte) (int, error) { /* ... */ }
func (f *File) Close() error { /* ... */ }

// File 自动实现了 ReadWriteCloser
var _ io.ReadWriteCloser = (*File)(nil)
```

### 4.3 小接口的优势

Go 推崇定义小接口，然后组合使用。这被称为 **"接口隔离原则"（Interface Segregation Principle）**。

```go
// ❌ 不推荐：大接口
type Database interface {
    Connect() error
    Disconnect() error
    Query(sql string) ([]Row, error)
    Insert(table string, data map[string]any) error
    Update(table string, data map[string]any) error
    Delete(table string, id int) error
    Transaction(func() error) error
}

// ✅ 推荐：小接口组合
type Connector interface {
    Connect() error
    Disconnect() error
}

type Querier interface {
    Query(sql string) ([]Row, error)
}

type Inserter interface {
    Insert(table string, data map[string]any) error
}

// 按需组合
type FullDatabase interface {
    Connector
    Querier
    Inserter
}
```

**优势：**
- 更容易测试（mock 单个功能）
- 更容易复用（只实现需要的部分）
- 更符合单一职责原则

## 5. 多态（Polymorphism）

## 5. 多态（Polymorphism）

接口的主要作用是实现**多态**——同一个接口，不同的实现，产生不同的行为。

### 5.1 基本多态示例

```go
type Shape interface {
    Area() float64
    Perimeter() float64
}

type Rectangle struct {
    Width, Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func (r Rectangle) Perimeter() float64 {
    return 2 * (r.Width + r.Height)
}

type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.Radius * c.Radius
}

func (c Circle) Perimeter() float64 {
    return 2 * math.Pi * c.Radius
}

// 接受任何 Shape 类型
func PrintShapeInfo(s Shape) {
    fmt.Printf("面积: %.2f, 周长: %.2f\n", s.Area(), s.Perimeter())
}

func main() {
    r := Rectangle{Width: 10, Height: 5}
    c := Circle{Radius: 7}
    
    PrintShapeInfo(r) // 面积: 50.00, 周长: 30.00
    PrintShapeInfo(c) // 面积: 153.94, 周长: 43.98
}
```

**TypeScript 对比：**
```typescript
interface Shape {
    area(): number;
    perimeter(): number;
}

class Rectangle implements Shape {
    constructor(public width: number, public height: number) {}
    
    area(): number {
        return this.width * this.height;
    }
    
    perimeter(): number {
        return 2 * (this.width + this.height);
    }
}

function printShapeInfo(s: Shape) {
    console.log(`面积: ${s.area()}, 周长: ${s.perimeter()}`);
}

printShapeInfo(new Rectangle(10, 5));
```

### 5.2 实战：支付系统

```go
// 定义支付接口
type PaymentMethod interface {
    Pay(amount float64) error
    GetName() string
}

// 实现1：支付宝
type Alipay struct {
    Account string
}

func (a Alipay) Pay(amount float64) error {
    fmt.Printf("使用支付宝(%s)支付 %.2f 元\n", a.Account, amount)
    return nil
}

func (a Alipay) GetName() string {
    return "支付宝"
}

// 实现2：微信支付
type WeChatPay struct {
    OpenID string
}

func (w WeChatPay) Pay(amount float64) error {
    fmt.Printf("使用微信支付(%s)支付 %.2f 元\n", w.OpenID, amount)
    return nil
}

func (w WeChatPay) GetName() string {
    return "微信支付"
}

// 实现3：信用卡
type CreditCard struct {
    CardNumber string
}

func (c CreditCard) Pay(amount float64) error {
    fmt.Printf("使用信用卡(%s)支付 %.2f 元\n", c.CardNumber, amount)
    return nil
}

func (c CreditCard) GetName() string {
    return "信用卡"
}

// 订单处理（不关心具体支付方式）
func ProcessOrder(method PaymentMethod, amount float64) error {
    fmt.Printf("选择支付方式: %s\n", method.GetName())
    return method.Pay(amount)
}

func main() {
    // 多态：同一个函数，不同的行为
    ProcessOrder(Alipay{Account: "user@example.com"}, 99.99)
    ProcessOrder(WeChatPay{OpenID: "wx_123"}, 199.99)
    ProcessOrder(CreditCard{CardNumber: "**** 1234"}, 299.99)
}
```

**输出：**
```
选择支付方式: 支付宝
使用支付宝(user@example.com)支付 99.99 元
选择支付方式: 微信支付
使用微信支付(wx_123)支付 199.99 元
选择支付方式: 信用卡
使用信用卡(**** 1234)支付 299.99 元
```

**优势：**
- 轻松添加新支付方式（如 PayPal），无需修改 `ProcessOrder`
- 测试时可以 mock `PaymentMethod`
- 符合开闭原则（对扩展开放，对修改关闭）

## 6. 空接口（Empty Interface）—— `any`

## 6. 空接口（Empty Interface）—— `any`

空接口是不包含任何方法的接口：`interface{}`。因为任何类型都至少实现了 0 个方法，所以**任何类型都满足空接口**。

### 6.1 any 类型别名（Go 1.18+）

```go
// Go 1.18 之前
var v interface{} = "hello"

// Go 1.18+ 推荐使用 any
var v any = "hello"

// any 就是 interface{} 的别名
type any = interface{}
```

### 6.2 空接口的使用场景

**1. 通用容器**

```go
// 可以存储任意类型
func PrintAny(v any) {
    fmt.Println(v)
}

func main() {
    PrintAny(42)
    PrintAny("hello")
    PrintAny(true)
    PrintAny([]int{1, 2, 3})
}
```

**2. JSON 解析**

```go
// 解析未知结构的 JSON
func parseJSON(jsonStr string) (any, error) {
    var result any
    err := json.Unmarshal([]byte(jsonStr), &result)
    return result, err
}

func main() {
    data, _ := parseJSON(`{"name":"Tom","age":18}`)
    m := data.(map[string]any)  // 类型断言
    fmt.Println(m["name"])       // Tom
}
```

**3. 异构集合**

```go
// 存储不同类型的元素
items := []any{
    42,
    "hello",
    true,
    Person{Name: "Tom"},
}

for _, item := range items {
    fmt.Printf("%v (type: %T)\n", item, item)
}
```

**输出：**
```
42 (type: int)
hello (type: string)
true (type: bool)
{Tom} (type: main.Person)
```

### 6.3 TypeScript 的 any 对比

```typescript
// TypeScript
let value: any;
value = 42;
value = "hello";
value = { name: "Tom" };

// 可以调用任何方法（运行时可能出错）
value.toUpperCase();  // 如果 value 不是 string 会报错
```

```go
// Go
var value any
value = 42
value = "hello"
value = Person{Name: "Tom"}

// 必须通过类型断言才能调用方法
// value.toUpperCase() // ❌ 编译错误！

str, ok := value.(string)
if ok {
    fmt.Println(strings.ToUpper(str)) // ✅ 安全
}
```

**关键区别：**
- TypeScript `any`：完全关闭类型检查
- Go `any`：仍然需要类型断言，更安全

### 6.4 空接口的性能开销

使用 `any` 会有性能损失：

```go
// 直接传递：无额外开销
func Sum(a, b int) int {
    return a + b
}

// 使用 any：有装箱开销
func SumAny(a, b any) any {
    return a.(int) + b.(int)  // 需要类型断言
}
```

**装箱（Boxing）：** 将值类型转换为接口类型时，会在堆上分配内存。

**建议：**
- 优先使用具体类型
- 只在必要时使用 `any`（如通用库、JSON 解析）

## 7. 类型断言（Type Assertion）

## 7. 类型断言（Type Assertion）

当你把一个具体类型赋值给接口变量后，接口变量会"忘记"原来的具体类型。类型断言用于从接口值中取回具体类型。

### 7.1 基本语法

```go
value, ok := interfaceValue.(ConcreteType)
```

- `value`: 断言成功后的值
- `ok`: 布尔值，表示断言是否成功
- `ConcreteType`: 要断言的具体类型

### 7.2 安全的类型断言（comma-ok 模式）

```go
func main() {
    var x any = "hello"
    
    // ✅ 安全：使用 comma-ok 模式
    str, ok := x.(string)
    if ok {
        fmt.Println("是字符串:", str)
    } else {
        fmt.Println("不是字符串")
    }
    
    // ❌ 不安全：如果断言失败会 panic
    num := x.(int)  // panic: interface conversion: interface {} is string, not int
}
```

### 7.3 类型选择（Type Switch）

处理多种可能类型时，使用 `type switch` 更简洁：

```go
func describe(i any) {
    switch v := i.(type) {
    case int:
        fmt.Printf("整数: %d\n", v)
    case string:
        fmt.Printf("字符串: %s (长度 %d)\n", v, len(v))
    case bool:
        fmt.Printf("布尔值: %t\n", v)
    case []int:
        fmt.Printf("整数切片: %v\n", v)
    case Person:
        fmt.Printf("Person: %s\n", v.Name)
    case *Person:
        fmt.Printf("Person指针: %s\n", v.Name)
    case nil:
        fmt.Println("nil 值")
    default:
        fmt.Printf("未知类型: %T\n", v)
    }
}

func main() {
    describe(42)                    // 整数: 42
    describe("hello")               // 字符串: hello (长度 5)
    describe(true)                  // 布尔值: true
    describe([]int{1, 2, 3})        // 整数切片: [1 2 3]
    describe(Person{Name: "Tom"})   // Person: Tom
    describe(nil)                   // nil 值
    describe(3.14)                  // 未知类型: float64
}
```

**TypeScript 对比：**
```typescript
function describe(i: any) {
    if (typeof i === "number") {
        console.log(`整数: ${i}`);
    } else if (typeof i === "string") {
        console.log(`字符串: ${i}`);
    } else if (typeof i === "boolean") {
        console.log(`布尔值: ${i}`);
    } else if (Array.isArray(i)) {
        console.log(`数组: ${i}`);
    } else {
        console.log(`未知类型: ${typeof i}`);
    }
}
```

### 7.4 接口间的类型断言

```go
type Speaker interface {
    Speak() string
}

type Swimmer interface {
    Swim()
}

type Duck struct{}

func (d Duck) Speak() string { return "嘎嘎" }
func (d Duck) Swim()         { fmt.Println("游泳") }

func main() {
    var s Speaker = Duck{}
    
    // 断言接口变量是否同时实现了另一个接口
    if swimmer, ok := s.(Swimmer); ok {
        fmt.Println("这只鸭子会游泳")
        swimmer.Swim()
    }
}
```

### 7.5 实战：错误处理中的类型断言

```go
// 自定义错误类型
type ValidationError struct {
    Field   string
    Message string
}

func (e ValidationError) Error() string {
    return fmt.Sprintf("%s: %s", e.Field, e.Message)
}

func validateUser(name string) error {
    if name == "" {
        return ValidationError{
            Field:   "name",
            Message: "不能为空",
        }
    }
    return nil
}

func main() {
    err := validateUser("")
    
    if err != nil {
        // 检查是否是 ValidationError
        if vErr, ok := err.(ValidationError); ok {
            fmt.Printf("验证失败 - 字段: %s, 错误: %s\n", vErr.Field, vErr.Message)
        } else {
            fmt.Println("其他错误:", err)
        }
    }
}
```

### 7.6 类型断言的陷阱

**陷阱1：断言指针类型**
```go
type Animal interface {
    Speak() string
}

type Dog struct{}
func (d *Dog) Speak() string { return "Woof" }

func main() {
    var a Animal = &Dog{}
    
    // ✅ 正确：断言为指针类型
    dog, ok := a.(*Dog)
    fmt.Println(ok) // true
    
    // ❌ 错误：断言为值类型（失败）
    _, ok = a.(Dog)
    fmt.Println(ok) // false
}
```

**陷阱2：nil 接口的断言**
```go
func main() {
    var a any  // nil 接口
    
    // panic: interface conversion: interface is nil, not string
    // str := a.(string)
    
    // ✅ 正确：先检查 nil
    if a != nil {
        str, ok := a.(string)
        fmt.Println(str, ok)
    }
}
```

## 8. 接口的最佳实践

## 8. 接口的最佳实践

### 8.1 接口定义越小越好

Go 社区推崇 **"单方法接口"** 和 **"接口隔离原则"**。

```go
// ✅ 推荐：单方法接口
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type Closer interface {
    Close() error
}

// 按需组合
type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}
```

```go
// ❌ 不推荐：大接口
type FileOperations interface {
    Read(p []byte) (n int, err error)
    Write(p []byte) (n int, err error)
    Close() error
    Seek(offset int64, whence int) (int64, error)
    Stat() (os.FileInfo, error)
}
```

**优势：**
- 更容易实现
- 更容易测试（mock 更简单）
- 更灵活的组合

### 8.2 接受接口，返回结构体

**Accept interfaces, return structs.**

```go
// ✅ 推荐
func ProcessData(r io.Reader) (*Result, error) {
    // r 是接口（灵活，可测试）
    // 返回具体类型（明确，高效）
    return &Result{}, nil
}

// ❌ 不推荐
func ProcessData(f *os.File) (io.Reader, error) {
    // f 是具体类型（不灵活）
    // 返回接口（不必要）
    return f, nil
}
```

**原因：**
- 参数用接口：调用方可以传任何实现（包括 mock）
- 返回具体类型：调用方知道确切的类型，避免类型断言

### 8.3 在使用方定义接口

**接口应该由使用者定义，而不是实现者。**

```go
// ❌ 不推荐：database 包定义接口
package database

type Database interface {
    Query(sql string) ([]Row, error)
    Insert(table string, data any) error
    // ...很多方法
}

type MySQL struct{}
func (m *MySQL) Query(...) { /* ... */ }
```

```go
// ✅ 推荐：userservice 定义自己需要的接口
package userservice

type UserQuerier interface {
    Query(sql string) ([]Row, error)  // 只需要 Query
}

func GetUsers(db UserQuerier) []User {
    rows, _ := db.Query("SELECT * FROM users")
    // ...
}

// MySQL 自动满足 UserQuerier
```

### 8.4 使用空接口要谨慎

```go
// ❌ 不推荐：滥用 any
func Process(data any) any {
    // 失去了类型安全
    return data
}

// ✅ 推荐：使用泛型（Go 1.18+）
func Process[T any](data T) T {
    return data
}

// ✅ 推荐：具体类型
func ProcessUser(user User) User {
    return user
}
```

### 8.5 检查接口实现

在编译时验证类型是否实现了接口：

```go
var _ io.Reader = (*MyReader)(nil)
var _ io.Writer = (*MyWriter)(nil)
var _ http.Handler = (*MyHandler)(nil)
```

### 8.6 避免接口污染

不要为了使用接口而定义接口。

```go
// ❌ 不必要的接口
type UserGetter interface {
    GetUser(id int) (*User, error)
}

type UserService struct{}
func (s *UserService) GetUser(id int) (*User, error) { /* ... */ }

// 如果只有一个实现，直接用结构体
```

## 9. 常见陷阱

### 9.1 nil 接口陷阱

```go
func GetError() error {
    var err *MyError = nil  // nil 指针
    return err              // 返回的接口不是 nil！
}

func main() {
    if err := GetError(); err != nil {
        fmt.Println("有错误") // 会执行！
    }
}
```

**解决方案：**
```go
func GetError() error {
    var err *MyError = nil
    if err == nil {
        return nil  // 返回 nil 接口
    }
    return err
}
```

### 9.2 接口比较陷阱

```go
type Person struct {
    Name string
    Data []int  // 切片不可比较
}

func main() {
    var a, b any
    a = Person{Name: "Tom", Data: []int{1}}
    b = Person{Name: "Tom", Data: []int{1}}
    
    // panic: runtime error: comparing uncomparable type main.Person
    fmt.Println(a == b)
}
```

### 9.3 方法集陷阱

```go
type Counter struct {
    count int
}

// 指针接收者
func (c *Counter) Increment() {
    c.count++
}

type Incrementer interface {
    Increment()
}

func main() {
    c := Counter{}
    
    // var i Incrementer = c  // ❌ 编译错误！Counter 没有实现 Incrementer
    var i Incrementer = &c    // ✅ *Counter 实现了 Incrementer
}
```

## 10. 实战：插件系统

```go
package main

import "fmt"

// 定义插件接口
type Plugin interface {
    Name() string
    Execute(args map[string]any) (any, error)
}

// 插件管理器
type PluginManager struct {
    plugins map[string]Plugin
}

func NewPluginManager() *PluginManager {
    return &PluginManager{
        plugins: make(map[string]Plugin),
    }
}

func (pm *PluginManager) Register(p Plugin) {
    pm.plugins[p.Name()] = p
}

func (pm *PluginManager) Execute(name string, args map[string]any) (any, error) {
    plugin, ok := pm.plugins[name]
    if !ok {
        return nil, fmt.Errorf("plugin %s not found", name)
    }
    return plugin.Execute(args)
}

// 实现1：日志插件
type LoggerPlugin struct{}

func (l LoggerPlugin) Name() string {
    return "logger"
}

func (l LoggerPlugin) Execute(args map[string]any) (any, error) {
    message := args["message"].(string)
    fmt.Println("[LOG]", message)
    return nil, nil
}

// 实现2：缓存插件
type CachePlugin struct {
    data map[string]any
}

func NewCachePlugin() *CachePlugin {
    return &CachePlugin{data: make(map[string]any)}
}

func (c CachePlugin) Name() string {
    return "cache"
}

func (c *CachePlugin) Execute(args map[string]any) (any, error) {
    action := args["action"].(string)
    key := args["key"].(string)
    
    switch action {
    case "set":
        c.data[key] = args["value"]
        return nil, nil
    case "get":
        return c.data[key], nil
    default:
        return nil, fmt.Errorf("unknown action: %s", action)
    }
}

func main() {
    pm := NewPluginManager()
    
    // 注册插件
    pm.Register(LoggerPlugin{})
    pm.Register(NewCachePlugin())
    
    // 使用插件
    pm.Execute("logger", map[string]any{"message": "系统启动"})
    pm.Execute("cache", map[string]any{"action": "set", "key": "user1", "value": "Tom"})
    
    result, _ := pm.Execute("cache", map[string]any{"action": "get", "key": "user1"})
    fmt.Println("缓存值:", result)
}
```

## 11. 总结

Go 的接口是其类型系统的灵魂，也是其设计哲学的体现。

### 核心概念回顾

1. **隐式实现**：无需 `implements` 关键字，鸭子类型的静态实现
2. **接口值**：由 `(type, data)` 组成，理解 nil 接口的陷阱
3. **接口组合**：通过嵌入实现灵活的组合
4. **多态**：同一接口，不同实现，不同行为
5. **空接口 `any`**：可以存储任意类型，但需类型断言
6. **类型断言**：从接口值中取回具体类型，使用 comma-ok 模式避免 panic
7. **Type Switch**：优雅地处理多种类型

### Go vs TypeScript/Java

| 特性 | Go | TypeScript | Java |
|------|----|-----------|----|
| 实现方式 | 隐式 | 显式 | 显式 |
| 关键字 | 无 | `implements` | `implements` |
| 接口内容 | 仅方法 | 属性+方法 | 方法+常量 |
| 多态 | ✅ | ✅ | ✅ |
| 类型断言 | 运行时 | 编译时 | 运行时 |
| 空接口 | `any` | `any` | `Object` |

### 最佳实践总结

✅ **推荐：**
- 定义小接口（单方法优先）
- 参数用接口，返回值用结构体
- 由使用方定义接口
- 使用 comma-ok 模式做类型断言
- 编译时检查接口实现

❌ **避免：**
- 大接口（超过3个方法考虑拆分）
- 滥用空接口 `any`
- 由实现方定义接口
- 直接类型断言（不检查 ok）
- 不必要的接口抽象

### 标准库经典接口

掌握这些接口，你就能理解 Go 标准库的设计模式：

```go
// io 包
type Reader interface { Read(p []byte) (n int, err error) }
type Writer interface { Write(p []byte) (n int, err error) }
type Closer interface { Close() error }

// fmt 包
type Stringer interface { String() string }

// http 包
type Handler interface { ServeHTTP(ResponseWriter, *Request) }

// error 包
type error interface { Error() string }

// sort 包
type Interface interface {
    Len() int
    Less(i, j int) bool
    Swap(i, j int)
}
```

### 进阶方向

- **泛型约束**：Go 1.18+ 接口可以作为类型约束
- **反射**：`reflect` 包动态检查接口实现
- **代码生成**：使用 `go generate` 自动生成接口实现
- **设计模式**：策略模式、适配器模式、装饰器模式

下一篇文章，我们将探讨 Go 语言的代码组织方式——**包（Package）和模块（Module）**，学习如何构建可维护的大型项目。

---

