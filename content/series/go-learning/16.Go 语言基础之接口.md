---
title: "Go 语言基础之接口"
description: "深入理解 Go 语言独特的接口设计，学习鸭子类型的静态实现和空接口的应用。"
date: "2025-11-25"
seriesOrder: 16
---

# 16. Go 语言基础之接口

## 引言

在 TypeScript 中，我们使用 `interface` 来定义对象的形状（属性和方法）。
在 Java 中，我们使用 `interface` 来定义契约，并要求类显式地 `implements` 它。

Go 语言的接口（Interface）设计非常独特，它被称为 **"鸭子类型" (Duck Typing)** 的静态实现。

> "如果它走起来像鸭子，叫起来像鸭子，那它就是鸭子。"

## 1. 接口的定义

接口是一个方法签名的集合。它定义了"能做什么"，而不关心"怎么做"或"是谁在做"。

```go
// 定义一个"会说话"的接口
type Speaker interface {
    Speak() string
}
```

## 2. 隐式实现 (Implicit Implementation)

这是 Go 接口最神奇的地方。

在 Java/TypeScript 中，你需要这样写：
```typescript
// TypeScript
class Dog implements Speaker { ... }
```

在 Go 中，**不需要 `implements` 关键字**。只要一个类型实现了接口中定义的所有方法，它就**自动**实现了该接口。

```go
type Dog struct {
    Name string
}

// Dog 实现了 Speak 方法
func (d Dog) Speak() string {
    return "汪汪汪"
}

type Cat struct {
    Name string
}

// Cat 也实现了 Speak 方法
func (c Cat) Speak() string {
    return "喵喵喵"
}
```

因为 `Dog` 和 `Cat` 都实现了 `Speak()` 方法，所以它们都自动成为了 `Speaker` 类型。

## 3. 多态 (Polymorphism)

接口的主要作用是实现多态。我们可以定义一个函数，接受 `Speaker` 接口类型的参数。

```go
func MakeSound(s Speaker) {
    fmt.Println(s.Speak())
}

func main() {
    dog := Dog{Name: "旺财"}
    cat := Cat{Name: "咪咪"}
    
    MakeSound(dog) // 输出: 汪汪汪
    MakeSound(cat) // 输出: 喵喵喵
}
```

这使得代码非常灵活和解耦。`MakeSound` 函数不需要知道具体传进来的是狗还是猫，只要它"会说话"就行。

## 4. 空接口 (Empty Interface) —— Go 的 `any`

Go 中有一个特殊的接口，它不包含任何方法：`interface{}`。

因为任何类型都至少实现了 0 个方法，所以**任何类型都实现了空接口**。

在 Go 1.18 之后，引入了一个别名 `any`，它等同于 `interface{}`。

```go
// 可以接收任何类型的参数
func PrintAny(v any) {
    fmt.Println(v)
}

func main() {
    PrintAny(1)
    PrintAny("hello")
    PrintAny(true)
    PrintAny(Dog{})
}
```

这类似于 TypeScript 中的 `any` 类型。它常用于：
1.  `fmt.Println` 等通用打印函数。
2.  解析结构未知的 JSON 数据（`map[string]any`）。

## 5. 类型断言 (Type Assertion)

当你把一个具体类型赋值给接口变量后，接口变量就"忘记"了原来的具体类型，只保留了接口定义的方法。

如果你需要从接口变量中取回原来的具体类型，需要使用**类型断言**。

### 5.1 语法

`value, ok := x.(T)`

-   `x`: 接口变量。
-   `T`: 想要断言的具体类型。

```go
var x any = "hello"

// 断言 x 是 string 类型
s, ok := x.(string)
if ok {
    fmt.Println("x 是字符串:", s)
} else {
    fmt.Println("x 不是字符串")
}
```

### 5.2 类型选择 (Type Switch)

如果你想判断一个接口变量到底是哪种类型，可以使用 `type switch`。

```go
func checkType(i any) {
    switch v := i.(type) {
    case int:
        fmt.Printf("是整数: %d\n", v)
    case string:
        fmt.Printf("是字符串: %s\n", v)
    case Dog:
        fmt.Printf("是只狗: %s\n", v.Name)
    default:
        fmt.Printf("未知类型\n")
    }
}
```

## 6. 接口的最佳实践

1.  **接口定义越小越好**：Go 提倡定义小接口。比如标准库中的 `io.Reader` 只定义了一个 `Read` 方法，`io.Writer` 只定义了一个 `Write` 方法。小接口更容易被实现和复用。
2.  **接受接口，返回结构体**：在设计函数时，参数最好是接口（为了灵活性），返回值最好是具体类型（除非必须返回接口）。

## 7. 总结

Go 的接口是其类型系统的灵魂。

1.  **非侵入式**：不需要显式声明实现，解耦了定义和实现。
2.  **多态**：通过接口实现通用逻辑。
3.  **空接口**：实现了类似动态语言的灵活性。

掌握了接口，你就能看懂 Go 标准库中大量的设计模式（如 `io.Reader/Writer`, `http.Handler`）。

下一篇文章，我们将探讨 Go 语言的代码组织方式——包（Package），这是我们系列文章的基础部分的最后一篇。

---

