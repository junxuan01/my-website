---
title: "Go 语言基础之函数"
description: "学习 Go 语言的函数定义、多返回值、匿名函数和闭包，了解 Go 独特的错误处理方式和 defer 机制。"
date: "2025-12-01"
seriesOrder: 14
---

# 14. Go 语言基础之函数

## 引言

函数是程序的基本构建块。在现代编程语言中，函数都是"一等公民"（First-class Citizen）——可以赋值给变量、作为参数传递、作为返回值返回。

### 函数在不同语言中的特点

**JavaScript/TypeScript：**
```javascript
// 函数表达式
const add = (x, y) => x + y;

// 默认参数
function greet(name = "World") {
    return `Hello, ${name}!`;
}

// 解构参数
function createUser({ name, age = 18 }) {
    return { name, age };
}

// 错误处理：try-catch
try {
    const data = JSON.parse(jsonStr);
} catch (error) {
    console.error(error);
}
```

**Go：**
```go
// 函数定义（显式类型）
func add(x, y int) int {
    return x + y
}

// ❌ 不支持默认参数
// ❌ 不支持函数重载
// ✅ 支持多返回值
// ✅ 支持闭包
// ✅ 支持 defer

// 错误处理：返回 error
func parseJSON(jsonStr string) (*Data, error) {
    var data Data
    err := json.Unmarshal([]byte(jsonStr), &data)
    if err != nil {
        return nil, err
    }
    return &data, nil
}
```

**关键区别：**
- Go **不支持默认参数**和**函数重载**
- Go 使用**多返回值**代替异常机制
- Go 的 **defer** 机制优雅地处理资源释放

### Go 1.25 函数特性

- **Go 1.0 - 1.17**：基本函数特性
- **Go 1.18+**：支持泛型函数
- **Go 1.21+**：内置函数性能优化
- **Go 1.25**（当前）：函数调用开销进一步降低

## 1. 函数定义

### 1.1 基本语法

```go
// func 函数名(参数列表) (返回值列表) { 函数体 }
func add(x int, y int) int {
    return x + y
}

// 调用
result := add(3, 5) // 8
```

### 1.2 参数简写

相邻的同类型参数可以省略类型：

```go
// x, y 都是 int
func add(x, y int) int {
    return x + y
}

// a, b 是 int，c, d 是 string
func process(a, b int, c, d string) {
    // ...
}
```

### 1.3 命名返回值

可以为返回值命名，相当于声明了局部变量：

```go
func divide(dividend, divisor float64) (result float64, err error) {
    if divisor == 0 {
        err = fmt.Errorf("除数不能为 0")
        return  // 裸返回：返回命名返回值的当前值
    }
    result = dividend / divisor
    return  // 等价于 return result, err
}
```

**TypeScript 对比：**
```typescript
function divide(dividend: number, divisor: number): { result: number, error?: string } {
    if (divisor === 0) {
        return { result: 0, error: "除数不能为 0" };
    }
    return { result: dividend / divisor };
}
```

**优势：**
- 自文档化：返回值含义更清晰
- 简化返回：可以使用裸 `return`

**注意：**
- 命名返回值会被零值初始化
- 裸返回在复杂函数中可能降低可读性

### 1.4 无返回值函数

```go
func sayHello(name string) {
    fmt.Printf("Hello, %s!\n", name)
}

// 等价于返回 ()
func sayHello(name string) () {
    fmt.Printf("Hello, %s!\n", name)
}
```

## 2. 多返回值（Multiple Return Values）

这是 Go 最著名的特性之一，彻底改变了错误处理方式。

### 2.1 基本用法

```go
// 返回两个 int
func swap(x, y string) (string, string) {
    return y, x
}

func main() {
    a, b := swap("hello", "world")
    fmt.Println(a, b) // world hello
}
```

**JavaScript 对比：**
```javascript
// JavaScript: 返回数组或对象
function swap(x, y) {
    return [y, x];  // 或 { first: y, second: x }
}

const [a, b] = swap("hello", "world");
console.log(a, b); // world hello
```

### 2.2 忽略返回值

使用 `_` 忽略不需要的返回值：

```go
func getNameAndAge() (string, int) {
    return "Tom", 18
}

func main() {
    name, _ := getNameAndAge()  // 忽略 age
    fmt.Println(name)
    
    _, age := getNameAndAge()   // 忽略 name
    fmt.Println(age)
}
```

### 2.3 错误处理模式

Go 标准库大量使用 `(result, error)` 模式：

```go
func readFile(filename string) ([]byte, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        return nil, fmt.Errorf("读取文件失败: %w", err)
    }
    return data, nil
}

func main() {
    data, err := readFile("config.json")
    if err != nil {
        log.Fatal(err)
    }
    // 使用 data...
}
```

**优势：**
- 错误处理显式化，不会被忽略
- 无需 try-catch 嵌套
- 错误是值，可以被检查、包装、传递

**TypeScript try-catch 对比：**
```typescript
function readFile(filename: string): Buffer {
    try {
        return fs.readFileSync(filename);
    } catch (error) {
        throw new Error(`读取文件失败: ${error}`);
    }
}

try {
    const data = readFile("config.json");
    // 使用 data...
} catch (error) {
    console.error(error);
}
```

### 2.4 最佳实践：错误优先返回

```go
// ✅ 推荐：错误放在最后
func parseJSON(jsonStr string) (*Data, error) {
    var data Data
    err := json.Unmarshal([]byte(jsonStr), &data)
    if err != nil {
        return nil, err
    }
    return &data, nil
}

// ❌ 不推荐：错误不在最后
func parseJSON(jsonStr string) (error, *Data) {
    // ...
}
```

## 3. 可变参数（Variadic Functions）

类似 JavaScript 的 Rest Parameters (`...args`)。

### 3.1 基本语法

```go
// nums 是 []int 切片
func sum(nums ...int) int {
    total := 0
    for _, num := range nums {
        total += num
    }
    return total
}

func main() {
    fmt.Println(sum(1, 2))         // 3
    fmt.Println(sum(1, 2, 3, 4))   // 10
    
    // 展开切片传递
    numbers := []int{1, 2, 3, 4, 5}
    fmt.Println(sum(numbers...))   // 15
}
```

**JavaScript 对比：**
```javascript
function sum(...nums) {
    return nums.reduce((a, b) => a + b, 0);
}

console.log(sum(1, 2));        // 3
console.log(sum(1, 2, 3, 4));  // 10

const numbers = [1, 2, 3, 4, 5];
console.log(sum(...numbers));  // 15
```

### 3.2 可变参数的位置

可变参数必须是**最后一个参数**：

```go
// ✅ 正确
func printf(format string, args ...any) {
    fmt.Printf(format, args...)
}

// ❌ 错误：可变参数不在最后
// func invalid(args ...int, format string) {}
```

### 3.3 实战：自定义日志函数

```go
func logInfo(prefix string, messages ...string) {
    for _, msg := range messages {
        fmt.Printf("[%s INFO] %s\n", prefix, msg)
    }
}

func main() {
    logInfo("APP", "服务启动", "端口监听:8080", "准备就绪")
}
```

**输出：**
```
[APP INFO] 服务启动
[APP INFO] 端口监听:8080
[APP INFO] 准备就绪
```

## 4. 匿名函数与闭包（Closures）

Go 支持匿名函数和闭包，机制与 JavaScript 几乎完全一致。

### 4.1 匿名函数

```go
func main() {
    // 定义并立即调用
    func() {
        fmt.Println("Hello from anonymous function")
    }()
    
    // 赋值给变量
    add := func(x, y int) int {
        return x + y
    }
    fmt.Println(add(3, 5)) // 8
}
```

**JavaScript 对比：**
```javascript
// 立即调用函数表达式 (IIFE)
(function() {
    console.log("Hello from anonymous function");
})();

// 赋值给变量
const add = (x, y) => x + y;
console.log(add(3, 5)); // 8
```

### 4.2 闭包（Closure）

闭包可以**捕获**外部函数的变量：

```go
func adder() func(int) int {
    sum := 0  // 被闭包捕获
    return func(x int) int {
        sum += x
        return sum
    }
}

func main() {
    pos := adder()
    fmt.Println(pos(1)) // 1
    fmt.Println(pos(2)) // 3  (sum 累加到 3)
    fmt.Println(pos(3)) // 6  (sum 累加到 6)
    
    // 创建新的闭包，有独立的 sum
    neg := adder()
    fmt.Println(neg(-1)) // -1
}
```

**JavaScript 对比：**
```javascript
function adder() {
    let sum = 0;  // 被闭包捕获
    return function(x) {
        sum += x;
        return sum;
    };
}

const pos = adder();
console.log(pos(1)); // 1
console.log(pos(2)); // 3
console.log(pos(3)); // 6
```

### 4.3 闭包陷阱：循环变量捕获

```go
// ❌ 错误示例
func main() {
    var functions []func()
    
    for i := 0; i < 3; i++ {
        functions = append(functions, func() {
            fmt.Println(i)  // 捕获的是 i 的引用，不是值
        })
    }
    
    for _, f := range functions {
        f()  // 输出: 3 3 3 (全是 3！)
    }
}
```

**解决方案1：传参**
```go
func main() {
    var functions []func()
    
    for i := 0; i < 3; i++ {
        functions = append(functions, func(n int) func() {
            return func() {
                fmt.Println(n)
            }
        }(i))  // 立即调用，传入 i 的值
    }
    
    for _, f := range functions {
        f()  // 输出: 0 1 2
    }
}
```

**解决方案2：局部变量**
```go
func main() {
    var functions []func()
    
    for i := 0; i < 3; i++ {
        i := i  // 创建新的局部变量
        functions = append(functions, func() {
            fmt.Println(i)
        })
    }
    
    for _, f := range functions {
        f()  // 输出: 0 1 2
    }
}
```

### 4.4 实战：计数器生成器

```go
func makeCounter(start int) (increment func(), decrement func(), value func() int) {
    count := start
    
    increment = func() {
        count++
    }
    
    decrement = func() {
        count--
    }
    
    value = func() int {
        return count
    }
    
    return
}

func main() {
    inc, dec, val := makeCounter(0)
    
    inc()
    inc()
    fmt.Println(val()) // 2
    
    dec()
    fmt.Println(val()) // 1
}
```

## 5. defer（延迟执行）

这是 Go 独有的、极其实用的特性。

### 5.1 基本用法

`defer` 注册的函数会在**当前函数返回前**执行：

```go
func example() {
    fmt.Println("开始")
    defer fmt.Println("结束")  // 在函数返回前执行
    fmt.Println("中间")
}

// 输出:
// 开始
// 中间
// 结束
```

### 5.2 资源清理模式

```go
func readFile(filename string) error {
    file, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer file.Close()  // 无论如何都会关闭文件
    
    // 即使这里 panic，file.Close() 也会执行
    data := make([]byte, 1024)
    _, err = file.Read(data)
    return err
}
```

**JavaScript try-finally 对比：**
```javascript
function readFile(filename) {
    const file = fs.openSync(filename);
    try {
        const data = Buffer.alloc(1024);
        fs.readSync(file, data);
        return data;
    } finally {
        fs.closeSync(file);  // 确保关闭
    }
}
```

**defer 的优势：**
- 资源的打开和关闭代码紧挨着（更容易维护）
- 不会因为忘记写 finally 而泄漏资源
- 即使 panic，defer 也会执行

### 5.3 执行顺序：后进先出（LIFO）

多个 defer 按**栈**的顺序执行：

```go
func main() {
    defer fmt.Println("1")
    defer fmt.Println("2")
    defer fmt.Println("3")
    fmt.Println("正常代码")
}

// 输出:
// 正常代码
// 3
// 2
// 1
```

**实际应用：数据库事务**
```go
func transferMoney(from, to int, amount float64) error {
    tx, err := db.Begin()
    if err != nil {
        return err
    }
    
    // 设置清理逻辑
    defer func() {
        if err != nil {
            tx.Rollback()  // 出错时回滚
        } else {
            tx.Commit()    // 成功时提交
        }
    }()
    
    err = debit(tx, from, amount)
    if err != nil {
        return err
    }
    
    err = credit(tx, to, amount)
    if err != nil {
        return err
    }
    
    return nil
}
```

### 5.4 defer 与 返回值

defer 在 return 之后、函数真正返回之前执行：

```go
func example() (result int) {
    defer func() {
        result++  // 可以修改命名返回值！
    }()
    return 0
}

func main() {
    fmt.Println(example()) // 1 (不是 0!)
}
```

**执行顺序：**
1. 计算返回值 (`result = 0`)
2. 执行 defer (`result++`, 变成 1)
3. 返回 result (1)

### 5.5 defer 的性能考虑

defer 有轻微的性能开销（Go 1.25 已优化到几乎可以忽略）：

```go
// 性能敏感的热路径
func fastPath() {
    mutex.Lock()
    // 如果这里的代码很简单且不会 panic
    // 可以手动 Unlock 而不用 defer
    doSomething()
    mutex.Unlock()
}

// 复杂逻辑或可能 panic 的代码
func complexPath() {
    mutex.Lock()
    defer mutex.Unlock()  // 推荐用 defer，确保安全
    
    // 复杂逻辑...
    if condition {
        return  // 多个返回点，defer 确保 Unlock
    }
    // ...
}
```

### 5.6 defer 陷阱：循环中的 defer

```go
// ❌ 错误：defer 在循环中累积
func processFiles(files []string) error {
    for _, filename := range files {
        f, err := os.Open(filename)
        if err != nil {
            return err
        }
        defer f.Close()  // 所有 defer 会累积到函数结束才执行！
        
        // 处理文件...
    }
    return nil
}
// 如果处理 1000 个文件，会同时打开 1000 个文件句柄！
```

**解决方案：使用匿名函数**
```go
// ✅ 正确
func processFiles(files []string) error {
    for _, filename := range files {
        err := func() error {
            f, err := os.Open(filename)
            if err != nil {
                return err
            }
            defer f.Close()  // 在匿名函数结束时关闭
            
            // 处理文件...
            return nil
        }()
        
        if err != nil {
            return err
        }
    }
    return nil
}
```

## 6. 函数类型与高阶函数

Go 的函数是一等公民，可以作为类型、参数和返回值。

### 6.1 函数类型

```go
// 定义函数类型
type Operation func(int, int) int

// 使用函数类型
func add(x, y int) int {
    return x + y
}

func multiply(x, y int) int {
    return x * y
}

func compute(a, b int, op Operation) int {
    return op(a, b)
}

func main() {
    fmt.Println(compute(3, 5, add))      // 8
    fmt.Println(compute(3, 5, multiply)) // 15
}
```

**TypeScript 对比：**
```typescript
type Operation = (x: number, y: number) => number;

const add: Operation = (x, y) => x + y;
const multiply: Operation = (x, y) => x * y;

function compute(a: number, b: number, op: Operation): number {
    return op(a, b);
}

console.log(compute(3, 5, add));      // 8
console.log(compute(3, 5, multiply)); // 15
```

### 6.2 高阶函数：函数作为参数

```go
// 过滤函数
func filter(nums []int, predicate func(int) bool) []int {
    result := []int{}
    for _, num := range nums {
        if predicate(num) {
            result = append(result, num)
        }
    }
    return result
}

// 映射函数
func mapInts(nums []int, mapper func(int) int) []int {
    result := make([]int, len(nums))
    for i, num := range nums {
        result[i] = mapper(num)
    }
    return result
}

func main() {
    numbers := []int{1, 2, 3, 4, 5, 6}
    
    // 过滤偶数
    evens := filter(numbers, func(n int) bool {
        return n%2 == 0
    })
    fmt.Println(evens) // [2 4 6]
    
    // 映射：每个数乘以 2
    doubled := mapInts(numbers, func(n int) int {
        return n * 2
    })
    fmt.Println(doubled) // [2 4 6 8 10 12]
}
```

**JavaScript 对比：**
```javascript
const numbers = [1, 2, 3, 4, 5, 6];

// 过滤偶数
const evens = numbers.filter(n => n % 2 === 0);
console.log(evens); // [2, 4, 6]

// 映射
const doubled = numbers.map(n => n * 2);
console.log(doubled); // [2, 4, 6, 8, 10, 12]
```

### 6.3 高阶函数：函数作为返回值

```go
// 返回一个乘法器函数
func multiplier(factor int) func(int) int {
    return func(x int) int {
        return x * factor
    }
}

func main() {
    double := multiplier(2)
    triple := multiplier(3)
    
    fmt.Println(double(5)) // 10
    fmt.Println(triple(5)) // 15
}
```

### 6.4 实战：中间件模式

```go
// HTTP 中间件类型
type HandlerFunc func(w http.ResponseWriter, r *http.Request)

// 日志中间件
func loggingMiddleware(next HandlerFunc) HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        next(w, r)
        fmt.Printf("[%s] %s %v\n", r.Method, r.URL.Path, time.Since(start))
    }
}

// 认证中间件
func authMiddleware(next HandlerFunc) HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        token := r.Header.Get("Authorization")
        if token == "" {
            http.Error(w, "Unauthorized", http.StatusUnauthorized)
            return
        }
        next(w, r)
    }
}

// 实际处理函数
func handleRequest(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "Hello, World!")
}

func main() {
    // 组合中间件
    handler := loggingMiddleware(authMiddleware(handleRequest))
    http.HandleFunc("/", handler)
    http.ListenAndServe(":8080", nil)
}
```

## 7. panic 和 recover

虽然 Go 推荐用 error 处理错误，但仍提供了 panic/recover 机制处理不可恢复的错误。

### 7.1 panic（恐慌）

`panic` 会立即停止当前函数执行，并开始回退调用栈（但 defer 会执行）：

```go
func divide(a, b float64) float64 {
    if b == 0 {
        panic("除数不能为 0")  // 触发 panic
    }
    return a / b
}

func main() {
    result := divide(10, 0)  // panic: 除数不能为 0
    fmt.Println(result)      // 不会执行
}
```

### 7.2 recover（恢复）

`recover` 只能在 defer 中使用，用于捕获 panic：

```go
func safeDivide(a, b float64) (result float64, err error) {
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf("panic 被捕获: %v", r)
        }
    }()
    
    result = divide(a, b)
    return
}

func main() {
    result, err := safeDivide(10, 0)
    if err != nil {
        fmt.Println("错误:", err)  // 错误: panic 被捕获: 除数不能为 0
    } else {
        fmt.Println("结果:", result)
    }
}
```

### 7.3 何时使用 panic/recover

**应该使用 panic 的场景：**
- 程序初始化失败（如配置文件损坏）
- 不可能恢复的错误（如数组越界）
- 库的内部断言失败

**应该使用 error 的场景：**
- 可预期的错误（如文件不存在）
- 可以恢复的错误
- 业务逻辑错误

```go
// ✅ 推荐：可预期的错误用 error
func openFile(filename string) (*os.File, error) {
    return os.Open(filename)
}

// ❌ 不推荐：不要用 panic 处理业务错误
func openFilePanic(filename string) *os.File {
    file, err := os.Open(filename)
    if err != nil {
        panic(err)  // 不好！
    }
    return file
}
```

## 8. 实战：函数式编程风格

```go
package main

import "fmt"

// Predicate 谓词函数类型
type Predicate func(int) bool

// Mapper 映射函数类型
type Mapper func(int) int

// Reducer 归约函数类型
type Reducer func(int, int) int

// Filter 过滤切片
func Filter(nums []int, pred Predicate) []int {
    result := []int{}
    for _, num := range nums {
        if pred(num) {
            result = append(result, num)
        }
    }
    return result
}

// Map 映射切片
func Map(nums []int, mapper Mapper) []int {
    result := make([]int, len(nums))
    for i, num := range nums {
        result[i] = mapper(num)
    }
    return result
}

// Reduce 归约切片
func Reduce(nums []int, init int, reducer Reducer) int {
    result := init
    for _, num := range nums {
        result = reducer(result, num)
    }
    return result
}

// 组合函数
func Compose(f, g Mapper) Mapper {
    return func(x int) int {
        return f(g(x))
    }
}

func main() {
    numbers := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
    
    // 链式操作：过滤偶数 -> 平方 -> 求和
    evens := Filter(numbers, func(n int) bool { return n%2 == 0 })
    squared := Map(evens, func(n int) int { return n * n })
    sum := Reduce(squared, 0, func(a, b int) int { return a + b })
    
    fmt.Println("偶数:", evens)       // [2 4 6 8 10]
    fmt.Println("平方:", squared)     // [4 16 36 64 100]
    fmt.Println("求和:", sum)         // 220
    
    // 函数组合
    addOne := func(x int) int { return x + 1 }
    double := func(x int) int { return x * 2 }
    addOneThenDouble := Compose(double, addOne)
    
    fmt.Println(addOneThenDouble(5)) // (5+1)*2 = 12
}
```

## 9. 总结

Go 的函数设计体现了**简洁性**和**实用性**。

### 核心特性回顾

1. **多返回值**：优雅地处理错误，避免异常机制
2. **命名返回值**：提高可读性，支持裸返回
3. **可变参数**：灵活处理不定数量的参数
4. **闭包**：捕获外部变量，实现状态保持
5. **defer**：确保资源清理，简化错误处理
6. **函数类型**：函数作为一等公民
7. **panic/recover**：处理不可恢复的错误

### Go vs JavaScript

| 特性 | Go | JavaScript |
|------|----|-----------| 
| 默认参数 | ❌ 不支持 | ✅ 支持 |
| 函数重载 | ❌ 不支持 | ❌ 不支持（TS 支持签名重载）|
| 多返回值 | ✅ 原生支持 | ❌ 需要对象/数组 |
| 闭包 | ✅ 支持 | ✅ 支持 |
| defer | ✅ 独有 | ❌ 用 finally |
| 错误处理 | error 返回值 | try-catch |

### 最佳实践

✅ **推荐：**
- 错误作为最后一个返回值
- 资源打开后立即 defer 关闭
- 小函数，单一职责
- 使用命名返回值提高可读性
- 避免 panic，优先使用 error

❌ **避免：**
- 在循环中使用 defer
- 滥用 panic/recover
- 过度使用闭包（性能敏感场景）
- 忽略错误返回值
- 函数名不清晰

### 常见模式

**构造函数模式：**
```go
func NewServer(addr string) *Server {
    return &Server{addr: addr}
}

func NewServerWithTimeout(addr string, timeout time.Duration) *Server {
    return &Server{addr: addr, timeout: timeout}
}
```

**选项模式（Options Pattern）：**
```go
type ServerOption func(*Server)

func WithTimeout(timeout time.Duration) ServerOption {
    return func(s *Server) {
        s.timeout = timeout
    }
}

func NewServer(addr string, opts ...ServerOption) *Server {
    s := &Server{addr: addr}
    for _, opt := range opts {
        opt(s)
    }
    return s
}

// 使用
server := NewServer(":8080", WithTimeout(5*time.Second))
```

### 进阶方向

- **泛型函数**：Go 1.18+ 支持类型参数
- **方法值和方法表达式**：将方法作为函数使用
- **函数式编程库**：如 samber/lo
- **并发模式**：goroutine 与 channel 结合

下一篇文章，我们将学习 Go 语言中最重要的类型抽象——**结构体（Struct）**，它是 Go 实现面向对象编程的基石。

---

