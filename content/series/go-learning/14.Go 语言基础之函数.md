---
title: "Go 语言基础之函数"
description: "学习 Go 语言的函数定义、多返回值、匿名函数和闭包，了解 Go 独特的错误处理方式。"
date: "2025-11-25"
seriesOrder: 14
---

# 14. Go 语言基础之函数

## 引言

在 JavaScript 中，函数是"一等公民"（First-class Citizen）。我们可以把函数赋值给变量，作为参数传递，或者作为返回值返回。

Go 语言中的函数也是一等公民，它支持匿名函数、闭包等特性。但与 JavaScript 不同的是，Go 的函数**不支持重载（Overloading）**，也不支持默认参数。

Go 函数最著名的特性是**多返回值**，这彻底改变了错误处理的方式。

## 1. 函数定义

### 1.1 基本语法

```go
// func 函数名(参数列表) (返回值列表) { ... }
func add(x int, y int) int {
    return x + y
}
```

### 1.2 参数简写

如果相邻的参数类型相同，可以省略前面的类型。

```go
// x, y 都是 int
func add(x, y int) int {
    return x + y
}
```

## 2. 多返回值 (Multiple Return Values)

这是 Go 语言最强大的特性之一。在 JavaScript 中，如果我们要返回多个值，通常会返回一个对象或数组：

```javascript
// JavaScript
function getSize() {
    return { width: 100, height: 200 };
}
```

在 Go 中，函数可以直接返回多个值。

```go
func swap(x, y string) (string, string) {
    return y, x
}

func main() {
    a, b := swap("hello", "world")
    fmt.Println(a, b) // world hello
}
```

这种特性最常用于**错误处理**。Go 的标准库函数通常返回两个值：一个是结果，一个是 `error`。

```go
file, err := os.Open("test.txt")
if err != nil {
    // 处理错误
}
// 使用 file
```

## 3. 可变参数 (Variadic Functions)

类似于 JavaScript 的 Rest Parameters (`...args`)，Go 也支持可变参数。

```go
// nums 是一个 int 切片
func sum(nums ...int) int {
    total := 0
    for _, num := range nums {
        total += num
    }
    return total
}

func main() {
    fmt.Println(sum(1, 2))      // 3
    fmt.Println(sum(1, 2, 3))   // 6
    
    // 如果已经有一个切片，可以用 ... 展开传递
    nums := []int{1, 2, 3, 4}
    fmt.Println(sum(nums...))   // 10
}
```

## 4. 匿名函数与闭包 (Closures)

Go 支持在函数内部定义匿名函数，并形成闭包。这与 JavaScript 的闭包机制几乎完全一致：**闭包可以捕获外部函数的变量**。

```go
func adder() func(int) int {
    sum := 0
    // 返回一个闭包，它捕获了 sum 变量
    return func(x int) int {
        sum += x
        return sum
    }
}

func main() {
    pos := adder()
    fmt.Println(pos(1)) // 1
    fmt.Println(pos(2)) // 3 (sum 变成了 3)
    fmt.Println(pos(3)) // 6
}
```

## 5. defer (延迟执行) —— 优雅的资源释放

这是 Go 语言独有的、非常实用的特性。

`defer` 关键字用于注册一个函数调用，这个调用会在**当前函数执行完毕返回之前**（return 之后，真正退出函数之前）执行。

### 5.1 典型场景：资源清理

在 JavaScript 中，我们通常用 `try...finally` 来确保资源被释放。

```javascript
// JavaScript
const file = openFile();
try {
    // do something
} finally {
    file.close(); // 确保关闭
}
```

在 Go 中，我们使用 `defer`，通常在打开资源后紧接着写 `defer`。

```go
func readFile(filename string) {
    file, err := os.Open(filename)
    if err != nil {
        return
    }
    // 无论函数如何退出（正常返回或 panic），file.Close() 都会执行
    defer file.Close() 

    // 读取文件...
}
```

这种写法让资源的打开和关闭代码靠在一起，极大地减少了忘记关闭资源的风险。

### 5.2 执行顺序：后进先出 (LIFO)

如果有多个 `defer` 语句，它们会按照**栈**的顺序执行（后定义的先执行）。

```go
func main() {
    defer fmt.Println("1")
    defer fmt.Println("2")
    defer fmt.Println("3")
}
// 输出:
// 3
// 2
// 1
```

## 6. 总结

Go 的函数设计非常实用：
1.  **多返回值**让错误处理变得统一且清晰。
2.  **闭包**让函数式编程成为可能。
3.  **defer** 优雅地解决了资源释放问题。

虽然没有重载和默认参数可能会让你在刚开始时觉得不便（比如需要定义 `NewClient`, `NewClientWithTimeout` 等多个函数），但这种显式的设计避免了许多隐晦的 bug。

下一篇文章，我们将学习 Go 语言中最重要的类型抽象——结构体（Struct），它是 Go 实现面向对象编程的基石。

---

**上一篇**：[13.Go 语言基础之 map](./13.Go%20语言基础之%20map.md)
**下一篇预告**：[15.Go 语言基础之结构体](./15.Go%20语言基础之结构体.md)
