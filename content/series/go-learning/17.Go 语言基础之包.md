---
title: "Go 语言基础之包"
description: "学习 Go 语言的包组织方式，了解包的概念、导入导出和与 ES Modules 的对比。"
date: "2025-11-25"
seriesOrder: 17
---

# 17. Go 语言基础之包 (Package)

在前面的文章中，我们已经学习了 Go 语言的各种基础语法。随着代码量的增加，将所有代码都写在一个 `main.go` 文件中显然是不可行的。

在前端开发中，我们使用 ES Modules (`import`/`export`) 或 CommonJS (`require`/`module.exports`) 来组织代码，将功能拆分到不同的文件和模块中。

Go 语言使用 **包 (Package)** 来组织源代码。包是 Go 语言中代码复用和封装的基本单元。

## 1. 包的概念 (Package Concept)

Go 语言中的包类似于前端项目中的一个文件夹（包含 `index.js` 或其他 `.js` 文件）。
*   **每个 Go 源文件都必须属于一个包**。
*   源文件的第一行非注释代码必须是 `package <name>`。
*   同一个文件夹下的所有 `.go` 文件必须属于同一个包（即 `package` 声明必须相同）。

### 1.1 `main` 包

*   `main` 包是一个特殊的包。
*   它定义了一个独立的可执行程序，而不是一个库。
*   `main` 包中必须包含一个 `main` 函数，这是程序的入口点。

### 1.2 库包 (Library Package)

*   非 `main` 包通常被称为库包。
*   它们提供可复用的功能，供其他包调用。
*   包名通常与文件夹名相同（虽然不是强制的，但这是惯例）。

## 2. 包的导入 (Import)

要使用其他包中的代码，需要使用 `import` 关键字。

### 2.1 单行导入

```go
import "fmt"
import "os"
```

### 2.2 分组导入 (推荐)

```go
import (
    "fmt"
    "os"
    "strings"
)
```

### 2.3 导入路径

*   **标准库**：直接使用包名，如 `"fmt"`, `"net/http"`。
*   **第三方库或自定义模块**：使用从 `go.mod` 中定义的模块路径开始的完整路径。

例如，如果你的 `go.mod` 是 `module github.com/myuser/myproject`，而你有一个子包在 `utils` 目录下：

```go
import "github.com/myuser/myproject/utils"
```

### 2.4 导入别名 (Alias)

如果导入的两个包名冲突，或者包名太长，可以给包起一个别名。这类似于前端的 `import * as utils from './utils'` 或 `import { something as other } from '...'`。

```go
import (
    "fmt"
    myfmt "github.com/myuser/myproject/fmt" // 给包起别名为 myfmt
)

func main() {
    fmt.Println("Standard library")
    myfmt.CustomPrint("My library")
}
```

### 2.5 匿名导入 (Anonymous Import)

有时我们导入一个包只是为了执行它的 `init()` 函数（进行初始化操作，如注册数据库驱动），而不需要在代码中显式调用它的任何函数。这时可以使用下划线 `_` 作为包名。

```go
import (
    "database/sql"
    _ "github.com/go-sql-driver/mysql" // 仅执行 init()，注册 MySQL 驱动
)
```

如果不使用 `_` 且代码中没有使用该包，Go 编译器会报错（Go 不允许导入未使用的包）。

### 2.6 点导入 (Dot Import) - 不推荐

可以使用 `.` 来导入包，这样可以直接使用包中的函数而不需要包名前缀。这类似于前端的 `import { * }` (虽然 JS 没有这种语法，但类似把所有 export 混入当前作用域)。

```go
import . "fmt"

func main() {
    Println("Hello") // 不需要 fmt.Println
}
```

**注意**：通常不推荐使用点导入，因为它会污染命名空间，使代码难以阅读（不知道函数来自哪个包）。通常只在测试文件中使用（如 Gomega/Ginkgo 测试框架）。

## 3. 可见性 (Visibility / Exported Names)

我们在之前的文章中多次提到过，Go 语言使用 **首字母大小写** 来控制访问权限（可见性）。

*   **大写字母开头**：**导出 (Public)**。可以被外部包访问。类似于 `export const MyVar = ...`。
*   **小写字母开头**：**未导出 (Private)**。只能在当前包内部访问。类似于不 `export` 的变量。

```go
// math/calc.go
package math

// Add 是导出的，因为首字母大写
func Add(a, b int) int {
    return a + b
}

// sub 是未导出的，只能在 math 包内部使用
func sub(a, b int) int {
    return a - b
}
```

```go
// main.go
package main

import (
    "fmt"
    "myproject/math" // 假设路径正确
)

func main() {
    fmt.Println(math.Add(1, 2)) // OK
    // fmt.Println(math.sub(1, 2)) // Error: cannot refer to unexported name math.sub
}
```

这是一种非常简洁且强制性的访问控制机制，不需要 `public`, `private`, `protected` 等关键字。

## 4. `init` 函数

每个包可以包含一个或多个 `init` 函数。

*   `init` 函数没有参数也没有返回值。
*   `init` 函数不能被显式调用。
*   **执行时机**：在 `main` 函数执行之前，Go 运行时会自动调用所有导入包的 `init` 函数。
*   **执行顺序**：
    1.  初始化导入的包（递归）。
    2.  初始化包级别的变量。
    3.  执行 `init` 函数。

```go
package main

import "fmt"

var myVar = setupVar()

func setupVar() string {
    fmt.Println("1. Initializing variable")
    return "Hello"
}

func init() {
    fmt.Println("2. Executing init function")
}

func main() {
    fmt.Println("3. Executing main function")
}
```

**输出：**
```
1. Initializing variable
2. Executing init function
3. Executing main function
```

**前端类比**：这有点像模块加载时执行的顶层代码。在 Node.js 中，当你 `require` 一个模块时，模块内的代码会立即执行。`init` 函数提供了一个专门的地方来放置这些初始化逻辑。

## 5. Go 项目的标准目录结构 (Standard Project Layout)

虽然 Go 编译器不强制要求特定的目录结构，但 Go 社区有一套广泛遵循的标准项目布局（Standard Go Project Layout）。

### 5.1 简单项目

对于简单的项目，所有文件可以直接放在根目录下。

```
myproject/
  go.mod
  main.go
  utils.go
```

### 5.2 标准结构 (适用于中大型项目)

```
myproject/
├── cmd/                # 应用程序入口
│   ├── myapp/          # 主应用
│   │   └── main.go
│   └── worker/         # 另一个应用（如后台 worker）
│       └── main.go
├── pkg/                # 可以被外部项目使用的库代码 (Public Library)
│   ├── utils/
│   └── api/
├── internal/           # 私有库代码 (Private Library)
│   ├── config/
│   └── service/
├── api/                # OpenAPI/Swagger 规范，Proto 文件等
├── web/                # 前端静态资源
├── scripts/            # 构建、安装、分析脚本
├── go.mod
└── go.sum
```

*   **`cmd/`**: 存放 `main` 包。通常每个子目录对应一个可执行文件。这里的代码应该尽量少，主要负责调用其他包的代码。
*   **`pkg/`**: 存放可以被其他项目导入的库代码。如果你希望你的代码被别人使用，放在这里。
*   **`internal/`**: 这是一个特殊的目录名。Go 编译器会强制执行访问控制：**`internal` 目录下的包只能被其父目录下的包导入**，不能被外部项目导入。这非常适合存放项目私有的、不希望公开 API 的代码。

## 6. 总结

*   **包 (Package)** 是 Go 代码组织的基本单元。
*   **`main` 包** 是程序的入口。
*   **导入 (Import)** 用于使用其他包。支持别名导入和匿名导入。
*   **可见性** 由标识符的首字母大小写决定（大写导出，小写私有）。
*   **`init` 函数** 用于包的初始化，在 `main` 之前自动执行。
*   **`internal` 目录** 提供了编译器级别的私有性保护。

掌握包的使用和项目结构的组织，是编写可维护、可扩展 Go 项目的关键。

---

至此，我们已经完成了 Go 语言基础系列的 17 篇文章。从环境搭建、基础语法、数据结构、函数、结构体、接口到包管理，我们涵盖了 Go 语言开发的核心知识点。

作为前端开发者，你应该已经发现 Go 语言在很多方面与 JavaScript/TypeScript 有着异曲同工之妙，但又在类型系统、并发模型和工程化方面有着独特的设计哲学。

希望这个系列教程能帮助你顺利开启 Go 语言的学习之旅！Happy Coding!
