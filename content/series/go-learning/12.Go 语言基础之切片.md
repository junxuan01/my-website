---
title: "Go 语言基础之切片"
description: "深入学习 Go 语言最重要的数据结构——切片，了解其底层原理和与 JavaScript Array 的区别。"
date: "2025-11-25"
seriesOrder: 12
---

# 12. Go 语言基础之切片

## 引言

在上一篇文章中，我们了解到 Go 语言的数组是固定长度的值类型，这在实际开发中非常不便。

为了解决这个问题，Go 引入了 **切片 (Slice)**。切片是 Go 语言中最重要、最常用的数据结构。你可以把它看作是**动态数组**，它拥有数组的所有优点（索引访问快），同时又具备动态扩容的能力。

对于前端开发者来说，切片用起来非常像 JavaScript 的 Array，但在底层原理上，它们有着本质的区别。

## 1. 什么是切片？

切片（Slice）本身并不是数组，它是一个**指向底层数组的窗口（引用）**。

### 1.1 内部结构

切片在内存中是一个很小的结构体，包含三个字段：
1.  **指针 (Pointer)**: 指向底层数组中切片开始的那个元素。
2.  **长度 (Length)**: 切片当前包含的元素个数。使用 `len()` 获取。
3.  **容量 (Capacity)**: 从切片开始位置到底层数组末尾的元素个数。使用 `cap()` 获取。

### 1.2 声明方式

切片的声明语法与数组非常像，唯一的区别是**方括号里没有数字**。

```go
// 数组：必须指定长度
var arr [5]int

// 切片：不需要指定长度
var s []int
```

## 2. 创建切片的三种方式

### 2.1 直接声明（字面量）

这是最常用的方式，类似于 JS 的数组字面量。

```go
s := []int{1, 2, 3}
```
Go 编译器会在底层创建一个长度为 3 的数组，并返回一个指向它的切片。

### 2.2 基于数组创建

你可以通过对数组进行"切分"来创建切片。

```go
arr := [5]int{10, 20, 30, 40, 50}
// 取索引 1 到 3 的元素（左闭右开，包含 1，不包含 3）
s := arr[1:3] 
// s 的值: [20, 30]
// len(s): 2
// cap(s): 4 (从索引 1 开始到数组末尾：20, 30, 40, 50)
```

### 2.3 使用 make 函数

如果你需要动态创建一个切片，可以使用 `make`。

```go
// make([]T, len, cap)
s := make([]int, 5, 10)
// 创建一个长度为 5，容量为 10 的 int 切片
// 初始值全为 0
```

## 3. 切片的核心操作

### 3.1 append (追加元素)

类似于 JS 的 `push`，但在 Go 中，`append` 是一个内置函数，且**必须将返回值赋值回原切片**。

```go
var s []int
s = append(s, 1)       // [1]
s = append(s, 2, 3, 4) // [1 2 3 4]

// 追加另一个切片 (类似于 JS 的 ... 展开运算符)
s2 := []int{100, 200}
s = append(s, s2...)   // [1 2 3 4 100 200]
```

**扩容机制**：
当切片的容量不足以容纳新元素时，Go 会自动创建一个更大的底层数组（通常是原来的 2 倍），将旧数据复制过去，然后追加新数据。这就是切片"动态"的秘密。

### 3.2 copy (复制切片)

由于切片是引用类型，简单的赋值 `s2 := s1` 只是复制了指针，它们依然指向同一个底层数组。如果你需要深拷贝，必须使用 `copy` 函数。

```go
s1 := []int{1, 2, 3}
s2 := make([]int, len(s1))
copy(s2, s1) // 将 s1 复制到 s2
```

## 4. 关键区别：JS Array.slice vs Go Slice

这是前端开发者最容易混淆的地方。

-   **JavaScript**: `arr.slice(1, 3)` 会返回一个新的数组，它是原数组的一个**浅拷贝**。修改新数组**不会**影响原数组。
    ```javascript
    let a = [1, 2, 3];
    let b = a.slice(0, 1);
    b[0] = 99;
    console.log(a[0]); // 1 (a 没有变)
    ```

-   **Go**: `arr[1:3]` 返回的是原数组的一个**视图（View）**。修改切片**会**影响底层数组，进而影响其他共享该数组的切片。
    ```go
    a := [...]int{1, 2, 3}
    b := a[:] // b 指向 a
    b[0] = 99
    fmt.Println(a[0]) // 99 (a 变了！)
    ```

**这是一个巨大的坑，请务必记住！**

## 5. nil 切片 vs 空切片

-   **nil 切片**: 声明了但未初始化。`var s []int`。`s == nil` 为 true。
-   **空切片**: 初始化了但长度为 0。`s := []int{}` 或 `s := make([]int, 0)`。`s == nil` 为 false。

在功能上，它们几乎一样（都可以 append，len 都是 0），但在 JSON 序列化时有区别：
-   nil 切片序列化为 `null`。
-   空切片序列化为 `[]`。

## 6. 总结

切片是 Go 语言中最强大的工具之一。
1.  它是**引用类型**，传递成本极低。
2.  它支持**动态扩容** (`append`)。
3.  它是**底层数组的视图**，修改切片可能影响原数组。

掌握了切片，你就掌握了 Go 数据处理的半壁江山。下一篇文章，我们将学习另一个重要的数据结构——Map（映射）。

---

**上一篇**：[11.Go 语言基础之数组](./11.Go%20语言基础之数组.md)
**下一篇预告**：[13.Go 语言基础之 map](./13.Go%20语言基础之%20map.md)
